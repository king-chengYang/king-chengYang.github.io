<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hbase模式设计</title>
      <link href="/2020/02/08/Hbase%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/02/08/Hbase%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="模式设计"><a href="#模式设计" class="headerlink" title="模式设计"></a>模式设计</h2><p>行键在HBase中充当表的一级索引，而且HBase本身没有提供二级索引机制，因此对行键的设计优化对实时查询尤为重要。</p><p>HBase系统架构通过写内存，排序，顺序写磁盘提高写性能，但是以牺牲读性能为代价，因为内存中的数据最终会刷为StoreFile，有很多个StoreFile来存储数据，读取数据时可能需要读取多个StoreFile来查找所需要的数据。</p><h3 id="行键设计"><a href="#行键设计" class="headerlink" title="行键设计"></a>行键设计</h3><p>HBase数据按照行键字典序自然排序，这对扫描操作是一个优化。行键也是HBase最有效的索引，且不支持二级索引。HBase行键设计的原则：</p><ul><li><strong>唯一原则</strong>：行键对应关系型数据库的唯一键（主键），系统设计之处必须考虑有足够的唯一行键去支持业务的数据量</li><li><strong>长度原则</strong>：长度适中，建议使用定长，方便从行键提取所需数据，而无需查询出数据内容以节省网络开销</li><li><strong>散列原则</strong>：避免递增，否则读写负载均衡会集中在某个热点分区，降低性能，甚至引起分区服务器过载而宕机</li></ul><h3 id="规避热点区间"><a href="#规避热点区间" class="headerlink" title="规避热点区间"></a>规避热点区间</h3><p>生产环境下用户ID的生成规则通常是一个递增的数字（用户系统一般基于关系型数据库，用户ID一般MySql等数据库提供的自增主键）。因此会出现一些热点问题：</p><ul><li>新注册的用户一般比较活跃，而新注册的用户根据用户ID分区会分到一个分区上，当新用户产生比较多的日志数据时，分区服务器会承受较大的读写压力。</li></ul><p>再例如订单系统使用时间戳作为分区依据，则旧订单可能会很少访问，而新订单的访问会很多，则新订单服务器会有很大的读写压力。</p><p>下面是两种常见的避免热点区间的方法</p><ul><li><strong>加盐</strong>：在行键前面加上随机数字或者字母，使得数据随机分配到不同的分区。而这种方法的缺点就是，当插入数据再读取数据时，需要在插入时保存一个原始业务行键与添加的随机数的映射关系，或者使用某种散列函数计算原始业务行键的散列值，然后将该散列值的随机数作为行键的前缀。使用这种行键设计的应用通常只是用来做一些分析统计，因此一般实时在线系统不建议使用该行键设计方式</li><li><strong>反转补齐</strong>：将用户ID反转（如123装为321）可以将变化最多的部分放在行键前面，这样的数据的写入也能够顺序地流入各个分区而使得集群负载比较均衡。反转补齐是避免热点区间常用的方法。因为用户ID一般都使用关系型数据库的自增主键，长度一般为20个数字，所以为了使得行键保持定长以方便排序以及可以从行键反推出用户ID，通常会将用户ID反转后在末尾加0补齐20个数字。如果使用时间戳作为行键的一部分，则可以使用“Long.MAX_VALUE-时间戳”，这样最新时间戳的数据行键值较小，数据行能够排在数据存储前列。</li></ul><h3 id="高表与宽表"><a href="#高表与宽表" class="headerlink" title="高表与宽表"></a>高表与宽表</h3><table><thead><tr><th></th><th>高表</th><th>宽表</th></tr></thead><tbody><tr><td>定义</td><td>数据每行包含的列比较少而行比较多的表</td><td>数据每行包含的列比较多而行比较少的表</td></tr><tr><td>查询性能对比</td><td>√</td><td></td></tr><tr><td>负载均衡对比</td><td>√</td><td></td></tr><tr><td>元数据对比</td><td></td><td>√</td></tr><tr><td>事务支持对比</td><td></td><td>√</td></tr></tbody></table><ul><li>查询性能：由于行键是HBase最有效的索引，而高表行比较多，行键比较多，过滤效果更好，并且每行数据更少，因此读取每个数据块可以包含更多的行，并且块缓存或者堆外缓存也可以缓存更多的行</li><li>负载均衡：HBase分区由行键区间决定，更多行可以使得区间粒度更细，分区大小更合适，负载更均衡</li><li>元数据：高表分区更多会导致元数据更多，HBase元数据表更大，可能会给HBase集群主节点HMaster与HBase客户端带来更大压力</li><li>事务支持：HBase只支持行级事务，因此对宽表的一行数据变更操作能够提供事务保证，而高表对多行数据变更无事务支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2020/02/04/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/02/04/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型（JMM）是Java虚拟机定义的，试图屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能达到一致的内存访问效果。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这些变量包括<strong>实例字段，静态字段，构成数组对象得元素</strong>，即线程共享得变量。</p><p>java虚拟机规定</p><ul><li>所有的变量都存储在主内存中</li><li>每个线程又自己的工作内存</li><li>线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</li><li>线程之间无法相互访问，必须通过主内存完成</li></ul><p><img src="%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" alt=""></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节，java内存模型中定义8种操作完成</p><ul><li>lock（锁定）：<strong>作用于主内存变量</strong>，把一个变量标识为一条线程独占状态</li><li>unlock（解锁）：<strong>作用于主内存变量</strong>，把一个处于锁定状态的变量释放出来，释放后可被其他线程锁定</li><li>read（读取）：<strong>作用于主内存变量</strong>，将一个变量的值从主内存传输到线程的工作内存中</li><li>load（载入）：<strong>作用于工作内存变量</strong>，将read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use（使用）：<strong>作用于工作内存变量</strong>，当使用该变量时会执行该操作，将工作内存中变量的值传递给执行引擎</li><li>assign（赋值）：<strong>作用于工作内存变量</strong>，当给该变量复制时执行该操作，将从执行引擎收到的值赋值给变量</li><li>store（存储）：<strong>作用于工作内存变量</strong>，把工作内存中一个变量的值传送到主内存中</li><li>write（写入）：<strong>作用于主内存变量</strong>，将store操作从工作内存中得到的变量的值放入主内存变量中</li></ul><p>而执行上述的8种基本操作还需要满足以下规则</p><ol><li>read和load顺序执行，store和write顺序执行，且不允许这四个操作单独出现</li><li>变量在工作内存中改变之后必须把该变化同步回主内存</li><li>新的变量只能在主内存中诞生</li><li>如果对一个变量执行lock操作，那么会清空工作内存中此变量的值，在执行引擎使用该变量时，需要重新执行load或assign操作初始化该变量</li><li>对一个变量执行unlock操作之前，必须把此变量同步回主内存中</li></ol><h3 id="对long和double型变量特殊规则"><a href="#对long和double型变量特殊规则" class="headerlink" title="对long和double型变量特殊规则"></a>对long和double型变量特殊规则</h3><p>Java内存模型要求上诉8各操作都具有原子性，但对于64位的数据类型(long和double)有如下宽松规定</p><ul><li>允许虚拟机没有被volatile修饰的64位数据的读写分为两次32位的操作</li></ul><p>虽然java内存模型允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，因此未声明未volatile的long和double类型的变量，在多个线程读取修改时，不会出现并发导致的数据不一致问题。</p><h3 id="原子性，可见性与有序性"><a href="#原子性，可见性与有序性" class="headerlink" title="原子性，可见性与有序性"></a>原子性，可见性与有序性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性即要么不执行，要么执行中不可被中断直到执行完毕。java内存模型直接保证原子性变量操作有read，load，assign，use，store，write。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p><p>java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值，这种依赖主内存作为传递媒介的方式实现可见性。</p><ul><li>volatile关键字保证了新值立即同步到主内存，以及每次使用前立即从主内存刷新，volatile可以保证可见性</li><li>synchronized关键字需要使用lock和unlock操作，lock操作需要清空工作内存变量值，再从主内存同步，而unlock操作之前，必须把此变量同步回主内存，synchronized可以保证可见性</li><li>final关键字也可以保证可见性</li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java语言提供volatile和synchronized两个关键字保证线程之间操作的有序性</p><ul><li>volatile关键字禁止指令重排</li><li>synchronized保证一个变量在同一时刻只允许一条线程对其进行lock操作，因此持有同一个锁的两个同步块只能串行进入</li></ul><h3 id="先行先发生原则"><a href="#先行先发生原则" class="headerlink" title="先行先发生原则"></a>先行先发生原则</h3><p>先行发生是java内存模型中定义的两项操作之间的偏序关系, 如果操作A先行发生于操作B之前,是指操作A产生的影响能被操作B观察到,影响包括修改内存中共享变量的值,发送了消息,调用了方法.</p><p>下面是一些虚拟机保证的先行发生关系,虚拟机可以对他们随意进行重排序</p><ul><li><strong>程序次序规则:</strong>  在一个线程内,按照程序代码顺序执行,代码逻辑上的先后</li><li><strong>管程锁定规则:</strong>  一个unlock操作先行发生于后面对同一个锁的lock操作</li><li><strong>volatile变量规则:</strong>  对一个volatile变量的写操作先行发生于后面对这个变量的读操作,时间上的先后</li><li><strong>线程启动规则:</strong>  线程的start()方法先行发生于此线程的每一个动作</li><li><strong>线程终止规则:</strong>  线程的所有操作都先行发生于对此线程的终止检测</li><li><strong>线程中断规则:</strong>  对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li><strong>对象终结规则:</strong>  对一个线程初始化完成,先行发生于它的finalize()方法的开始</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字</title>
      <link href="/2020/02/04/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/02/04/java%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final可以修饰类，方法和变量（局部变量和成员变量）</p><ul><li>当用final修饰一个类时，表明这个类不能被继承。</li><li>当用final修饰一个方法时，子类无法覆盖该方法</li><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h2><p><strong>try+catch</strong></p><p>运行流程：运行到try块中，如果有异常抛出，则转到catch块去处理，如果没有异常，执行catch块后面的语句</p><p>*<em>try+catch+finally *</em></p><p>运行流程：运行到try块中，如果有异常抛出，则转到catch块,catch块执行完毕后，执行finally块的代码，再执行finally块后面的代码。如果没有异常抛出，执行完try块，再执行finally块的代码，然后执行finally块后面的语句 </p><p> *<em>try+finally *</em></p><p>运行流程：运行到try块中,如果有异常抛出的话，程序转向执行finally块的代码，然后方法就以抛出异常的方式退出。 </p><p><strong>try和finally中return问题</strong></p><p>try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回，因此当finally中有return语句时，会覆盖try中的return结果</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问</p><p>static可以修饰方法，变量，代码块</p><ul><li>修饰变量：所有类的对象共有，即类的变量，对于静态变量在内存中只有一个拷贝，JVM只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配</li><li>修饰方法：所有类对象共有，即类的方法，静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。</li><li>修饰代码块：static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized可以修饰代码块，方法，静态方法，类</p><ol><li><p>修饰一个代码块，作用的对象是调用这个代码块的对象</p><p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。</p></li><li><p>修饰一个方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p><p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized方法时，再同一时刻只有一个线程得到执行，另一个线程阻塞，必须等待当前线程执行完这个方法以后才能执行该方法。</p></li><li><p>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</p></li><li><p>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p></li></ol><p>synchronized可以保证原子性，可见性，有序性。</p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient关键字只能修饰变量，而不能修饰方法和类</p><ul><li>被transient修饰的变量，该变量无法序列化</li><li>transient修饰的变量如果是自定义变量，则该类需要实现Serializable接口</li><li>静态变量不论是否使用transient修饰，均不能序列化</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile修饰变量时有两个重要的特性</p><ul><li>保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对于其他下次你哼来说时可以立即得到的。普通变量的值再线程间传递均需要通过主内存完成。</li><li>禁止指令重排优化，普通变量仅仅会保证在该方法的执行过程所有依赖赋值结果的地方能获得正确的结果，而不能保证变量赋值操作的顺序与程序代码的执行顺序一致</li></ul><p>即valatile可以实现的可见性，有序性，不能实现原子性</p><h2 id="interface与abstract"><a href="#interface与abstract" class="headerlink" title="interface与abstract"></a>interface与abstract</h2><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>interface只能修饰类，有如下特点</p><ul><li>接口中方法，变量的默认为public abstract类型</li><li>不能实例化对象</li><li>无构造方法</li><li>所有的方法必须是抽象的</li><li>无静态代码和静态方法</li></ul><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>abstract可以修饰类和方法，具有如下特点</p><ol><li>abstract class不能创建实例对象</li><li>含有abstract方法的类必须定义为abstract class，但abstract class类中的可以包含非抽象类</li><li>abstract类中定义的抽象方法必须在具体子类中实现，所以不能有抽象的构造方法和抽象的静态方法</li><li>如果子类没有实现父类的abstract方法，那么子类也必须定义为abstract类型</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>（1）抽象类可以有构造方法，但接口不能有构造方法；</p><p>（2）抽象类可以有普通成员变量，但接口没有普通成员变量；</p><p>（3）抽象类中可以包含非抽象的普通方法，而接口中的方法必须都是抽象的、不能有非抽象的方法；</p><p>（4）抽象类中的抽象方法的访问类型可以是public、protected，但接口中的抽象方法只能是public类型且默认为public abstract类型；</p><p>（5）抽象类中可以包含静态方法，而接口中不能包含静态方法；</p><p>（6）抽象类和接口都可以包含静态成员变量，抽象类的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认为public static final类型；</p><p>（7）一个类可以实现多个接口，但只能继承一个抽象类；</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>子类拥有父类非 private 的属性、方法。默认的属性和方法无法访问</li><li>子类可以访问父类中protected的方法</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</li><li>子类可以以自己的方式实现父类的方法</li><li>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写</li><li>子类不能缩小父类方法的访问权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的锁机制</title>
      <link href="/2020/02/04/java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/02/04/java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 悲观锁"></a>乐观锁 悲观锁</h2><p><strong>悲观锁：</strong>认为自己使用数据时一定有别的线程修改数据，因此在获取数据前一定会加锁，确保数据不会被别的线程修改，例如synchronized关键字</p><p><strong>乐观锁：</strong>认为自己使用数据时不会有别的线程修改数据，在获取数据时不会加锁，而在更新数据时会判断之前有没有别的线程更新了这个数据。如果没有被更新，则修改数据；如果更新了，可根据不同情况执行不同操作，例如CAS算法</p><p><img src="%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81.png" alt=""></p><p>应用场景</p><ul><li>悲观锁适合写操作多的场景</li><li>乐观锁适合读操作多的场景</li></ul><h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>CAS算法涉及三个操作数</p><ul><li>内存中的数据A</li><li>需要更新的数据B</li><li>需要比较的数据C</li></ul><p>CAS算法步骤：读取内存中数据A，将A与需要比较的数C比较，如果A与C相等，更新内存数据为B，否则不更新</p><p>CAS算法涉及的问题</p><ul><li><strong>ABA问题：</strong>内存中的数先由A改为B，再由B改回A，实际上操作数已经被改变了，但只对比数据会更新数据。解决方法是可以加上版本号</li><li><strong>只能保证一个共享变量的原子操作</strong></li><li><strong>循环时间长开销大：</strong>CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li></ul><h2 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁 适应性自旋锁"></a>自旋锁 适应性自旋锁</h2><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程都需要转入内核态完成，这些操作给系统的并发性能带来很大压力。</p><p>为了让线程等待，我们可以让线程执行一个忙循环（自旋），即线程不满足条件时在while循环中等待，满足条件了再执行自己的代码。自旋等待避免了线程切换的开销，但它会占用处理器的时间。因此，如果锁被占用的时间很短，则会提高性能，如果锁占用时间很长，则自旋会白白浪费处理器资源。</p><p>自适应的自旋锁，其自旋的时间不再固定，而是由前一次再同一个锁上的自旋时间及锁的拥有者的状态决定。</p><h2 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 偏向锁 轻量级锁 重量级锁"></a>无锁 偏向锁 轻量级锁 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。</p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。CAS就是无锁的实现。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><p><img src="%E9%94%81%E7%8A%B6%E6%80%81.png" alt=""></p><ul><li>无锁可以利用CAS操作实现加锁</li><li>偏向锁是记录线程id判断是否是一个线程访问解决加锁问题</li><li>轻量级锁通过CAS和自旋解决加锁问题</li><li>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</li></ul><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 非公平锁"></a>公平锁 非公平锁</h2><p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，即先来先获得锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p><strong>非公平锁</strong>是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 不可重入锁"></a>可重入锁 不可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁。</p><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁 共享锁"></a>独享锁 共享锁</h2><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。例如ReentrantReadWriteLock中的写锁</p><p>共享锁是指该锁可被多个线程所持有。例如ReentrantReadWriteLock中的读锁</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 同步问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2019/12/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/12/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="一-操作系统概述"><a href="#一-操作系统概述" class="headerlink" title="一.操作系统概述"></a>一.操作系统概述</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统目前有五大类型：<strong>批操作系统，分时系统，实时系统，网络操作系统，分布式系统</strong></p><p>操作系统的特征：</p><ul><li>并发<ul><li>并发：多个程序在同一时间段发生</li><li>并行：多个程序在同一时刻发生。单处理器进程交替进行；多处理器进程可重叠执行</li></ul></li><li>共享</li><li>虚拟</li><li>异步</li></ul><p><strong>设备独立性：</strong>用户程序使用的设备与实际使用哪台设备无关的一种特性</p><p>操作系统的主要功能：</p><ul><li>资源管理：处理器管理，存储器管理，设备管理，文件管理</li><li>提供用户接口：命令接口，图形用户接口，系统调用</li><li>以进程的方式组织用户使用计算机</li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统提供给用户的接口有<strong>命令接口</strong>，<strong>系统调用</strong>，<strong>图形接口</strong></p><p><strong>系统调用（程序接口API）：</strong>用户可以利用系统提供的一组系统调命令，来调用OS内核中的一个或一组过程以完成自己需要的功能。可以被看做一个内核与用户空间交互的接口。</p><h2 id="二-进程管理"><a href="#二-进程管理" class="headerlink" title="二.进程管理"></a>二.进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：是资源分配的独立单位，是调度的基本单位，<strong>资源分配的最小单位</strong></p><p>线程：是CPU调度和执行的最小单位，<strong>CPU调度的最小单位</strong></p><p>引入进程与线程的原因</p><ul><li>引入进程是为了使多个程序能够并发的运行，提高资源利用率和系统吞吐量，增加并发程度</li><li>引入线程是为了减少进程切换和创建，撤销进程的开销，提高执行效率，并发性能和节省资源</li></ul><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程主要由<strong>程序段，数据，进程控制块PCB</strong>三部分组成，其中PCB进程控制块是进程存在的唯一标志，数据部分可以与其它进程共享</p><p>进程的创建：申请空白PCB，分配资源，初始化PCB，将进程插入到就绪队列</p><p>进程的终止：设置进程状态为终止，终止其子进程，回收进程占用的资源，删掉它的PCB</p><p>进程与程序的根本区别是：静态与动态的特点</p><p>进程的状态：</p><ul><li>运行态：进程正在使用计算机</li><li>就绪态：进程具备运行条件，但尚未被调度</li><li>阻塞态（等待态）：进程由于等待某一事件或者等待I/O操作不能运行时而进入阻塞态</li></ul><p>进程通信：</p><ul><li><p>共享存储器系统</p><p>在共享存储器系统中，相互通信的进程共享某些存储区，进程之间能够通过这些空间进行通信</p><ul><li>基于共享数据结构方式</li><li>基于共享存储区方式</li></ul></li><li><p>管道通信</p><p>管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件</p></li><li><p>消息传递系统</p><p>进程间的数据交换，以格式化的消息为单位</p><ul><li>直接通信方式</li><li>间接通信方式</li></ul></li></ul><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>原语：是由若干指令组成的，用于完成一定特定功能的一个过程，原语执行是连续的不被中断的。</p><p>进程同步的目的：协调不同进程的运行次序，使得进程能够有效的共享资源并且相互合作</p><p><strong>并发进程的两种关系：</strong>（间接制约）互斥与（直接制约）同步</p><p><strong>临界资源：</strong>需要进程互斥的访问的计算机资源，进程通过互斥的方式对资源进行共享，例如打印机</p><p><strong>临界区：</strong>每个进程访问临界资源的那段代码</p><p>同步机制遵循的规则：<strong>空闲让等，忙则等待，有限等待，让权等待</strong></p><h3 id="同步经典例子"><a href="#同步经典例子" class="headerlink" title="同步经典例子"></a>同步经典例子</h3><pre><code>P:wait(S){    S = S-1;    if(S&lt;0)        挂起}V:signal(S){    S = S+1;    if(S&lt;=0)        唤醒}</code></pre><p>PV操作中互斥量设置为1，同步信号量若期望的消息尚未产生，则对应的初值应为0，若期望的消息已经存在，则信号量初值设置为存在的数目。</p><p>生产者消费者问题</p><pre><code>参数：    empty表示缓冲区是否为空，初值为n；    full表示缓冲区是否为满，初值为0;    互斥信号量mutex=1生产者：producer(){    while(1){        生产一个产品；        P(empty);        P(mutex);        将产品放入缓冲区        V(mutex);        V(full);    }}消费者：consumer(){    while(1){        P(full);        P(mutex);        将产品从缓冲区读出        V(mutex);        V(empty);        消费产品    }}</code></pre><p>读者-写者问题（当写者发起请求时，后续读者都只能在队列中等待，直到写者完成）</p><pre><code>参数：    readcount记录读者数量，初始为0；    mutex为互斥信号量，用于保护更新readcount变量时的互斥；    rw为读写互斥信号量；    canoperate为可进入文件进行操作的互斥信号量；读者：begin    P(canoperate);    P(mutex);    readcount++;    if(readcount == 1)        P(rw);    V(mutex);    P(canoperate);    读文件    P(mutex)    readcount--;    if(readcount == 0)        V(rw);    V(mutex);end;写者：begin    P(canoperate);    P(rw);    V(canoperate);    写文件    V(rw);</code></pre><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><h4 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h4><ul><li>高级调度：作业调度或者长程调度，以作业为单位从外存调入内存</li><li>中级调度：内存与外存对换区交换内容，从存储器资源的角度，将进程的部分或全部内容换出到外存上，将当前进程所需部分内容换入到内存</li><li>低级调度：从就绪队列中选择一个等待CPU的进程并分配CPU给它</li></ul><h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><ol><li>CPU利用率：CPU的负荷</li><li>吞吐量：一个时间单元内完成的进程的数量</li><li>周转时间：从进程提交到进程完成的时间</li><li>等待时间：在就绪队列中等待的时间</li><li>响应时间：从提交申请到产生第一响应的时间</li></ol><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ul><li><p>先来先服务调度算法（FCFS）</p></li><li><p>短作业优先调度算法（SJF）</p><p>平均等待时间，平均周转时间最短</p></li><li><p>优先级调度算法</p><p>老化技术：使作业的优先级随着等待时间的增加而提高</p></li><li><p>时间片轮转调度算法：进程循环获得时间片</p></li><li><p>多级队列调度：将就绪队列分成多个独立队列，每个队列根据情况使用不同的调度算法</p></li><li><p>多级反馈队列调度：</p><p>有三个队列0，1，2。调度程序会先执行队列0中的进程，未执行完的进程进入队列1，只有当0中没有进程时，才能执行队列1中的进程。同样，在队列1中没有执行完的进程进入队列2，只有0，1都没有进程时，才执行队列2中的进程。</p><p>到达0中的进程可以抢占队列1中的进程。而队列1中的进程没执行完或者被队列0中的进程抢占，都让该进程进入到队列中</p></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>进程-资源图表达的系统状态S为死锁状态的充分必要条件是<strong>当且仅当S状态的资源分配图不可完全简化</strong></p><p>产生死锁的原因：</p><ul><li>系统资源不足</li><li>进程推进顺序不当</li></ul><p>产生死锁的必要条件</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不可剥夺条件</li><li>循环等待</li></ul><p>处理死锁的方法</p><ul><li><p>预防死锁：破坏四个必要条件</p><ul><li>破坏互斥条件：资源共享</li><li>破坏”请求和保持条件“：<strong>静态资源分配法</strong>，申请资源之前，一次性申请全部资源</li><li>破坏”不可剥夺“条件：当新的资源请求得不到满足，则释放已有资源</li><li>破坏”循环等待“条件：<strong>有序资源分配法</strong>，将系统资源按类型编号，所有进程必须按照资源序号递增的次序申请资源，同类资源一次申请完。</li></ul></li><li><p>死锁避免：银行家算法</p></li><li><p>检测和解除死锁：</p><p>允许死锁发生，系统不断检测</p><p>发生死锁后，解除死锁：资源剥夺法，撤销进程法</p></li></ul><h2 id="三-内存管理"><a href="#三-内存管理" class="headerlink" title="三.内存管理"></a>三.内存管理</h2><h3 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h3><h4 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h4><p>程序装入的过程</p><ul><li>编译</li><li>链接：由链接程序将编译后形成的一组目标模块，和所需库函数链接在一起，形成一个完整的装入模块</li><li>装入：由装入程序将程序装入模块</li></ul><p>程序装入的方式</p><ul><li><p>绝对装入</p><p>在编译时就知道程序在内存中的地址，编译程序产生绝对地址的目标代码。程序中的逻辑地址与实际地址完全相同</p></li><li><p>静态重定位装入</p><p>装入时将目标代码中的指令地址和数据地址转换成绝对地址。地址变换在装入时一次完成</p></li><li><p>动态重定位装入</p><p>装入时程序的地址为相对地址，只有程序在运行时，会将相对地址转换位绝对地址，需要重定位寄存器支持。</p></li></ul><h4 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h4><ul><li><p>静态链接</p><p>程序装入之前，将各模块与所需的库函数链接</p></li><li><p>装入时动态链接</p><p>装入内存时，采用边装入边链接的方式</p></li><li><p>运行时动态链接</p><p>程序执行时需要该模块时，才对它进行链接</p></li></ul><h4 id="逻辑地址-物理地址"><a href="#逻辑地址-物理地址" class="headerlink" title="逻辑地址 物理地址"></a>逻辑地址 物理地址</h4><p>编译之后，每个目标模块都是从0号开始编址，称为该模块的相对地址</p><p>逻辑地址：用户的程序经过汇编或编译后形成目标模块，模块的相对地址即为逻辑地址</p><p>物理地址：内存中存储单元的地址，物理地址可以直接寻址</p><p>地址映射（重定位）：将用户程序的逻辑地址转换为运行时由机器直接寻址的物理地址的过程</p><p>静态重定位和动态重定位属于操作系统重定位</p><ul><li>静态重定位（静态重定位装入）：装入一个作业时，将作业中指令地址和数据地址全部转换为绝对地址<ul><li>无需硬件支持</li><li>程序在内存中只能连续存储</li><li>程序经地址重定位后不能移动，也不能再申请内存空间</li></ul></li><li>动态重定位（动态重定位装入）：装入一个作业时，不进行地址转换。当程序执行时，每执行一条指令就将相对地址由<strong>重定位寄存器</strong>转换为绝对地址<ul><li>程序在执行过程中可以移动</li><li>程序不必在内存中连续存储</li><li>程序运行前可以只装入部分代码，然后在运行期间再动态申请内存</li><li>若干个用户可以共享同一程序段或数据段</li></ul></li><li>编译重定位：编译器在内存中分配函数，变量等的虚地址，当程序访问到这些地址时，使用的是预分配的虚地址，根据相对程序头部将PC指针偏移找到目标代码。</li></ul><p>内存保护</p><ul><li>重定位寄存器：包含最小的物理地址</li><li>界地址寄存器：最大的逻辑地址值，每个逻辑地址必须小于界地址寄存器</li></ul><h3 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h3><p>进程可以使用的最大地址空间受限于<strong>地址位数</strong></p><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><ul><li>时间局部性：如果程序中某一条指令一旦执行成功，不久之后该指令可能再次执行。原因是循环操作</li><li>空间局部性：一旦程序访问某一个存储单元，不久之后，其附近的存储单元也将被访问。原因是指令通常是顺序存放顺序执行。</li></ul><p>例子</p><ul><li>虚拟内存</li><li>Cache</li><li>页面置换算法（LRU，CLOCK）</li><li>预调页策略</li></ul><h4 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h4><p><strong>内存连续分配</strong></p><ol><li><p>固定分区：</p><p>将内存中用户区划分为若干个连续的分区，其尺寸固定不可变。可以使用&lt;分区号，起始地址，大小，状态&gt;表结构表示分区。出现内部碎片</p></li><li><p>动态分区：</p><p>每个分区大小可以变化。可以使用空闲分区表，空闲分区链表示分区。出现外部碎片，使用<strong>紧凑（紧缩）</strong>方法合并分区，即操作系统不时对进程进行移动和整理</p><p>动态分区的分配策略</p><ul><li>首次适应：空闲分区地址递增方式连接，找到第一个可用分区</li><li>临近适应：在首次适应的基础上循环适应</li><li>最佳适应：空闲分区按容量递增方式连接，找到第一个可用分区</li><li>最坏适应：空闲分区按容量递减方式连接，找到第一个可用分区（最大分区）</li></ul></li></ol><p>交换技术</p><p>把处于等待状态的程序从内存中移到外存，称为换出；把准备好竞争CPU运行的程序从外存移到内存，称为换入</p><h4 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h4><p><strong>内存离散分配，分页内存管理允许进程的物理地址空间可以是非连续的。作业地址空间一维（只需要指定地址，该地址会通过硬件分为页号和偏移）</strong></p><p>页表：每个进程对应一张页表，记录页面在内存中对应的物理块号。页表放在内存中实现页号到物理块号的地址映射。表结构：页号：&lt;物理块号&gt;</p><p>页表中并不包括页号这一项，因为每个页表中每个页号都对应一个物理块号，并且页号按照顺序排列，直接可以定位。</p><p>页内偏移量 = 一个页的大小</p><p>页表寄存器：存放页表起始地址和页表长度，类似重定位寄存器</p><p>快表：TLB，类似Cache</p><p>优点：</p><ul><li>存在页内碎片，但相对较小，内存利用率较高</li><li>实现了离散分配</li><li>便于存储访问控制，有利于代码共享</li><li>无外部碎片</li></ul><p>缺点：</p><ul><li>用户视角的内存和实际物理内存分离</li><li>需要专门的硬件支持</li><li>不支持动态链接</li><li>有内部碎片</li></ul><p>多级页表</p><p>|顶级页表|二级页表|页内偏移量|</p><p>相当于：二级页表是顶级页表的页内偏移量。顶级页表项和二级页表项占的位数相同</p><p>例如：</p><p>  一个页面大小为$2^{12}$，则页内偏移量占12位，页内偏移量代表一个页的大小。顶级页表长度为9位，则一共$2^9$个页表项，一个页表项的长度为8。二级页表项与顶级页表项占的位数相同，为9位，二级页表项即可表示顶级页表项的偏移量，并且是对页表项的偏移量，而非页面大小的偏移量。         </p><h4 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h4><p><strong>类似分页管理，只是每一段长度不一定相同。作业地址空间二维（需要指定段号和偏移）</strong></p><p>理解为：将一个程序分为很多段，每个段就是一个逻辑处理，这些段可以在内存中随意存放。</p><p>段之所以更好满足用于需要就是其将属于一个逻辑的代码放在一起。</p><p>段表：段号: &lt;段长，基址&gt;表结构</p><p>段表寄存器：&lt;段表起始地址，段表长度&gt;，类似重定位寄存器</p><p>优点：</p><ul><li>便于动态链接</li><li>便于共享分段</li><li>便于程序模块化处理，符合用户视角</li><li>无内部碎片(长度可变)</li></ul><p>缺点：</p><ul><li>需要硬件转换</li><li>为了满足分段动态增长，减少外部碎片，采用拼接技术</li><li>有外部碎片</li></ul><h4 id="段页管理"><a href="#段页管理" class="headerlink" title="段页管理"></a>段页管理</h4><p>一个进程对应若干段，一个段对应若干页</p><ul><li>作业的地址空间被分成若干个逻辑段，每个段都有自己的段号</li><li>将每一个段分成若干个大小固定的页</li></ul><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>分段，分页需要将整个进程放入内存中，虚拟内存技术允许执行进程不必完全在内存中</p><p>缺页中断：在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存</p><ul><li>与一般中断的区别：<ul><li>在指令执行期间响应，而非一条指令执行完之后</li><li>缺页中断处理完成后仍回到原指令重新执行，而一般中断则返回到下一条指令执行</li><li>一条指令在执行期间，可能产生多次缺页中断</li></ul></li></ul><p>页面置换算法</p><ul><li><p>最佳置换算法（OPT）</p><p>淘汰页面最长时间不再使用的页面，需要预测未来</p></li><li><p>先进先出置换算法（FIFO）</p><p>会产生Belady异常，即当所分配的物理块数增大而缺页故障不减反增的异常现象。</p></li><li><p>最近最少使用置换算法（LRU）</p><p>淘汰最近最长没有使用的页面</p></li><li><p>时钟置换法</p><ul><li><p>二次机会法（NRU，最近未使用算法）</p><p>给每一块设置一个访问位，并将所有的块链接成循环链表，0表示未访问可替换，1表示已访问</p></li><li><p>改进后的时钟置换算法</p><p>一个访问位A，一个修改位M</p><p>被替换的优先级</p><ul><li>A=0,M=0</li><li>A=0,M=1</li><li>A=1,M=0</li><li>A=1,M=1</li></ul><p>执行过程</p><ul><li>先找第一优先级的</li><li>再找第二优先级的，遍历过程中将所有的访问位置位0</li></ul></li></ul></li></ul><p>局部模型-工作集</p><p>工作集是一个经常使用的页的集合</p><p><strong>颠簸（抖动）：</strong>在页面置换时，刚刚换出的页面又换入主存，这种频繁的页面调度称为<strong>颠簸</strong></p><p>原因：操作系统监视CPU的使用率，当使用率较低时，会引入新进程，以增加多道程序的程度。当多道程序增加到一定程度会出现颠簸。</p><h2 id="三-设备管理"><a href="#三-设备管理" class="headerlink" title="三.设备管理"></a>三.设备管理</h2><p>I/O设备分类：</p><ul><li>设备使用特性<ul><li>存储设备</li><li>输入输出设别</li></ul></li><li>传输速率<ul><li>低速设备</li><li>高速设别</li><li>中速设备</li></ul></li><li>信息交换单位<ul><li>块设备</li><li>字符设别</li></ul></li><li>设备共享性<ul><li>独占设备</li><li>共享设备</li><li>虚拟设备</li></ul></li></ul><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><h4 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h4><ul><li>DMA数据传输的基本单位是数据块，把对一个数据块的读写变为对一组数据块的读写</li><li>实现CPU，通道，和I/O设备三者并行操作</li></ul><h3 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h3><ul><li>缓和CPU和I/O设备之间速度不匹配的矛盾</li><li>减少对CPU中断的频率，放宽对CPU中断的响应时间的限制</li><li>提高CPU和I/O设备之间的并行性</li></ul><p>方式：</p><p>C为处理时间，M为传输到用户的时间，T为传输到缓冲区的时间</p><ul><li>单缓冲：时间Max（C，T）+M</li><li>双缓冲：时间Max（C+M，T），拿数据和处理数据是一个过程</li><li>循环缓冲</li><li>缓冲池</li></ul><h3 id="假脱机技术（SPOOLing）"><a href="#假脱机技术（SPOOLing）" class="headerlink" title="假脱机技术（SPOOLing）"></a>假脱机技术（SPOOLing）</h3><p>脱机输入脱机输出：利用专门外围控制机，完成低速I/O设备和高速磁盘数据传输</p><p>特点：</p><ul><li>提高I/O的速度。利用输入输出井模拟脱机输入输出，缓和了CPU和I/O设备速度不匹配的矛盾</li><li>将独占设备改造为共享设备。并没有为进程分配设备，而是为进程分配一存储区和建立一张I/O请求表</li><li>实现虚拟设备功能。多个进程同时使用同一台独占设备</li><li>利用空间换时间</li></ul><p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_SPOOLing.PNG" alt=""></p><p>共享打印机</p><p>当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程</p><ul><li>由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据传入其中</li><li>输出进程再为用户进程申请一张空白的用户请求打印表，将用户要打印的内容填入其中，再将该表挂到请求打印队列上。</li></ul><h2 id="四-文件系统"><a href="#四-文件系统" class="headerlink" title="四.文件系统"></a>四.文件系统</h2><p>系统运行时，计算机以进程为基本单位进行资源的调度和分配，而在用户进行的输入，输出中，则以文件为基本单位</p><h3 id="文件的组织方式"><a href="#文件的组织方式" class="headerlink" title="文件的组织方式"></a>文件的组织方式</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>文件的逻辑结构就是从用户的观点出发看到的文件的组织方式。</p><ul><li><p>无结构文件</p><p>数据按照顺序组织成记录并积累保存，是有序相关信息项的集合，以字节为单位。通过穷举法搜索</p></li><li><p>有结构文件</p><ul><li>顺序文件（顺序搜索）<ul><li>串结构（时间顺序）</li><li>顺序结构（关键字顺序）</li></ul></li><li>索引文件：索引表</li><li>索引顺序文件：先索引再顺序</li><li>直接文件和哈希文件</li></ul></li></ul><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>文件的物理结构直接与外存的分配方式有关，采用不同的分配方式时，将形成不同的文件物理结构</p><table><thead><tr><th></th><th>访问第n个记录</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>顺序分配</td><td>访问磁盘一次（不存在一个记录存在两个磁盘块的情况）</td><td>存取速度快，根据相对地址快速定位</td><td>需要连续的存储空间，不利于扩充，且会有碎片</td></tr><tr><td>链接分配</td><td>访问磁盘n次</td><td>解决碎片问题，便于动态扩充</td><td>按文件的指针顺序访问，效率较低，指针存储浪费空间</td></tr><tr><td>索引分配</td><td>m级访问磁盘m+1次</td><td>可以随机访问，易于文件的扩充</td><td>索引表的查找策略对文件系统影响较大</td></tr></tbody></table><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件控制块：FCB，用于描述和控制文件的数据结构。文件与文件控制块一一对应。</p><p>目录表</p><p>存储空间管理</p><ul><li>空闲表法&lt;序号，第一个空闲盘块号，空闲盘块数&gt;</li><li>空闲链表法</li><li>位视图法</li><li>成组链接法</li></ul><h2 id="五-磁盘"><a href="#五-磁盘" class="headerlink" title="五.磁盘"></a>五.磁盘</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>磁道划分为扇区。</p><p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.PNG" alt=""></p><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>先寻道，再定位到对应扇区，最后传输数据</p><ul><li><p>寻道时间 = 启动振臂时间$S$+经过的磁道数$N$*经过一个磁道的时间$M$</p></li><li><p>延迟时间 ，定位到对应的扇区，与磁盘的旋转速度$r$有关</p></li><li><p>传输时间 = （经过的磁盘数=传输的字节数$b$ / 一个磁道的字节数$N$）*(转一圈需要的时间=1 / 磁盘每秒的转数)</p><p>rpm代表一分钟的转数vv</p></li></ul><p>磁盘调度算法</p><ul><li>先来先服务(FCFS）</li><li>最短寻道时间优先(SSTF)</li><li>扫描（SCAN）算法（电梯算法）（改进版），双向扫描</li><li>循环扫描（C-SCAN）（改进版）：单向扫描</li></ul><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>低级格式化：将一个磁盘分成扇区</p><p>为了使磁盘可以存储文件，需要两部</p><ul><li><p>磁盘分区</p></li><li><p>逻辑格式化（创建文件系统）</p><p>操作系统将初始的文件系统数据结构存储到磁盘上，包括空闲，已分配的空间和一个初始位空的目录。</p></li></ul><h3 id="RAID（磁盘冗余阵列）"><a href="#RAID（磁盘冗余阵列）" class="headerlink" title="RAID（磁盘冗余阵列）"></a>RAID（磁盘冗余阵列）</h3><p>RAID级别：</p><ul><li><p>RAID0：无冗余的磁盘阵列</p><p>将多个磁盘合并位一个大磁盘，不具备冗余能力，并行I/O。</p><p>一个磁盘块损坏，所有数据无法使用</p></li><li><p>RAID1：镜像文件</p><p>将磁盘阵列中硬盘分为两组，互为镜像，并行传输方式。</p><p>提高读写速度，增加系统可靠性</p></li><li><p>RAID2：内存方式的差错纠正结构</p><p>差错由内存系统检测</p></li><li><p>RAID3：位交织奇偶结构</p><p>一个硬盘存放数据的奇偶校验位，其余硬盘存放数据。</p><p>检验盘损坏，则全部数据无法使用</p></li><li><p>RAID4：块交织奇偶结构</p></li><li><p>RAID5：分布交织奇偶结构</p><p>将数据的奇偶校验位交互存放于各个硬盘上</p></li><li><p>RAID6：P+Q冗余方案</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列BlockingQueue</title>
      <link href="/2019/12/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/"/>
      <url>/2019/12/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列相对于非阻塞队列最大的区别在于</p><ul><li>当队列是空的时，从队列中获取元素的操作将会被阻塞，直到其他的线程往空的队列插入新的元素</li><li>当队列是满时，往队列里添加元素的操作会被阻塞，直到队列中移除一个或者多个元素，或者完全清空队列</li></ul><h2 id="BlockingQueue简介"><a href="#BlockingQueue简介" class="headerlink" title="BlockingQueue简介"></a>BlockingQueue简介</h2><p>BlockingQueue是一个阻塞队列，满足上面阻塞队列的性质，其插入，删除，读取操作方法如下：</p><table><thead><tr><th align="center"></th><th align="center">抛异常</th><th align="center">返回特殊值</th><th align="center">阻塞</th><th>超时</th></tr></thead><tbody><tr><td align="center"><strong>插入</strong></td><td align="center">add(o)</td><td align="center">offer(o)</td><td align="center">put(o)</td><td>offer(o, timeout, timeunit)</td></tr><tr><td align="center"><strong>移除</strong></td><td align="center">remove(o)</td><td align="center">poll(o)</td><td align="center">take(o)</td><td>poll(timeout, timeunit)</td></tr><tr><td align="center"><strong>检查</strong></td><td align="center">element(o)</td><td align="center">peek(o)</td><td align="center"></td><td></td></tr></tbody></table><ul><li>抛异常：操作无法立即执行，抛出异常</li><li>返回特殊值：操作无法立即执行，返回false或null</li><li>阻塞：操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li>超时：操作无法立即执行，该方法调用将在给定的时间内发生阻塞，直到能够执行，操作成功返回true；若在给定时间内无法完成操作，返回false</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 插入队列，通常会使用offer实现     *     * @param e 需要添加的元素     * @return 添加成功返回true     * @throws IllegalStateException 如果元素无法被插入到队列中     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入队列，插入成功返回true，失败返回false     *     * @param e 需要添加的元素     * @return 插入成功返回true，失败返回false     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入元素e至队尾, 如果队列已满, 则阻塞调用线程直到队列有空闲空间.     *     * @param e 需要添加的元素     * @throws InterruptedException 如果等待时被中断     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入元素e至队列, 如果队列已满, 则限时阻塞调用线程，直到队列有空闲空间或超时.     *     * @param e 需要添加的元素     * @param timeout 在放弃插入之前需要等待的时间     * @param unit a timeout的时间单位     * @return 插入成功返回true，失败返回false     * @throws InterruptedException 如果等待时被中断     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 从队首删除元素，如果队列为空, 则阻塞调用线程直到队列中有元素.     *     * @return 队列头部的元素     * @throws InterruptedException 如果等待时被中断     */</span>    E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 从队首删除元素，如果队列为空, 则限时阻塞调用线程，直到队列中有元素或超时.     *     * @param timeout 在放弃插入之前需要等待的时间     * @param unit a timeout的时间单位     * @return 返回头部的元素，或者时间超时返回null     * @throws InterruptedException 如果等待时被中断     */</span>    E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre><p>谨记：BlockingQueue无法插入null</p><h2 id="消费者生产者问题"><a href="#消费者生产者问题" class="headerlink" title="消费者生产者问题"></a>消费者生产者问题</h2><p>操作系统中，生产者消费者问题，一般定义两个同步信号量和一个互斥信号量</p><ul><li>mutex 互斥信号量，表示只有一个线程可以操作队列</li><li>empty 同步信号量，表示剩余空间的个数</li><li>full 同步信号量，表示已经装满的个数</li></ul><p>消费者生产者问题可以自己定义P操作，V操作，然后再利用这三个信号量完成。</p><p>下面是一个利用LinkedBlockingQueue，并且空间大小为5的阻塞队列实现的消费者生产者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 生产者线程 */</span><span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token function">Producer</span><span class="token punctuation">(</span>LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> linkedBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> linkedBlockingQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">Produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Apple apple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产:"</span><span class="token operator">+</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 消费者线程 */</span><span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token function">Consumer</span><span class="token punctuation">(</span>LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> linkedBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> linkedBlockingQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">comsume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">comsume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Apple apple <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费Apple="</span><span class="token operator">+</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue是一种<strong>有界阻塞队列</strong>，在初始构造的时候需要指定队列的容量。具有如下特点：</p><ol><li>队列的容量一旦在构造时指定，后续不能改变；</li><li>插入元素时，在队尾进行；删除元素时，在队首进行；</li><li>队列满时，调用特定方法插入元素会阻塞线程；队列空时，删除元素也会阻塞线程；</li><li>支持公平/非公平策略，默认为非公平策略。</li><li>ArraBlockingQueue是使用环形数组实现<ul><li>当元素个数等于队列长度时表示队列已满</li><li>当元素个数等于0表示队列为空</li></ul></li><li>所有线程共用一把锁</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>所有线程共同使用同一个重入锁</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 存储数据的数组 */</span><span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**获取数据的索引，头索引，主要用于take，poll，peek，remove方法 */</span><span class="token keyword">int</span> takeIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**添加数据的索引，尾索引，主要用于 put, offer, or add 方法*/</span><span class="token keyword">int</span> putIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 队列元素的个数 */</span><span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 控制并非访问的锁，相当于mutex */</span><span class="token keyword">final</span> ReentrantLock lock<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作，相当于full */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**notFull条件对象，用于通知put方法队列未满，可执行添加操作，相当于empty */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 迭代器 */</span><span class="token keyword">transient</span> Itrs itrs <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ArrayBlockingQueue有三个构造函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * 指定队列初始容量的构造器. */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span>int capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用ArrayBlockingQueue(int capacity, boolean fair) </span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定队列初始容量和公平/非公平策略的构造器. */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化队列</span>    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 利用独占锁的策略</span>    notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 根据已有集合构造队列 */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//先构造队列，再插入元素</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> fair<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保证items数组的可见性，即保证插入，删除，读取操作不会操作数据不完整的队列</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不能有null元素</span>                items<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArrayIndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count <span class="token operator">=</span> i<span class="token punctuation">;</span>        putIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> i<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 如果队列已满，则重置puIndex索引为0</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>核心构造方法 ArrayBlockingQueue(int capacity, boolean fair) 默认的是非公平锁</p><ul><li><p><strong>公平策略：</strong>按照“先来后到”的原则，对于每一个等待线程都是公平的。</p></li><li><p><strong>非公平策略：</strong>在多个线程争用锁的情况下，能够最终获得锁的线程是随机的（由底层OS调度）。</p></li></ul><p><em>注意：一般情况下，使用公平策略的程序在多线程访问时，总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时一定需要暂停线程并启动线程。</em></p><p>构造完之后，ArrayBlockingQueue的初始化结构如下</p><p><img src="ArrayBlockingQueue%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84.png" alt=""></p><p>插入元素之后，ArrayBlockingQueue的结构如下</p><p><img src="ArrayBlockingQueue%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E7%BB%93%E6%9E%84.png" alt=""></p><h3 id="尾部插入"><a href="#尾部插入" class="headerlink" title="尾部插入"></a>尾部插入</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ArrayBlockingQueue中的add方法调用其父类AbstractQueue中的add方法，如下</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//调用offer方法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入失败抛出异常</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//检测是否为空</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果队列已满，插入失败，返回false</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入到队列中，返回true</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//检测是否为空</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该方法可中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这里必须用while，防止虚假唤醒，若是虚假唤醒，则再检查一遍确认是否能插入</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//队列已满。</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在notfull队列上等待</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列已满，在notfull队列上等待nanos时间</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span>    <span class="token comment" spellcheck="true">// assert items[putIndex] == null;</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//环形数组，如果尾指针已经到数组尾部，则将尾指针移到数组头部，即重置索引为0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//已经有数据插入，可以唤醒删除线程</span><span class="token punctuation">}</span></code></pre><h3 id="头部删除"><a href="#头部删除" class="headerlink" title="头部删除"></a>头部删除</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果队列为空，返回null，否则删除头部元素</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中孤单</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果队列为空，加入到notEmpty队列中</span>        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列为空，加入到notEmpty队列等待nanos</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span>    <span class="token comment" spellcheck="true">// assert items[takeIndex] != null;</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    E x <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取出元素</span>    items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置取出后的位置为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果头指针已经到尾部，则将头针移到数组头部，即重置头部索引为1</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>        itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//队列中已经空余出位置，唤醒插入线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一种<strong>近似有界阻塞队列</strong>，因为LinkedBlockingQueue既可以在初始构造时就指定队列的容量，也可以不指定，如果不指定，那么它的容量大小默认为<code>Integer.MAX_VALUE</code>。</p><ol><li>插入元素时，在队尾进行；删除元素时，在队首进行；</li><li>队列满时，调用特定方法插入元素会阻塞线程；队列空时，删除元素也会阻塞线程；</li><li>底层数据结构为链表</li><li>维护两把锁<code>takeLock</code>和<code>putLock</code>，可以使删除和插入操作互不干扰<ul><li>takeLock用于控制出队的并发，只能有一个线程进行删除操作</li><li>putLock用于入队的并发，只能有一个线程进行插入操作</li></ul></li><li>所有的元素都被封装成Node类型的节点插入到队列中</li></ol><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 节点类，用于存储数据 */</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span> item <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 当前阻塞队列中的元素个数 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**阻塞队列的头结点,不存数据*/</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**阻塞队列的尾节点，存数据*/</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 获取并移除元素时使用的锁，如take, poll, etc */</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty <span class="token operator">=</span> takeLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 添加元素时使用的锁如 put, offer, etc */</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull <span class="token operator">=</span> putLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 默认构造器. * 队列容量为Integer.MAX_VALUE. */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用LinkedBlockingQueue(int capacity)</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 显示指定队列容量的构造器 */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化为头指针，尾指针为null的队列</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 从已有集合构造队列. * 队列容量为Integer.MAX_VALUE */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保证items数组的可见性，即保证插入，删除，读取操作不会操作数据不完整的队列</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 队列不能包含null元素</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> capacity<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 队列已满</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队尾插入元素</span>            <span class="token operator">++</span>n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 设置元素个数</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>构造完之后，LinkedBlockingQueue的初始化结构如下</p><p><img src="LinkedBlockingQueue%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84.png" alt=""></p><p>插入元素之后，LinkedBlockingQueue的结构如下</p><p><img src="LinkedBlockingQueue%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E7%BB%93%E6%9E%84.png" alt=""></p><h3 id="尾部插入-1"><a href="#尾部插入-1" class="headerlink" title="尾部插入"></a>尾部插入</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不能插入null元素</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//队列已满，返回false</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//加上插入锁</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//队列未满插入数据</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入前队列的长度</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果插入后队列不满，唤醒等待的插入线程</span>                notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> c <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不可插入null数据</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入之前的队列长度</span>    putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果已经满了，则加入notFull队列等待</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//被唤醒后，插入数据</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取后再增加</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果插入后队列未满，则可以唤醒下一个插入线程</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//插入之前的队列长度</span>    putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列已满，在notfull队列上等待nanos时间</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒，插入数据</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果插入后队列未满，则可以唤醒下一个插入线程</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert putLock.isHeldByCurrentThread();</span>    <span class="token comment" spellcheck="true">// assert last.next == null;</span>    last <span class="token operator">=</span> last<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在尾节点插入数据</span><span class="token punctuation">}</span></code></pre><h3 id="头部删除-1"><a href="#头部删除-1" class="headerlink" title="头部删除"></a>头部删除</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果队列为空，返回null</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    E x <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果队列不为空，删除头部元素</span>            x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//删除之前，队列长度大于1，则可以唤醒下一个删除线程</span>                notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    E x<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//可中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//队列长度为0，加入到notEmpty等待队列中</span>            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒后，删除元素</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果删除之前长度大于1，则可以唤醒下一个删除进程</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    E x <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//队列长度为0，加入到notEmpty等待队列等待nanos时间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒后，删除元素</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果删除之前长度大于1，则可以唤醒下一个删除进程</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// assert takeLock.isHeldByCurrentThread();</span>     <span class="token comment" spellcheck="true">// assert head.item == null;</span>     Node<span class="token operator">&lt;</span>E<span class="token operator">></span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head头部没有数据</span>     Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>     h<span class="token punctuation">.</span>next <span class="token operator">=</span> h<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC    ，自己指向自己</span>     head <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head指针后移</span>     E x <span class="token operator">=</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>     first<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h2 id="ArrayBlockingQueue与LinkedBlockingQueue对比"><a href="#ArrayBlockingQueue与LinkedBlockingQueue对比" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue对比"></a>ArrayBlockingQueue与LinkedBlockingQueue对比</h2><table><thead><tr><th></th><th>ArrayBlockingQueue</th><th>LinkedBlockingQueue</th></tr></thead><tbody><tr><td>底部数据结构</td><td>环形数组，存储元素</td><td>链表，封装成Node插入</td></tr><tr><td>锁</td><td>只有一个lock，插入删除只能一个进行</td><td>takeLock和putLock两个锁，插入删除可同时进行，效率会更高一些</td></tr><tr><td>队列大小</td><td>必须指定大小</td><td>可不指定大小默认为Integer.MAX_VALUE，可指定大小</td></tr><tr><td>插入唤醒</td><td>插入数据后直接唤醒删除线程</td><td>插入数据后如果还有空间唤醒后续插入线程；插入之前为空队列再唤醒删除线程</td></tr><tr><td>删除唤醒</td><td>删除数据后直接唤醒插入线程</td><td>删除数据后如果还有数据唤醒后续删除线程；删除之前为满队列再唤醒插入线程</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/77410889</a></p><p><a href="https://segmentfault.com/a/1190000016296278" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016296278</a></p><p><a href="https://blog.yeskery.com/articles/338891277" target="_blank" rel="noopener">https://blog.yeskery.com/articles/338891277</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2019/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2019/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一-计算机系统概述"><a href="#一-计算机系统概述" class="headerlink" title="一. 计算机系统概述"></a>一. 计算机系统概述</h2><h3 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h3><p>硬件性能参数</p><ul><li>计算机字长：CPU字长，指CPU一次能处理数据的二进制位数</li><li>机器主频：时钟脉冲的频率</li><li>主存容量：计算机能够存放的最大的二进制位数bit，B，KB，MB</li></ul><p>计算机性能指标</p><ul><li><p>响应时间：计算机完成某任务从任务输入到结果输出的全部时间</p></li><li><p>吞吐量：单位时间内计算机完成的工作量</p><p>CPI：执行一条指令平均使用的CPU时钟个数</p><p>MIPS：每秒完成百万条（10的六次方）指令数</p></li></ul><h2 id="二-数据的表示和运算"><a href="#二-数据的表示和运算" class="headerlink" title="二. 数据的表示和运算"></a>二. 数据的表示和运算</h2><h3 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h3><p>$X =x_0x_1x_2…x_n$ </p><p>定点小数：$x_0$为符号位，$x_1x_2…x_n$为尾数（小数部分的内容）$[-(1-2^n),1-2^{n}]$</p><p>定点整数：$x_0$为符号位，$x_1x_2…x_n$为尾数（整数部分的内容）$[-(2^n-1),2^n-1]$</p><table><thead><tr><th>真值</th><th>$-2^n$</th><th>$-(2^n-1)$</th><th>-1</th><th>0</th><th>+1</th><th>$2^n-1$</th></tr></thead><tbody><tr><td>原码</td><td>无</td><td>11…11</td><td>10…01</td><td>10…00/00…00</td><td>00…01</td><td>01…11</td></tr><tr><td>反码</td><td>无</td><td>10…00</td><td>11…10</td><td>11…11/00…00</td><td>00…01</td><td>01…11</td></tr><tr><td>补码</td><td>10…00</td><td>10…01</td><td>11…11</td><td>00…00</td><td>00…01</td><td>01…11</td></tr></tbody></table><h3 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h3><p>步骤</p><ul><li>对阶</li><li>尾数加减运算</li><li>尾数结果规格化</li><li>舍入</li><li>溢出判断</li></ul><p>算术逻辑单元ALU</p><ul><li><p>一位全加器</p><p>加数A，加数B，进位C</p></li><li><p>并行加法器</p><p>由多个一位全加器组成</p><ul><li><p>串行进位</p><p>高位依赖低位的进位信息</p></li><li><p>并行进位</p><p>高位低位同时进行运算</p></li></ul></li></ul><h2 id="三-存储器层次结构"><a href="#三-存储器层次结构" class="headerlink" title="三. 存储器层次结构"></a>三. 存储器层次结构</h2><h3 id="半导体存储器RAM"><a href="#半导体存储器RAM" class="headerlink" title="半导体存储器RAM"></a>半导体存储器RAM</h3><p>RAM（随机存取存储器）随机存取存储器，每次访问时间是固定的，与其所在的物理位置无关。</p><p>RAM可以分为静态RAM与动态RAM。</p><ul><li>SRAM：利用触发器电路状态存储信息</li><li>DRAM：利用MOS电容是否带电荷存储信息</li></ul><p>RAM与ROM</p><ul><li>ROM只能读不能写，常用于存放系统程序或不需要修改的数据，非易失</li><li>RAM既可以读也可以写，常用来存放用户程序，数据或作为系统程序的工作区，易失</li></ul><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>多用于cache</p><p>由存储阵列，地址译码器，I/O电路，片选线，读写控制电路组成</p><ul><li><p>存储阵列：是主存储器的核心，程序与数据存放在存储阵列中</p></li><li><p>地址译码器：包含译码器与驱动器，可分为一维译码器（字选择线），二维译码器（字选择线+位选择线）</p><ul><li><p>二维译码器</p><p>将一维线性排列的存储单元进行重新排列，变成二维排列。行选择线选择某一行，位选择线选择该行第几个存储器。</p></li></ul></li><li><p>片选器：实现选择某一个芯片</p></li><li><p>I/O电路与读写控制电路：完成选中存储单元中各位的读出与写入操作</p></li></ul><p>参数：</p><ul><li>数据引脚数量=存储字长=存储单元所包含存储元个数</li><li>存储阵列容量=存储数量（存储单元的个数，与地址线数量有关）*存储字长</li><li>地址引脚数量：与存储单元的个数有关</li></ul><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>多用于主存</p><ul><li><p>刷新：对DRAM定期进行全部重写过程。刷新操作主要解决存储单元中电容缓慢泄露电荷导致的信息丢失问题。</p></li><li><p>DRAM刷新地址计数器：指刷新存储器的行地址。其位数就是行地址的位数</p></li><li><p>刷新的方式</p><ul><li><p>集中式刷新</p><p>是指将各行的行刷新集中一段时间统一进行</p></li><li><p>分散式刷新</p><p>将存储周期扩大一倍，前半段用于正常的读写，后半段用于行刷新。不存在“死区”</p></li><li><p>异步式刷新</p><p>将各行的行刷新均匀分散在整个刷新周期中进行，对集中式刷新和分散式刷新的折中</p></li></ul></li></ul><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>数据存放的方式：</p><ul><li>小端照齐：数据的最低位存放在地址低位</li><li>大端照齐：数据的最高位存放在地址低位</li></ul><h4 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h4><ul><li>位扩展：横向扩展</li><li>字扩展：纵向扩展</li><li>字与位同时扩展：纵向横向同时扩展</li></ul><h4 id="片选"><a href="#片选" class="headerlink" title="片选"></a>片选</h4><p>CPU对存储单元的访问：</p><ol><li>选择存储芯片，即进行片选</li><li>从选中的芯片中依地址码选择对应的存储单元，即进行字选</li></ol><p>片选的方法：</p><ul><li>线选法：有多少个芯片就有多少个选择线，一个选择线对应一个芯片</li><li>全译码法：对芯片进行编码，n个芯片，需要$log_2n$个选择线</li><li>部分译码：相比全译码方法，会多出几位无用</li></ul><h3 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>读</p><ul><li>Cache和主存均被分为若干个大小相等的块，每个块由若干字节组成</li><li>CPU发出主存地址后<ul><li>首先判断该存储字是否在Cache中，若命中，直接访问Cache</li><li>若不命中，则访问主存并将该字所在的主存块装入Cache</li></ul></li></ul><p>写，可能出现数据不一致问题</p><ul><li>如果命中Cache<ul><li>写直达法：将信息同时写入Cache和主存中</li><li>写回法：将信息写入Cache，在Cache被替换时再写入主存</li><li>写一次法：与写回法一样，但再第一次写入时也将信息写入到主存</li></ul></li><li>如果不命中Cache<ul><li>不按写分配法：只将需要写的信息写入主存</li><li>按写分配法：将需要写的信息写入主存后，再将该块从主存中读入Cache</li></ul></li></ul><h4 id="Cache与主存之间的映射关系"><a href="#Cache与主存之间的映射关系" class="headerlink" title="Cache与主存之间的映射关系"></a>Cache与主存之间的映射关系</h4><p>主存的块标记有m位，即主存有$2^m$个块，块大小$2^b$个字，Cache一个$2^c$个块，块大小$2^b$个字</p><ol><li><p>全相联映射</p><p>主存中某个块可以被放到Cache中任意一个位置</p><p>主存：| 块号m位 | 块内地址b位 |</p><p>Cache：| 块号c位 | 块内地址b位 |</p><p>目录表： 块标记位数m位</p></li><li><p>直接映射</p><p>将主存划分为若干个区，每个区的块数与Cache的块数相同，区内第$j$个块只能放在Cache第$j$个块</p><p>主存快标记m=k+c，$2^c$为Cache的块数，k为区标记，一共$2^k$个区</p><p>主存：| 区号k位 | 区内块号c位 | 块内地址b位 |</p><p>Cache：| 块号c位 | 块内地址b位 |</p><p>目录表：块标记位数k位</p></li><li><p>组相联映射</p><p>Cache分成若干个组，每个组包含多个块，将主存划分为若干个区，每个区的主存块数与Cache的组数相同，区内第j块可以放置在Cache的第j组的任意位置</p><p>Cache中c=(c-g)+g，一个$2^{c-g}$个组，一个组内有$2^g$个块</p><p>主存快标记m=(m-c+g) + (c-g) ，一共$2^{m-c+g}$个区，一个区内有$2^{c-g}$个块数</p><p>n路组相联表示一组中有n个数据块</p><p>主存：| 区号k位 | 区内块号g位 | 块内地址b位 |</p><p>Cache：| 组号g位 | 块号c位 | 块内地址b位 |</p><p>目录表：块标记位数k位</p></li></ol><h2 id="四-MIPS-指令系统"><a href="#四-MIPS-指令系统" class="headerlink" title="四. MIPS 指令系统"></a>四. MIPS 指令系统</h2><p>MIPS按字节寻址，一条指令长度为32位，一个字长，所以执行一条指令，PC＋４</p><p>程序控制局部性原理：<strong>时间局部性</strong>和<strong>空间局部性</strong></p><h3 id="MIPS指令格式"><a href="#MIPS指令格式" class="headerlink" title="MIPS指令格式"></a>MIPS指令格式</h3><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_MIPS%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.PNG" alt=""></p><h3 id="MIPS寻址方式"><a href="#MIPS寻址方式" class="headerlink" title="MIPS寻址方式"></a>MIPS寻址方式</h3><p>寄存器取数使用()，例如(R)</p><p>主存按地址取数使用[]，例如[(R)]</p><h4 id="MISP"><a href="#MISP" class="headerlink" title="MISP"></a>MISP</h4><ul><li><p>寄存器寻址：操作数在寄存器组中，指令中有寄存器编号</p></li><li><p>立即数寻址：操作数在指令中</p></li><li><p>基址寻址：操作数地址=基址+偏移地址，基址寄存器编号和偏移地址均在指令中</p></li><li><p>PC相对寻址：操作数地址=PC+偏移地址，偏移地址在指令中</p></li><li><p>伪直接寻址：操作数在主存中，操作数地址在指令中</p><p>单地址指令：操作码+A</p><p>双地址指令：操作码+A+A</p><p>操作码采用定长编码：所有指令格式的操作码长度相同</p><p>操作码采用变长编码：指令格式操作码长度不一样</p></li></ul><p>有效地址为EA，获取操作数需要访问内存的次数</p><table><thead><tr><th>寻址方式</th><th>有效地址</th><th>访存次数</th></tr></thead><tbody><tr><td>立即数寻址</td><td>A即为操作数</td><td>0</td></tr><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>寄存器寻址</td><td>EA=$R_i$</td><td>0</td></tr><tr><td>基址寻址</td><td>EA=(BR)+A</td><td>1</td></tr><tr><td>PC相对寻址</td><td>EA=(PC)+A</td><td>1</td></tr></tbody></table><h4 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h4><ul><li>立即寻址：√</li><li>寄存器寻址：√</li><li>直接寻址：√</li><li>间接寻址：两次寻址</li><li>寄存器间接寻址：两次寻址</li><li>基址寻址：基址固定不变</li><li>变址寻址 = MISP的基址寻址（基址寄存器）</li><li>相对寻址：√</li></ul><h2 id="五-MIPS处理器"><a href="#五-MIPS处理器" class="headerlink" title="五.MIPS处理器"></a>五.MIPS处理器</h2><h3 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h3><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_CPU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.PNG" alt="CPU内部结构"></p><p>CPU的基本功能就是对指令流和数据流在时间和空间上实施正确的控制</p><ul><li>指令流：CPU执行的指令序列</li><li>数据流：根据指令操作要求依次存取数据的序列</li></ul><p>指令的四种基本操作：</p><ul><li>取数：读取某个主存单元的数据，并传输到某个寄存器中</li><li>存数：将某个寄存器的数据存入到主存某个单元之中</li><li>传送：将某个寄存器的数据传输到ALU或者另一个寄存器中</li><li>运算：进行某种逻辑运算，并将结果保存到某一个寄存器中</li></ul><p>CPU组成：</p><ul><li>程序计数器PC</li><li>指令寄存器IR：存放从存储器中取出的指令</li><li>存储器数据寄存器MDR：暂存由主存读出的一条指令或一个数据字</li><li>存储器地址寄存器MAR：保存当前CPU所访问的主存单元地址</li></ul><p>CPU执行流程：</p><pre><code>以ADD R1,(R2)为例：R1 &lt;- (R1)+((R2))最后再将R1中数据放回内存取指：    T1:PC -&gt; MAR            //读取地址    T2:1 -&gt; READ            //发出读命令       M(MAR) -&gt; MDR        //读取数据    T3:MDR -&gt; IR            //读出的数据放在    T4:PC+1 -&gt; PC             //PC+1取数：    T1:R2 -&gt; MAR    T2:1 -&gt; READ       M(MAR) -&gt; MDR    T3:MDR -&gt; B    T4:R1 -&gt; A运算：    A+B -&gt; AC    AC -&gt; R1写回：    T1: R1 -&gt; MDR    T2: PC -&gt; MAR    T3: 1 -&gt; WRITE        MDR-&gt;M(MAR)    T4: PC+1 -&gt; PC</code></pre><h3 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h3><p>所有指令执行周期为固定为单一时钟周期，即CPI=1.采用<strong>哈弗体系结构</strong>（指令和数据采用不同存储器）。</p><h4 id="单周期数据通路设计"><a href="#单周期数据通路设计" class="headerlink" title="单周期数据通路设计"></a>单周期数据通路设计</h4><ol><li><p>取指和PC自增数据通路</p><p>功能描述：</p><ul><li>取指：IM Address ⬅PC，instruction=IM[PC]</li><li>PC自增：PC⬅PC+4</li></ul><p>所需部件：PC，Adder，指令寄存器IM</p></li><li><p>R型指令数据通路</p><p>add rd，rs，rt</p><ul><li>rd第三个寄存器</li><li>rs第一个寄存器</li><li>rt第二个寄存器</li></ul><p>功能描述：R[rd]⬅R[rs]+R[rt]</p><p>所需部件：寄存器堆，ALU</p></li><li><p>加载数据指令</p><p>lw rt，rs，imm16</p><p>功能描述：R[rt] = DM[ R[rs]+Signext(imm16) ]</p><p>通路部件：寄存器堆，ALU，符号扩展单元Signext，数据存储器DM</p></li><li><p>存数指令</p><p>sw rt，rs，imm16</p><p>功能描述：DM[R[rs]+Signext(imm16)] ⬅R[rt]</p><p>通路部件：寄存器堆，ALU，符号扩展单元Signext，数据存储器DM</p></li><li><p>分支指令数据通路</p><p>beq rs，rt，imm16</p><p>功能描述：If ( R[rs] – R[rt] =0) then PC  ⬅ (PC + 4) + Signext(imm16)&lt;&lt;2</p><pre><code>                                                 else PC  ⬅  PC + 4</code></pre><p>通路部件：寄存器堆，ALU，增加一个加法器，符号扩展器，移位器</p></li></ol><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.PNG" alt=""></p><h4 id="指令执行时间计算"><a href="#指令执行时间计算" class="headerlink" title="指令执行时间计算"></a>指令执行时间计算</h4><ul><li>采用单周期，即所有指令周期固定为单一时钟周期，<ul><li>时钟周期由最长的指令决定(LW指令)，为600ps</li></ul></li><li>不同类型采用不同的指令周期（可变时钟周期）</li></ul><p>改进方法：改变m每种指令类型所用的时钟数，采用多周期实现</p><h3 id="多周期处理器"><a href="#多周期处理器" class="headerlink" title="多周期处理器"></a>多周期处理器</h3><p>为什么不使用单周期实现方式</p><pre><code>单周期设计中，时钟周期对所有指令等长，而时钟周期由计算机中可能的最长执行时间的指令决定，一般为取数指令。因此一些较短执行时间的指令会浪费一段时间</code></pre><p>多周期方案（采用普林斯顿结构，指令和数据采用一个存储器）</p><ul><li>将指令分为多个步骤执行，每一个步骤一个时钟周期，则指令执行周期为多个周期，不同指令的指令周期包含时钟周期不一样。</li><li>优点：<ul><li>提高性能</li><li>降低成本：一个功能单元可以在一条指令执行过程中使用多次，只要是在不同的周期内（有点像流水线）</li></ul></li></ul><h4 id="MIPS多周期数据通路设计"><a href="#MIPS多周期数据通路设计" class="headerlink" title="MIPS多周期数据通路设计"></a>MIPS多周期数据通路设计</h4><p>一个ALU，指令算术逻辑运算，取指后PC+4，beq转移指令，都在ALU中完成，扩展数据为补码形式。</p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%A4%9A%E5%91%A8%E6%9C%9F%E6%8C%87%E4%BB%A4.PNG" alt=""></p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%A4%9A%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.PNG" alt=""></p><h3 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h3><ul><li>流水线不改善单个任务处理延迟，但改善了整个工作负载得吞吐率</li><li>流水线速率受限于最慢的流水段</li><li>多个任务同时工作，但占用不同的资源</li><li>潜在加速比=流水线级数</li></ul><h4 id="流水线的五个阶段"><a href="#流水线的五个阶段" class="headerlink" title="流水线的五个阶段"></a>流水线的五个阶段</h4><ol><li>IF：取指令，PC值变化，利用PC中地址从内存中读取指令，放入ID/IF中</li><li>ID：指令译码，读寄存器，从寄存器堆中读取数据放入到ID/EXE中</li><li>EX：执行运算，ALU操作，将结果放在EX/MEM中<ul><li>Load/Store：计算地址</li></ul></li><li>EME：访存。为每一条指令分配该阶段是为了保证同一时刻不会有两条指令都访问数据缓存<ul><li>Load：从Memory读取数据</li><li>Store：将数据写入Memory</li></ul></li><li>WB：数据写回寄存器，将计算结果从ALU输出寄存器写回RF中</li></ol><p>不同阶段之间增加寄存器，保存前一个周期产生的信息。</p><ul><li>命名法则：前级/后继</li><li>功能：时钟上升沿到来，保存前级结果，之后输出至下级组合逻辑</li></ul><p>RF：Register File寄存器堆有两次使用：第二级读，第五级写。并且其第二个寄存器的值可以直接传递到EX/MEM</p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG" alt=""></p><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><p>流水线处理中，由于各个阶段的依赖关系，硬件资源的竞争等原因，会出现操作无法执行的情况。</p><p>在下一个时钟周期妨碍下一条指令执行的执行的情况称为<strong>数据冒险</strong></p><h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p> 结构冒险是指由于硬件资源的竞争，操作无法同时执行的情况，即资源使用冲突</p><ol><li><p>内存访问造成构造冒险</p><p>IF阶段和MEM阶段都涉及内存访问，访问内存使用的总线是共享资源，无法同时进行。（若依曼架构）</p><p>第一条指令为load或者save指令的第四个周期，会与第四条指令的第一个周期发生冲突。</p><p>解决方法：使用哈弗架构</p><pre><code>将指令用的内存和数据用的内存分别设置，即可解决构造冒险。CPU直接访问的缓存基本上都分为指令用和数据用两种，称为指令缓存和数据缓存</code></pre></li><li><p>寄存器访问造成构造冒险</p><p>WB阶段写回寄存器和ID阶段读取寄存器，寄存器无法读写同时进行</p><p>第一条指令为load或者R型指令第五个周期，会与第四条指令第二个周期发生冲突。</p><p>解决办法：分割寄存器堆的访问周期</p><pre><code>时钟周期前半段写，后半段读</code></pre></li></ol><h4 id="数据冒险-1"><a href="#数据冒险-1" class="headerlink" title="数据冒险"></a>数据冒险</h4><p>数据冒险指，由于指令所需要的数据还未准备好所引起的冒险情况。当即将执行的指令依赖于还未完成的数据时，会导致指令无法立刻开始执行，引起数据冒险。</p><ol><li><p>第一条指令在第五个周期将数据写回寄存器，若第二条指令第二个周期要用到第一条指令的数据，则会出现数据冒险</p><p>写回的数据，后续指令需要用到。第一条指令为R型指令，在第五个周期将数据写回寄存器，而第二条指令在第二个周期取指时需要用到该寄存器的值，发生数据冒险。</p></li></ol><p>解决方法：使用<strong>直通的方法</strong>，或者两个nop</p><pre><code>R型指令原本回写运算结果是在WB阶段，而实际上决定运算结果的是在EX阶段。直通方法就是指，在运算结果确定的EX阶段，将数据直接传递给下一个指令的ALU阶段EX/MEM.RegisterRd = ID/EX.RegisterRs = r1在EX/MEM与ID/EX中间加一个转发单元</code></pre><ol start="2"><li><p>数据冒险与阻塞</p><p>当一条指令读取一个寄存器而其前一条指令是load指令（需要将内存中的数据写回寄存器），并且该load指令写入的是同一个寄存器，则直通方法无法解决。原因：load指令写回的数据在MEM阶段完成后产生</p><p>解决方法：阻塞流水线</p><pre><code>当load指令后紧跟着一个需要其结果的指令时，必须采用相应的机制阻塞流水线。除了转发单元，还要将第二条指令阻塞一个周期，使用nop指令（没有任何效果），如果没有转发单元，需要两个nop指令</code></pre></li></ol><p>还可以调整指令的执行顺序。</p><h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p>控制冒险指，无法确定下一条指令而引发的冒险情况。</p><p>在执行可能会改变下一条指令的分支指令时，在这一条指令执行结果确定前（MEM之后）下一条指令无法进行</p><p>解决方法：</p><ul><li><p>假定分支不发生</p><p>即不管分支结果是否产生，继续向下执行，如果分支产生，则丢弃已经预取并译码的指令</p></li><li><p>缩短分支延迟</p><p>一般到MEM阶段才能确定分支结构要执行的下一条指令的PC。</p><p>题前计算分支的目的地址可以将分支加法器从EX段移动到ID段，将PC值和IF/ID流水线寄存器中的指令立即数相加，计算分支结果。</p><p>当分支指令的判断条件的数据寄存器依赖前一条指令的结果时</p><ul><li>如果依赖前一条指令的ALU计算结果时，通过转发单元完成</li><li>如果依赖前一条指令的回写阶段，通过nop指令实现</li></ul></li></ul><h2 id="六-总线与输入输出系统"><a href="#六-总线与输入输出系统" class="headerlink" title="六. 总线与输入输出系统"></a>六. 总线与输入输出系统</h2><h3 id="总线的仲裁方式"><a href="#总线的仲裁方式" class="headerlink" title="总线的仲裁方式"></a>总线的仲裁方式</h3><p>仲裁的方式有集中式和分布式两种。</p><h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><p>总线上主设备最少有两根信号线连接到总线仲裁机构，一根是总线请求信号线BR，一根是总线允许信号线BG</p><ol><li><p>链式查询方式</p><p>总线仲裁机构在有总线请求时，发出总线允许信号BG，由各主设备自行仲裁。需要三根信号线</p><p>特点：</p><ul><li>仲裁采用优先级策略，且各主设备的优先级固定，即离CPU越近主设备优先级越高</li><li>需要的仲裁信号线较少</li><li>可扩展性比较高，但对电路故障敏感，容易产生断链现象</li><li>三条线：BS（总线忙），BR（总线请求），BG（总线允许）</li></ul></li><li><p>计数器定时查询方式</p><p>使用设备地址信号线代替BG，内部使用计数器的计数信号表示设备。可以实现循环优先级和固定优先级两种方式。</p><p>特点：</p><p>　* 对电路不敏感，但信号线数量增多<br>　* 需要2+$log_2 n$条信号线，总线允许线改为设备地址线</p></li><li><p>独立请求方式</p><p>每个设备需要一对总线请求和总线允许信号线</p><p>特点</p><ul><li>速度快</li><li>优先次序控制灵活</li><li>线路多，电路复杂</li><li>n条BR，n条BG</li></ul></li></ol><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>不需要中央总裁器，每个设备都有自己的仲裁号和仲裁器，当某主设别由总线请求时，由自身决定仲裁结果。</p><h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h3><h4 id="I-O接口的功能"><a href="#I-O接口的功能" class="headerlink" title="I/O接口的功能"></a>I/O接口的功能</h4><ul><li><p>实现对主机和外设的通信联络控制</p></li><li><p>进行地址译码和设备选择</p><p>接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息</p></li><li><p>实现数据缓冲</p></li><li><p>数据格式的变换</p><p>并-串转换，串-并转换，模-数转换，数-模转换</p></li><li><p>传输控制命令和状态信息</p></li></ul><h4 id="I-O接口的结构"><a href="#I-O接口的结构" class="headerlink" title="I/O接口的结构"></a>I/O接口的结构</h4><p>接口要分别传送数据信息，控制信息，状态信息，这些数据都是由数据总线来传输</p><p>接口类型</p><ul><li>数据传输方式分类：串行接口，并行接口</li><li>主机访问I/O设备的控制方式分类：程序查询式接口，程序中断接口，DMA接口，通道</li><li>功能选择分灵活性分：可编程接口，不可编程接口</li><li>通用性分类：通用接口，专用接口</li><li>输入输出的信号分类：数字接口，模拟接口</li></ul><p>I/O端口：接口电路中可以被CPU直接访问的寄存器，若干个端口+相应的控制逻辑电路=接口</p><ul><li>数据端口：存放数据信息</li><li>命令端口：存放控制命令，CPU只可写</li><li>状态端口：存放状态信息，CPU只可读</li></ul><p>I/O端口编址方式：</p><ul><li>独立编址方式</li><li>统一编址方式</li></ul><h3 id="基本I-O方式"><a href="#基本I-O方式" class="headerlink" title="基本I/O方式"></a>基本I/O方式</h3><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>为了保证数据传输的正确进行，要求CPU在程序中查询外设的工作状态。如果外设没有准备好，CPU就循环等待，如果已经准备好，CPU才能执行I/O指令进行数据传送</p><p>流程：</p><ol><li>预置传送参数</li><li>向外设接口发出命令字</li><li>从外设接口取回状态字</li><li>查询外设标志</li><li>传送数据</li><li>修改传送参数：每进行一次数据传送之后必须修改传送参数：主存缓冲区地址+1，传送个数计数器-1</li><li>判断传送是否结束</li></ol><p>接口：</p><ul><li>数据缓冲寄存器：数据端口，用来存放CPU进行传送的数据信息</li><li>设备状态寄存器：供CPU查询的设备状态寄存器，即状态端口</li></ul><p>缺点：</p><ul><li>CPU等待外部设备</li><li>CPU只能和一台外设交换信息</li><li>不能发现和处理预先无法估计的错误和异常</li></ul><h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>计算机执行程序的过程中，出现某些急需处理的异常情况和特殊请求，CPU暂时中止现行程序，转去对出现的异常情况和特殊请求处理，在处理完毕之后，CPU将自动返回原来的程序继续执行</p><p>中断条件：</p><ul><li>CPU接收到中断请求信号</li><li>CPU允许中断，CPU内部有一个中断允许触发器（EINT）</li><li>一条指令执行完毕（缺页中断除外）</li></ul><p>中断隐指令：CPU响应中断之后，经过某些操作，需执行中断程序，这些操作由硬件实现，称为中断隐指令，包括保存断点，暂不允许中断，引出中断服务程序</p><p>中断过程：</p><ul><li>中断请求</li><li>中断判优（判断中断的优先级）</li><li>中断响应</li><li>中断处理<ul><li>准备部分：关中断，保护现场，判断中断源，开中断指令（允许更高级中断）</li><li>处理部分：执行中断服务程序</li><li>结尾部分：关中断，恢复现场，开中断指令</li></ul></li><li>中断返回</li></ul><p>中断屏蔽：有些中断发生后，可以选择性封锁部分中断，即中断屏蔽。中断屏蔽触发器（MASK），可以改变中断优先级（将原来较低的中断源编程较高的级别，称为中断升级）</p><p>中断分类：</p><p>分类一</p><ul><li>强迫性中断</li><li>自愿性中断</li></ul><p>分类二</p><ul><li>外中断</li><li>内中断</li></ul><p>分类三</p><ul><li>硬中断</li><li>软中断</li></ul><p>分类四</p><ul><li><p>向量中断：用硬件方法识别中断源和获得中断服务程序入口地址</p><p>中断向量：中断服务程序的入口地址</p></li><li><p>非向量中断：用软件查询的方式识别中断源和获得中断程序程序入口地址</p></li></ul><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>周期挪用（周期窃取）：每传输一个字需要占用一个存储周期的时间</p><p>直接存储器访问（DMA）在<strong>外设</strong>和<strong>主存</strong>之间开辟一条”直接数据通道”，在不需要CPU干预不需要软件介入的情况下在两者之间进行高速数据传送。</p><p>通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出<strong>系统总线</strong>，由DMA控制器接管总线进行数据传送</p><p>DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p><p>DMA与中断的区别：</p><ul><li>中断方式是程序切换，需要现场保护和现场恢复；DMA方式除了开始与结尾，不占用任何CPU资源</li><li>中断请求一般发生在每条指令执行完毕；DMA请求的响应时间可以发生在每个机器周期结束</li><li>中断传送需要CPU参与，DMA方式传输数据时无需CPU干预</li><li>DMA请求优先级高于中断请求</li><li>中断方式可以处理异常事件，DMA局限于传输数据块</li></ul><p>DMA控制器</p><ul><li>主存地址计数器：存放待交换数据的主存地址</li><li>传送长度计数器：记录长度计数器</li><li>数据缓冲寄存器：暂存每次传输的数据</li><li>DMA请求触发器：每当外设准备好数据后给出一个控制信号，使DMA请求触发器置位</li><li>控制/状态逻辑</li><li>中断机构：当一个数据块传输完毕之后触发中断机构，向CPU提出中断请求，CPU进行结尾处理</li></ul><p>传输过程</p><ul><li>DMA预处理：DMA传输之前进行初始化，由CPU完成</li><li>数据传送：以数据块为基本单位进行传输</li><li>DMA后处理：DMA向CPU发中断请求，CPU停止原来的程序执行，转去执行DMA结束处理工作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流计算</title>
      <link href="/2019/04/08/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/04/08/%E6%B5%81%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>原文出处：<a href="https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650719541&amp;idx=1&amp;sn=39fba251816ee625854c31ddc91f73af&amp;chksm=887dd843bf0a515544bed451d6f1b26af560f9c8991bb72d302c74c852fa848c95601d375482&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1586262346462&amp;sharer_shareid=9f8f1bd360ef58661a2034df035a1bb1#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650719541&amp;idx=1&amp;sn=39fba251816ee625854c31ddc91f73af&amp;chksm=887dd843bf0a515544bed451d6f1b26af560f9c8991bb72d302c74c852fa848c95601d375482&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1586262346462&amp;sharer_shareid=9f8f1bd360ef58661a2034df035a1bb1#rd</a></p><h3 id="01-“流”好在哪里？"><a href="#01-“流”好在哪里？" class="headerlink" title="01 “流”好在哪里？"></a>01 “流”好在哪里？</h3><p>“流”是一种非常好的编程模式。</p><p><img src="%E6%B5%81%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>▲图一：代表流计算模式的有向无环图DAG</p><p><strong>首先，“流”与“异步”不谋而合。</strong></p><p>“流”的各个节点通过队列传递消息，不同节点的执行正好就是完全异步的。并且由于有队列隔离，不同节点的执行完全不用考虑并发安全的问题。“流”在内部执行时是异步和并行的，能最大限度提高资源使用效率，提高程序执行性能。</p><p>可以说，“流”是“异步”的一种重要表现方式，“异步”则是“流”在执行时的内禀性质。</p><p><img src="%E6%B5%81%E4%B8%8E%E5%BC%82%E6%AD%A5.png" alt=""></p><p>▲图2：“流”和“异步”，傻傻分不清楚！</p><p><strong>其次，如果“流”的执行节点间使用的是阻塞队列</strong>，那么整个流的各个执行环节就天然地带有了反向压力能力，让我们不必担心很多异步系统在高负载而又临时处理能力不足时造成的OOM问题。</p><p><strong>再次，“流”能够非常自然地描述业务执行的流程。</strong>不管是大到整个产品线的各个服务模块，还是小到每个服务模块中的具体实现步骤。就像“分形”一样，“流”能够做任意细力度的划分。这是一种非常普遍的描述事情发生过程的模式。</p><p><strong>最后，通过类似于Kafka这样消息中间件的隔离，可以非常清晰地定义模块和模块之间的边界</strong>，从设计模式中高内聚、低耦合的角度来看，是一种非常不错的实践！</p><h3 id="02-流计算解决了什么问题？"><a href="#02-流计算解决了什么问题？" class="headerlink" title="02 流计算解决了什么问题？"></a>02 流计算解决了什么问题？</h3><p>总的来说，我们使用流计算主要是为了计算以下几类问题。</p><h4 id="1-流数据操作"><a href="#1-流数据操作" class="headerlink" title="1. 流数据操作"></a><strong>1. 流数据操作</strong></h4><p>流数据操作可以说是流计算系统与生俱来的能力，它本身是针对数据流的转化或转移处理，所以实现和使用起来都相对更加直观。</p><p>流数据操作的内容主要包括了三类：<strong>对数据进行清洗、规整和结构化</strong>，对不同来源的数据进行关联及合并，以及在不同系统之间搬运数据。这三类操作通过一些常用的流式API就可以实现。</p><h4 id="2-单点特征计算"><a href="#2-单点特征计算" class="headerlink" title="2. 单点特征计算"></a><strong>2. 单点特征计算</strong></h4><p>一个事件中包含的用户是否在黑名单中？发生事件的设备是否是模拟器？温度传感器传来的温度事件是否已经超出正常温度范围？发送消息设备的IP是否是代理？一次交易的金额是否属于大额交易？手机是否有SIM卡？</p><p>诸如此类的问题，要么可以通过黑白名单，要么能够通过特定的规则计算而得到答案，实现起来相对简单，所以<strong>我们将这类特征计算称之为单点特征。</strong></p><h4 id="3-时间维度聚合特征计算"><a href="#3-时间维度聚合特征计算" class="headerlink" title="3. 时间维度聚合特征计算"></a><strong>3. 时间维度聚合特征计算</strong></h4><p>相同设备的1小时内注册事件次数、相同银行卡号的7天交易事件次数、过去30天内同一IP段上交易金额、过去1分钟高温事件的次数、过去5分钟日志告警事件的次数……</p><p>诸如此类特征在诸如风控、预警、监控等各种场景都非常广泛的应用。分析不难发现，这类特征都有个共同特点，它们均需要在时间维度对数据进行聚合运算。因此，<strong>我们称这类特征为时间维度聚合特征。</strong></p><h4 id="4-关联图谱特征计算"><a href="#4-关联图谱特征计算" class="headerlink" title="4. 关联图谱特征计算"></a><strong>4. 关联图谱特征计算</strong></h4><p>除了时间维度的聚合分析外，我们还经常进行“空间”维度的聚合分析。不过<strong>这种分析有个更专业的名字，即“关联图谱”分析。</strong></p><p>比如在一些风控场景中，我们需要计算用户账户使用IP的个数、同一手机号码发生在不同城市的个数、同一设备上关联用户的数目、同一用户关联设备的数目、同一推荐人推荐的用户数等特征。</p><p>以设备关联用户数为例，如果某个设备上注册的用户很多，那么它的风险就比较高，毕竟正常情况下我们都只会用自己的手机注册自己的账号，而不会是帮其他几十、上百人注册账号的。</p><h4 id="5-事件序列分析"><a href="#5-事件序列分析" class="headerlink" title="5. 事件序列分析"></a><strong>5. 事件序列分析</strong></h4><p>数据流中的数据不是单纯在时间上有着先来后到的关系，而是在数据和数据之间也有着联系。</p><p>考虑用户在手机上安装新APP的过程，它可能是先点击了某个广告链接，然后下载并安装了APP，最后成功注册了账号。从“点击”到“下载”，再到“安装”和“注册”，这就完成了一次将广告转化为用户的过程。</p><p>再比如在网络欺诈识别场景中，如果用户在新建账号后，立马发生大量交易行为。那么这种“新建账号”到“10分钟内5次交易”的行为就是种非常可疑的行为了。</p><p>诸如此类从数据流表示的事件流中，检测并筛选出符合特定模式或行为的事件序列的过程，我们称之为<strong>复杂事件处理</strong>（Complex Event Processing，简称为CEP）。<strong>CEP也是流计算经常被用来解决的问题。</strong></p><h4 id="6-模型学习和预测"><a href="#6-模型学习和预测" class="headerlink" title="6. 模型学习和预测"></a><strong>6. 模型学习和预测</strong></h4><p>随着流计算越来越流行和普及，越来越多的原本主要针对离线批式数据的统计和机器学习模型也被用于流数据。</p><p>比如在风控系统中，当我们计算好特征后，还需要把这些特征输入评分模型进行风险评分。根据不同的使用场景，使用的评分模型可能是基于规则的模型，也可能是基于机器学习的模型。传统的机器学习模型主要通过离线训练而来，但现在越来越多的模型会直接基于流数据在线训练和更新。</p><p>再比如在异常检测应用中，我们会在线统计并估计变量的分布参数，然后根据训练出的分布模型判断变量之后的取值是否属于异常。<strong>这种同时在线更新和预测的做法，在流计算应用中也越来越常见。</strong></p><h3 id="03-流数据状态和流信息状态"><a href="#03-流数据状态和流信息状态" class="headerlink" title="03 流数据状态和流信息状态"></a><strong>03 流数据状态和流信息状态</strong></h3><p>在流计算系统中，“<strong>状态</strong>”是非常重要的方面。甚至从各种开源流计算框架的发展历史来看，我们会发现大家对实时流计算中的“状态”问题也是一点点逐步才弄清楚的。</p><p>关联操作中临时保存的窗口数据、实现时间维度聚合特征、关联图谱特征、CEP中有限状态机、统计或机器学习模型的参数估计，实时流计算系统需要的最主要的几个计算目标，无不与“状态”有关。但，<strong>这些状态是有区别的！</strong></p><p>我们将流在执行过程中涉及到的状态，分为两类：<strong>流数据状态</strong>和<strong>流信息状态</strong>。</p><ul><li><strong>流数据状态。</strong>在流数据处理的过程中，可能需要处理事件窗口、时间乱序、多流关联等问题，在解决这些问题的过程中，通常会涉及到对部分流数据的临时缓存，并在处理完后将其清理。我们将临时保存的部分流数据称为“流数据状态”。</li><li><strong>流信息状态。</strong>在对流数据的分析过程中，会得到一些我们感兴趣的信息，比如时间维度的聚合数据、关联图谱中的一度关联节点数、CEP中的有限状态机等，这些信息可能会在后续的流数据分析过程中被继续使用，从而需要将这些信息保存下来。同时在后续的流数据处理过程中，这些信息还会被不断地访问和更新。我们将这些分析所得并保存下来的数据称为“流信息状态”。</li></ul><p>将实时流计算应用中的状态分为了“流数据状态”和“流信息状态”。可以说是从两个不同的维度对“流”进行的管理。前者“流数据状态”是从“时间”角度对流进行管理，而后者“流信息状态”则是从“空间”角度对流的管理。</p><p>“流信息状态”弥补了“流数据状态”只是对事件在时间序列上做管理的不足，将流的状态扩展到了任意的空间。</p><p><strong>目前，针对“流信息状态”的存储，主要有三种方式：</strong></p><ul><li>计算节点和状态数据节点分离的分布式内存数据库方案</li></ul><p><img src="redis%E9%9B%86%E7%BE%A4.png" alt=""></p><p>▲图3：使用Redis集群进行状态存储和管理</p><ul><li>计算节点和状态数据节点共存的分布式内存格点方案</li></ul><p><img src="Ignite%E9%9B%86%E7%BE%A4.png" alt="img"></p><p>▲图4：使用Ignite集群进行状态存储和管理</p><ul><li>基于分布式文件系统同步状态数据的方案</li></ul><p><img src="%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt=""></p><p>▲图5：基于分布式文件系统的状态存储和管理集群</p><p>将“流计算应用本身的执行过程”和“流数据的信息管理机制”解耦，这使得实时流计算系统的整体结构更加清晰。如果我们将前者理解为CPU的执行流水线，那么后者就相当于是内存。实时流计算系统的这种架构就非常像是一个分布式的JVM了！</p><h3 id="04-流计算框架"><a href="#04-流计算框架" class="headerlink" title="04 流计算框架"></a><strong>04 流计算框架</strong></h3><p>目前的开源流计算框架有许多，比如Apache Storm、Spark Streaming、Apache Samza、Apache Flink、Akka Streaming、Apache Beam等。这些流计算框架各有特色，那我们该如何面对琳琅满目的流计算框架呢？可以从两个角度来看待这个问题。</p><p><strong>从横向功能特征的角度来看</strong>，其实所有流计算框架的核心概念都是相同的。只要我们掌握了流计算中的核心概念，把握流计算框架中各种问题的关键所在，那么面对这些流计算框架，也不会感到眼花缭乱，乱了阵脚。</p><p><strong>从纵向发展历史的角度来看</strong>，以Flink为代表的新一代流计算框架，在理论和实践上都已日趋完善和成熟。当掌握了流计算中的核心概念后，不妨一开始就站在Flink这个巨人的肩膀上，开始在流计算领域的探索和实践。</p><p>而作为有希望统一流计算领域的Apache Beam，实际上是构建在各种具体流计算框架上的更高一层统一编程模式，它对流计算中的各种概念和问题做出了总结，是我们追踪流计算领域最新进展的一个好切入点。</p><p>最后附上实时流计算系统思维导图（点击图片可放大）：</p><p><img src="%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 流式处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka保证数据可靠性和一致性</title>
      <link href="/2019/04/08/kafka%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2019/04/08/kafka%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650719661&amp;idx=1&amp;sn=c0e9c11a9b254252592e6197487ffc77&amp;chksm=887dd8dbbf0a51cd98a77ff477e79ea968aab8e66d0094bfb603bccf018eaaa083b047d216cb&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650719661&amp;idx=1&amp;sn=c0e9c11a9b254252592e6197487ffc77&amp;chksm=887dd8dbbf0a51cd98a77ff477e79ea968aab8e66d0094bfb603bccf018eaaa083b047d216cb&amp;scene=0&amp;xtrack=1#rd</a></p><p>学过大数据的同学应该都知道 Kafka，它是分布式消息订阅系统，有非常好的横向扩展性，可实时存储海量数据，是流数据处理中间件的事实标准。本文将介绍 Kafka 是如何保证数据可靠性和一致性的。</p><h2 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a><strong>数据可靠性</strong></h2><p>Kafka 作为一个商业级消息中间件，消息可靠性的重要性可想而知。本文从 Producter 往 Broker 发送消息、Topic 分区副本以及 Leader 选举几个角度介绍数据的可靠性。</p><h3 id="Topic-分区副本"><a href="#Topic-分区副本" class="headerlink" title="Topic 分区副本"></a><strong>Topic 分区副本</strong></h3><p>在 Kafka 0.8.0 之前，Kafka 是没有副本的概念的，那时候人们只会用 Kafka 存储一些不重要的数据，因为没有副本，数据很可能会丢失。但是随着业务的发展，支持副本的功能越来越强烈，所以为了保证数据的可靠性，Kafka 从 0.8.0 版本开始引入了分区副本（详情请参见 KAFKA-50）。也就是说每个分区可以人为的配置几个副本（比如创建主题的时候指定 replication-factor，也可以在 Broker 级别进行配置 default.replication.factor），一般会设置为3。</p><p>Kafka 可以保证单个分区里的事件是有序的，分区可以在线（可用），也可以离线（不可用）。在众多的分区副本里面有一个副本是 Leader，其余的副本是 follower，所有的读写操作都是经过 Leader 进行的，同时 follower 会定期地去 leader 上的复制数据。当 Leader 挂了的时候，其中一个 follower 会重新成为新的 Leader。通过分区副本，引入了数据冗余，同时也提供了 Kafka 的数据可靠性。</p><p>Kafka 的分区多副本架构是 Kafka 可靠性保证的核心，把消息写入多个副本可以使 Kafka 在发生崩溃时仍能保证消息的持久性。</p><h3 id="Producer-往-Broker-发送消息"><a href="#Producer-往-Broker-发送消息" class="headerlink" title="Producer 往 Broker 发送消息"></a><strong>Producer 往 Broker 发送消息</strong></h3><p>如果我们要往 Kafka 对应的主题发送消息，我们需要通过 Producer 完成。前面我们讲过 Kafka 主题对应了多个分区，每个分区下面又对应了多个副本；为了让用户设置数据可靠性， Kafka 在 Producer 里面提供了消息确认机制。也就是说我们可以通过配置来决定消息发送到对应分区的几个副本才算消息发送成功。可以在定义 Producer 时通过 acks 参数指定（在 0.8.2.X 版本之前是通过 request.required.acks 参数设置的，详见 KAFKA-3043）。这个参数支持以下三种值：</p><ul><li>acks = 0：意味着如果生产者能够通过网络把消息发送出去，那么就认为消息已成功写入 Kafka 。在这种情况下还是有可能发生错误，比如发送的对象无能被序列化或者网卡发生故障，但如果是分区离线或整个集群长时间不可用，那就不会收到任何错误。在 acks=0 模式下的运行速度是非常快的（这就是为什么很多基准测试都是基于这个模式），你可以得到惊人的吞吐量和带宽利用率，不过如果选择了这种模式， 一定会丢失一些消息。</li><li>acks = 1：意味若 Leader 在收到消息并把它写入到分区数据文件（不一定同步到磁盘上）时会返回确认或错误响应。在这个模式下，如果发生正常的 Leader 选举，生产者会在选举时收到一个 LeaderNotAvailableException 异常，如果生产者能恰当地处理这个错误，它会重试发送悄息，最终消息会安全到达新的 Leader 那里。不过在这个模式下仍然有可能丢失数据，比如消息已经成功写入 Leader，但在消息被复制到 follower 副本之前 Leader发生崩溃。</li><li>acks = all（这个和 request.required.acks = -1 含义一样）：意味着 Leader 在返回确认或错误响应之前，会等待所有同步副本都收到悄息。如果和 min.insync.replicas 参数结合起来，就可以决定在返回确认前至少有多少个副本能够收到悄息，生产者会一直重试直到消息被成功提交。不过这也是最慢的做法，因为生产者在继续发送其他消息之前需要等待所有副本都收到当前的消息。</li></ul><p>根据实际的应用场景，我们设置不同的 acks，以此保证数据的可靠性。</p><p>另外，Producer 发送消息还可以选择同步（默认，通过 producer.type=sync 配置） 或者异步（producer.type=async）模式。如果设置成异步，虽然会极大的提高消息发送的性能，但是这样会增加丢失数据的风险。如果需要确保消息的可靠性，必须将 producer.type 设置为 sync。</p><h3 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a><strong>Leader 选举</strong></h3><p>在介绍 Leader 选举之前，让我们先来了解一下 ISR（in-sync replicas）列表。每个分区的 leader 会维护一个 ISR 列表，ISR 列表里面就是 follower 副本的 Borker 编号，只有跟得上 Leader 的 follower 副本才能加入到 ISR 里面，这个是通过 replica.lag.time.max.ms 参数配置的。只有 ISR 里的成员才有被选为 leader 的可能。</p><p>所以当 Leader 挂掉了，而且 unclean.leader.election.enable=false 的情况下，Kafka 会从 ISR 列表中选择第一个 follower 作为新的 Leader，因为这个分区拥有最新的已经 committed 的消息。通过这个可以保证已经 committed 的消息的数据可靠性。</p><p>综上所述，为了保证数据的可靠性，我们最少需要配置一下几个参数：</p><ul><li>producer 级别：acks=all（或者 request.required.acks=-1），同时发生模式为同步 producer.type=sync</li><li>topic 级别：设置 replication.factor&gt;=3，并且 min.insync.replicas&gt;=2；</li><li>broker 级别：关闭不完全的 Leader 选举，即 unclean.leader.election.enable=false；</li></ul><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a><strong>数据一致性</strong></h2><p>这里介绍的数据一致性主要是说不论是老的 Leader 还是新选举的 Leader，Consumer 都能读到一样的数据。那么 Kafka 是如何实现的呢？</p><p><img src="%E4%B8%80%E8%87%B4%E6%80%A7.png" alt=""></p><p>假设分区的副本为3，其中副本0是 Leader，副本1和副本2是 follower，并且在 ISR 列表里面。虽然副本0已经写入了 Message4，但是 Consumer 只能读取到 Message2。因为所有的 ISR 都同步了 Message2，只有 High Water Mark 以上的消息才支持 Consumer 读取，而 High Water Mark 取决于 ISR 列表里面偏移量最小的分区，对应于上图的副本2，这个很类似于木桶原理。</p><p>这样做的原因是还没有被足够多副本复制的消息被认为是“不安全”的，如果 Leader 发生崩溃，另一个副本成为新 Leader，那么这些消息很可能丢失了。如果我们允许消费者读取这些消息，可能就会破坏一致性。试想，一个消费者从当前 Leader（副本0） 读取并处理了 Message4，这个时候 Leader 挂掉了，选举了副本1为新的 Leader，这时候另一个消费者再去从新的 Leader 读取消息，发现这个消息其实并不存在，这就导致了数据不一致性问题。</p><p>当然，引入了 High Water Mark 机制，会导致 Broker 间的消息复制因为某些原因变慢，那么消息到达消费者的时间也会随之变长（因为我们会先等待消息复制完毕）。延迟时间可以通过参数 replica.lag.time.max.ms 参数配置，它指定了副本在复制消息时可被允许的最大延迟时间。</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop YARN 在快手的应用实践与技术演进之路</title>
      <link href="/2019/04/08/Hadoop%20YARN%20%E5%9C%A8%E5%BF%AB%E6%89%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/04/08/Hadoop%20YARN%20%E5%9C%A8%E5%BF%AB%E6%89%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>原文出处：<a href="https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650719076&amp;idx=1&amp;sn=3956a8f9d1dcfc63132984a1f71bf582&amp;chksm=887dde12bf0a5704aca4066aa590bd3fbedbaf9533b48734c145d1355eccdde9812da487da57&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1586262523299&amp;sharer_shareid=9f8f1bd360ef58661a2034df035a1bb1#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650719076&amp;idx=1&amp;sn=3956a8f9d1dcfc63132984a1f71bf582&amp;chksm=887dde12bf0a5704aca4066aa590bd3fbedbaf9533b48734c145d1355eccdde9812da487da57&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1586262523299&amp;sharer_shareid=9f8f1bd360ef58661a2034df035a1bb1#rd</a></p><p>本文主要分为三部分：<strong>yarn的背景、</strong> <strong>yarn技术改进、</strong> <strong>yarn未来规划。</strong></p><h3 id="yarn背景"><a href="#yarn背景" class="headerlink" title="yarn背景"></a>yarn背景</h3><p>yarn大家都比较熟悉了，是从Hadoop1.0分离到2.0的比较重要的特性，把原来的jobtracker集中式调度变成yarn的二级调度，解决集群扩展性的问题。yarn主要是分成了三个模块，ResourceManager来管理整个集群的资源，NodeManager管理整个机器资源情况，ApplicationMaster管理整个APP的资源信息。MR/SPARK/Flink实现了自己的AM逻辑在yarn上运行。</p><p><img src="yarn.png" alt=""></p><p>接下来介绍一下yarn的RM模块。yarn的RM模块按照功能可以分成两部分：集群状态管理和资源分配。RM内部通过ResourceTrackerService和ApplicationMasterService 负责NM和APP的通信交互。服务内部会生成相应的事件交给内部的事件处理器处理。驱动NM和APP状态机的运行，确保APP和NM处于合适的状态。调度通俗的讲就是把节点的空闲资源分配给需要的APP。社区早期版本的yarn是在心跳逻辑里面触发整个调度逻辑的，这里面有一个问题，调度过程会跟整个事件处理的竞争资源，导致两方相互影响，性能不高，后来yarn社区做了优化，把整个调度逻辑拆离，放到单独线程来做。</p><p><img src="RM.png" alt=""></p><p><strong>yarn在快手的应用特点</strong></p><p>yarn在快手是非常典型的大数据的应用栈，yarn上面服务了一些经典的离线计算，像HiveSQL，最终回变成一个MR／SPARK作业或者PESTO查询在yarn上运行。对于流式的实时数据处理需求，我们上层有一个青藤平台来托管FLINK在YARN上运行。对于模型训练的场景，我们是用XLearning作为调度器，调度TensorFlow，XGBoost，MPI等训练学习引擎。基于Spark和XLearning，我们打造了亚瑟机器学习平台，可以把数据处理流程和一些模型的训练、预测流程做一个打通，方便用户使用。</p><p><img src="yarn%E5%9C%A8%E5%BF%AB%E6%89%8B.png" alt=""></p><h3 id="yarn技术改进"><a href="#yarn技术改进" class="headerlink" title="yarn技术改进"></a><strong>yarn技术改进</strong></h3><h4 id="1-yarn技术实践和演进"><a href="#1-yarn技术实践和演进" class="headerlink" title="1. yarn技术实践和演进"></a>1. yarn技术实践和演进</h4><p>对yarn的一些改动，主要分成四个方面：（1）集群稳定性方面的优化。（2）对yarn的抢占机制做了优化。（3）yarn的调度性能提升。（4）计算集群小IO优化。</p><p><img src="%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%BC%94%E8%BF%9B.png" alt=""></p><h4 id="2-整个集群变大以后，对yarn调度系统来说面临什么问题"><a href="#2-整个集群变大以后，对yarn调度系统来说面临什么问题" class="headerlink" title="2.整个集群变大以后，对yarn调度系统来说面临什么问题?"></a>2.整个集群变大以后，对yarn调度系统来说面临什么问题?</h4><p>直观的感觉来说，整个集群变大，节点就变多了，running的APP也会增多。节点和APP增多会导致RM对外服务压力变大，事件处理逻辑增多，事件处理压力会比较大，并且对增加整个调度的压力。因为你有很多的APP需要请求资源，你整个资源池又非常大，所以整个调度压力是非常大的，怎么解决这个压力的问题。还有整个状态变化会非常多，这时候会有一些事件处理，在yarn原生的框架里面，事件处理是单线程的，会有各种各样的问题，整个事件处理压力非常大。针对这些问题我们做了一些针对性的优化。在大集群里面，机器故障会变得越来越频繁，怎么应对机器故障对整个作业稳定性造成的影响，这也是比较重要的方面。</p><p><img src="%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98.png" alt=""></p><h4 id="3-在RM方面做的一些优化"><a href="#3-在RM方面做的一些优化" class="headerlink" title="3.在RM方面做的一些优化"></a>3.在RM方面做的一些优化</h4><p>从几个比较经典的Case来说一下。有一次我们升级整个集群的时候，导致整个集群挂掉，一次升级几百个机器，直接导致RM事件雪崩，最终OOM掉。我们发现是RM和NM交互有一些冗余事件的，我们对冗余事件进行了一些优化。对于NM，我们设计了一个慢启动的策略，如果NM刚启动没有必要维持每秒汇报一次，开始可以20秒汇报一次，下次10秒，下次5秒，最终恢复到正常，这样会把整个RM的事件处理压力降下来，最终升级集群对RM基本没什么影响。最终升级瓶颈变成了我们的运维系统，不能并发升级太多机器。</p><p>HDFS是yarn非常底层的基础设施，ResourceManager事件处理逻辑中有一些HDFS操作，HDFS卡一下，会造成整个事件处理逻辑卡住，最终整个集群卡住。分析发现RM对HDFS的操作主要集中在失败APP的处理，不是非常核心的逻辑，解决方案也比较简单粗暴，把HDFS的操作从同步改成异步。我们还对整个yarn事件处理逻辑进行排查，发现有一些像DNS的操作，在某些情况下也会比较卡，我们就把这种比较重IO的操作进行相应的优化，确保事件处理逻辑中都是快速的CPU操作，保证事件处理的高效和稳定。</p><p>经过优化之后，我们发现在集群规模比较大的时候，事件处理过程还是要消耗非常多的CPU，我们profile发现，大部分的CPU的消耗是处理NM节点信息的汇报，RM事件处理主要分几个部分，有一些是节点级别的，有一些是APP级别的，有一些调度级别的。NM级别跟其他的是没有太必要放在同一个线程处理，我们把它抽离出来，放在一个额外的线程上，这样把大部分处理迁出去了，让整个事件处理逻辑变得比较轻量。</p><p>2.6之后yarn支持状态恢复，RM重启理论上对APP是没有影响的，可以把APP恢复出来，但是还是有一些比较小的缺陷，会造成APP的失败，比如没有把一些异常cover住，抛到AM，导致AM挂掉，token恢复在一些场景下也有问题。我们的RM升级是非常频繁的，基本上2天左右就会升级新版本，集群上有一些非常重要的作业，所以失败，对他们造成的影响会比较大。</p><p><img src="%E6%80%A7%E8%83%BD%E6%80%A7%E6%94%B9%E8%BF%9B.png" alt=""></p><h4 id="4-在从节点上面怎么避免单点问题"><a href="#4-在从节点上面怎么避免单点问题" class="headerlink" title="4.在从节点上面怎么避免单点问题"></a>4.在从节点上面怎么避免单点问题</h4><p>yarn社区本身是有一个磁盘的故障监测机制的，基本的思路也会定期在磁盘上创建目录，如果能创建成功说明这个磁盘是OK的，如果失败就认为你这个磁盘有问题，这个比较简单有效。但是在某些特定场景下，会有一些奇怪的磁盘问题，比如整个磁盘是好的，但是某个目录是坏的，可能会导致某些特定的作业失败。我们扩展了NM磁盘的黑名单功能，通过container的失败信息做一些规则匹配，这样可以定向发现一些磁盘问题，把疑似有问题的磁盘放在黑名单里面，不再向这个磁盘调度作业。</p><p>yarn有一个比较大的问题，如果你有一台机器有问题，造成一些container调度失败，并且系统没有捕获的话，会造成雪崩效应，比如一批container启动失败了，这台机器资源看起来非常空闲，然后RM发现机器空闲，就调动更多container上来，然后越来越多的container失败，最后导致很多APP运行失败。社区提出了AM的黑名单机制，主要来解决AM的失败问题，如果AM大量失败，不往这台机器上调度AM，APP内部依赖自己的黑名单机制，发现这些问题机器。我们觉得这样可能会造成很多无效的container失败，所以我们的解决思路是建立整个集群的黑名单，而不单独是AM的黑名单。当我们通过一些规则发现有大量的container在某一台机器失败，或者这台机器的container调度速度非常异常，我们会把这台机器放到我们集群的黑名单里面，不再向这台机器调度资源。</p><p>资源隔离方面，现在社区主要是用cgroup做一些内存和CPU的隔离，其他方面的隔离非常弱的，我们当时碰到一些场景比如磁盘打满了，FD泄露、线程泄露的问题。曾经在上一家公司的时候写过一个程序，有线程泄露的问题，泄露之后把整个机器的线程全用光了，这样导致这个机器所有服务异常，计算框架计算不断把这个问题task调度到其他机器上，最终把整个集群都打挂了。解决方案就是对container的线程数目，磁盘大小定期检查，如果超过阙值，直接kill掉。</p><p>单台机器的故障率比较低，但集群规模变大之后，整体故障率变得非常高。怎么发现这些机器是个问题。我们借助container失败率做一个基本的判断。如果是一台机器失败率高于正常值，可能是非常有问题的，需要人工检查一下。还可以借助一些物理指标的异常检测，因为在离线系统里面，CPU打得比较高的，load也比较高，所以当前这些指标可能不容易发现，用syscpu作为异常检测指标，集群中经常有些机器task跑的比较慢，重启机器就好了。一台机器有问题会导致Task失败，Task失败会导致作业的失败，我们做了一个失败APP的归因系统，可以从归因系统里面发现一些问题机器。单纯从作业失败还不够，我们正在做一个基于失败TASK的归因系统，因为TASK有容灾重试机制，可能会掩盖潜在问题。</p><p><img src="%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%94%B9%E8%BF%9B.png" alt=""></p><h4 id="5-yarn调度方面做的优化"><a href="#5-yarn调度方面做的优化" class="headerlink" title="5.yarn调度方面做的优化"></a>5.yarn调度方面做的优化</h4><p>yarn一个主要的功能，就是要调度整个集群的资源，它的视角是整个集群的节点信息，还有APP的资源请求信息，还有一些队列信息。yarn的调度模型里面，逻辑是比较复杂的， 简单说，先来一个节点，如果这个节点有一定资源的话，会对集群中的一级队列做排序，然后选出最应该调度的队列。选择这个队列之后找这个队列下面的二级队列进行排序，逐渐递归找到APP，选一个合适的APP进行调度，如果资源调度不上，再找下一个APP。调度逻辑是要耗费很大资源的，主要是各种排序。但整个排序真的有这么大必要吗？</p><p><img src="%E8%B0%83%E5%BA%A6%E4%BC%98%E5%8C%96.png" alt=""></p><p><strong>我们早期思路就是怎么减少整个排序的时间，减少排序时间从三方面着手，减少排序规模，减少单次排序时间，优化排序算法</strong>。如何减少排序规模？集群里有几千个队列，几千个队列是不是都需要资源？APP是不是都需要资源，是否都需要排序？实际场景中大部分是不需要资源和参与排序的，这样把整个排序规模减小了。在调度单词排序时，使用了java.collection.sort()函数排序的，每次排序涉及到两个元素的compare，怎么来减少compare的开销？在yarn里面每一次compare的时候有很多可以可以优化的地方，比如计算一个队列使用的资源量，有一些临时对象可以cache住，最终缩小整个单次排序的时间。Collection.sort底层使用归并排序，我们改成堆排序，经过这些优化后，差不多能够支撑5000台机器的规模。</p><p><img src="%E8%B0%83%E5%BA%A6%E4%BC%98%E5%8C%96-%E7%BC%A9%E7%9F%AD%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4.png" alt=""></p><p>优化之后还是存在一个很明显的问题，调度的扩展性是不足的，因为整个排序过程都是在一个CPU里面，如果想利用更多CPU，会涉及到整个排序怎么切分，节点怎么切分、作业怎么切分，怎么让资源分配达到均衡，怎么保证公平性，涉及到非常复杂的策略，非常难拆分。yarn调度是先选一个节点，然后再选APP，调度过程只看到一个节点的信息，而看不到整体的集群信息，整个调度策略是非常受限，很难加一些策略在里面。比如yarn本地化一个非常简单的功能实现上比较复杂，在整个调度框架层面。如何来解决这个问题？</p><p><img src="%E4%BC%98%E5%8C%96%E5%90%8E%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png" alt=""></p><p>最终决定我们重写调度逻辑，开发了Kwaischeduler。我们觉得在整个集群里面有一个上帝视角的，你可以拿到整个集群的资源使用情况和资源配置情况和每一个队列、每个APP的资源需求量和资源的配置。基于这些信息，我们能够计算出来，应该给每一个APP来分配多少资源。然后App资源的分配过程我们完全可以并发起来，借助多线程的能力，去整个资源池里面抢这些资源。因为我们是先调度APP的，所以抢这些资源的时候，借鉴K8S的调度思路，先对节点进行过滤，然后按照不同的调度策略，给每个节点打分，每个策略可以有一个权重，从理论上来说每个APP都可以有自己的策略。Kwai scheduler上线后调度性能和调度策略扩展性不是问题，现在单集群的调度性能可以达到每秒钟4万多container，对比国内其他厂商和社区，我们的调度性能和扩展性上表现还不错。</p><p><img src="Kwaischeduler.png" alt=""></p><p><strong>简单介绍一下底层实现。首先主要分成两部分，一部分是集群资源的预分配过程，把一些资源分配到每个APP，第二部分是APP怎么去每台机器上竞争资源</strong>。有一个单独线程定期会对集群情况做snapshot，基于snapshot来做一个上帝视角的资源分配。我们为每个APP分配出资源之后，就可以把APP丢到线程池里面并发抢资源，对相应的节点排序，选出分数最高的节点，最终你会有一个commit的过程，真正拿到资源。整个调度分配结束后，会把整个分配结果写回到整个原生的yarn框架。</p><p><img src="Kwaischeduler%E5%8E%9F%E7%90%86.png" alt=""></p><p><strong>在计算集群里面有一个大的问题，就很多的小IO</strong>。在我们业务场景里面，快手的数据规模比较大比较大，经常是几十万个map，几千reduce。一个map也没有多少数据，可能就是250M，reduce单次shuffle取的数据非常小的，可能只有几K几十K，所以有很多的小IO，导致整个集群磁盘util非常高，但是磁盘读写速度非常慢。针对这个问题，我们对MR的shuffle过程做一个Cache。在shuffle过程中，当一个请求来的时候，我们分析一下这次shuffle过程有没有可能产生比较多小IO，可以按需把shuffle数据放到cache里，只需要一次大的IO把数据搬到Cache里面，后面的shuffle请求可以直接从cache里面读，消灭了后面多次小IO，通过这个我们优化，提升了整个的集群IO性能。</p><p><img src="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.png" alt=""></p><p><strong>yarn为什么有抢占的问题，为什么K8S这些在线系统不会有抢占问题</strong>。yarn主要是离线调度系统，资源使用不像在线系统比较恒定，有一些突增，这意味着如果完全资源配额限制资源，会导致整个集群的资源利用率降低或者job的运行时间拉长。所以yarn允许你的资源使用超过配额。这带来另一个问题，使用超过配额后，当另一个队列需要资源的时候，能不能及时把这些资源释放出来。在大部分情况下是可以的，因为离线系统的作业一般会比较快的结束。但是在特殊场景下，有可能是一个spark作业一直占着资源不释放，可能会导致一些比较核心的作业拿不到资源。抢占主要是解决这个问题。但是在大部分的公司，抢占是没有打开的，原因主要因为社区版本的抢占不太可控。会基于队列的资源使用量来决定是否抢占，如果核心队列资源使用超过配额太多， 可能会被非核心队列抢占，存在比较大的风险。我们解读这个问题的思路是基于一些核心队列来触发的抢占，抢占只能从核心的队列触发，被抢占的只是非核心队列，这样就解决低优先级作业抢占核心的作业问题。但是这个方案还是有些问题，如果使用资源超过配额的都是一些核心的作业，这时候怎么处理？我们主要思路是，希望构建整个集群的作业优先级体系，把作业重要性系统做一个全局拉起，这样我们可以做一些队列内部的抢占和跨核心队列之间的抢占。</p><p><img src="%E8%B5%84%E6%BA%90%E6%8A%A2%E5%8D%A0%E6%94%B9%E8%BF%9B.png" alt=""></p><h3 id="yarn的未来规划"><a href="#yarn的未来规划" class="headerlink" title="yarn的未来规划"></a>yarn的未来规划</h3><p>构建作业分级保障，现在我们yarn的集群规模比较大，大家使用的资源都非常多，但是这些资源有没有用到真正比较重要的业务上，其实我们是有些疑问的，有多少无效的计算在里面，当然这个涉及到业务层的优化。为作业打一些作业的标签，基于这些任务的标签，以及优先级的特性，刻划整个集群资源的使用情况，为预算或者其他的技术方案提供一些技术的底层支持。</p><p>我们现在单个yarn集群规模在国内是top级的，但是单集群毕竟是容量有限，我们后面会考虑多集群建设的方案，社区的federation方案在跨IDC方面有些问题，如何在业务透明的前提下，建设跨IDC集群有非常多问题需要解决。</p><p><img src="%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92.png" alt=""></p><p><strong>yarn现在主要托管的是一些离线计算的资源</strong>，公司还有很多空闲资源没有使用，怎么来使用这些空闲资源，怎么做到把一些合适的任务调入到一些比较空闲的机器上，当这个机器需要的时候，及时把任务迁移走，怎么减少业务相互的影响，底层这方面需要做什么支撑，这都需要探索。</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java与线程</title>
      <link href="/2019/03/30/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/03/30/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址，文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。</p><p>Java语言提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start()且还没有结束的<code>java.lang.Thread</code>类的实例就代表了一个线程。</p><p>实现线程的主要有三种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现</p><h4 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h4><p>内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核（Kernel）支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。</p><p>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能由轻量级进程。轻量级进程与内核线程之间1：1的关系称为1对1的线程模型。</p><p><img src="%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B.png" alt=""></p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使一个轻量级线程在系统调用中阻塞了，也不会影响整个进程继续工作。但轻量级进程具有以下局限性：</p><ul><li>由于是基于内核线程实现的，所以各个线程操作，如创建，析构以及同步，都需要进行系统调用，而系统调用的代价比较高，需要从用户态和内核态中来回切换。</li><li>每个轻量级进程都需要一个内核线程的支持，因此轻量级进程要消耗一定的内核资源，因此一个系统支持轻量级进程的数量是有限的。</li></ul><p>对于Sun JDK来说，它的windows版与Linux版都是使用一对一的线程模型实现的，一条java线程就映射到一条轻量级进程之中。</p><h4 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h4><p>用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立，同步，销毁和调度完全在用户态完成，不需要内核帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现。进程与用户线程之间是1：N的关系。</p><h4 id="使用用户线程加轻量级进程混合使用"><a href="#使用用户线程加轻量级进程混合使用" class="headerlink" title="使用用户线程加轻量级进程混合使用"></a>使用用户线程加轻量级进程混合使用</h4><p>在该模式下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间上，因此用户线程的创建，切换，析构等操作依然廉价，并且可以支持大规模的用户线程并发。</p><p>操作系统提供支持的轻量级进程则作为用户线程和内核之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程完成，大大降低了整个进程被完全阻塞的风险。轻量级进程和用户线程是N：M的关系。</p><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p><strong>线程调度是指系统为线程分配处理器使用权的过程</strong>。主要的调度方式有两种：协同式线程调度和抢占式线程调度。</p><ul><li>使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要通知系统切换到另一个线程上。<ul><li>优点即实现简单，而且没有什么线程同步问题</li><li>缺点是线程执行时间不可控制，如果一个线程编写出现问题，一直不通知系统进行线程切换，则该线程会一直阻塞在那里。</li></ul></li><li>使用抢占式调度的多线程系统，每个线程将由系统来分配执行时间，线程的切换不由线程本身决定（在java中可以使用Thread.yield()方法让出执行时间，但获取执行时间是不可控的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会出现一个线程导致整个进程阻塞的问题。</li></ul><p>java是使用抢占式调度方式，虽然java线程调度是系统自动完成的，但我们可以设置线程优先级，建议系统给高优先级的线程多分配一些时间。</p><h3 id="Java线程状态转换"><a href="#Java线程状态转换" class="headerlink" title="Java线程状态转换"></a>Java线程状态转换</h3><p>java语言有5种线程状态，在任意时间点，一个线程只能有且只有其中的一种状态。</p><p><img src="%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt=""></p><ol><li><p>新建（New）</p><p>创建后尚未启动的线程处于这种状态</p></li><li><p>运行（Runable）</p><p>Runable包括了操作系统线程状态种的Running和Ready，也就是处于该状态的线程可能正在执行，也有可能正在等待着CPU为它分配执行时间。</p></li><li><p>等待</p><ul><li><p>无限期等待</p><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下是让线程进入无限期等待的几种方式</p><ul><li>没有设置Timtout参数的Object.wait()方法</li><li>没有设置Timeout参数的Thread.join()方法</li><li>LockSupport.park()方法</li></ul></li><li><p>限期等待</p><p>处于这种状态的线程不会被分配CPU执行时间，不过无需等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下是让线程进入限期等待的几种方式</p><ul><li>Thread.sleep()方法</li><li>设置了Timtout参数的Object.wait()方法</li><li>设置了Timeout参数的Thread.join()方法</li><li>LockSupport.parkNanos()方法</li><li>LockSupport.parkUntil()方法</li></ul></li></ul></li><li><p>阻塞</p><p>线程被阻塞了，<code>阻塞状态</code>与<code>等待状态</code>的区别是：</p><ul><li>阻塞状态在等待获取到一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生</li><li>等到状态是在等待一段时间，或者唤醒动作的发生，在程序等待进入同步区域时，线程会进入这种状态</li></ul></li><li><p>结束</p><p>已终止线程的线程状态，线程已经结束执行</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Executors框架</title>
      <link href="/2019/03/22/Executors%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/03/22/Executors%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Executors框架概述"><a href="#Executors框架概述" class="headerlink" title="Executors框架概述"></a>Executors框架概述</h3><p>Executors框架整体架构如下：</p><p><img src="Executors%E6%A1%86%E6%9E%B6.png" alt=""></p><ul><li><strong>Executor</strong><br>执行器接口，也是最顶层的抽象核心接口， 分离了任务和任务的执行。</li><li><strong>ExecutorService</strong><br>在Executor的基础上提供了执行器生命周期管理，任务异步执行等功能。</li><li><strong>ScheduledExecutorService</strong><br>在ExecutorService基础上提供了任务的延迟执行/周期执行的功能。</li><li><strong>Executors</strong><br>生产具体的执行器的静态工厂</li><li><strong>ThreadFactory</strong><br>线程工厂，用于创建单个线程，减少手工创建线程的繁琐工作，同时能够复用工厂的特性。</li><li><strong>AbstractExecutorService</strong><br>ExecutorService的抽象实现，为各类执行器类的实现提供基础。</li><li><strong>ThreadPoolExecutor</strong><br>线程池Executor，也是最常用的Executor，可以以线程池的方式管理线程。</li><li><strong>ScheduledThreadPoolExecutor</strong><br>在ThreadPoolExecutor基础上，增加了对周期任务调度的支持。</li><li><strong>ForkJoinPool</strong><br>Fork/Join线程池，在JDK1.7时引入，时实现Fork/Join框架的核心类。</li></ul><h3 id="Executors详解"><a href="#Executors详解" class="headerlink" title="Executors详解"></a>Executors详解</h3><p>Executors框架是用来解耦任务本身和任务的执行的，主要是通过上图中三个接口满足使用者需求</p><ol><li><strong>Executor</strong>：提交普通的可执行任务</li><li><strong>ExecutorService</strong>：提供对线程池生命周期的管理、异步任务的支持</li><li><strong>ScheduledExecutorService</strong>：提供对任务的周期性执行支持</li></ol><p>而Executors类，专门用于创建 上述接口的实现类对象，Executors就是一个简单的工厂，可以生产4类Executor执行器实例，它的所有方法都是静态的。（Executors也可以提供Fork/Join线程池，但目前不太了解，故先不研究）。</p><h4 id="ThreadFactory线程工厂"><a href="#ThreadFactory线程工厂" class="headerlink" title="ThreadFactory线程工厂"></a>ThreadFactory线程工厂</h4><p>这4类线程池都包含两个重载的方法，一个是不传入ThreadFactory，一个是传入ThreadFactory。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Constructs a new {@code Thread}.  Implementations may also initialize     * priority, name, daemon status, {@code ThreadGroup}, etc.     *     * @param r a runnable to be executed by new thread instance     * @return constructed thread, or {@code null} if the request to     *         create a thread is rejected     */</span>    Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Executors返回的是线程池，这里面会涉及到线程的创建，如果使用<code>new Thread()</code>这种方法创建线程，且需要给线程设置名字等属性时会很麻烦，而ThreadFactory 作为一个线程工厂可以减轻这些任务量，我们可以根据需求定制ThreadFactory，当创建线程时直接使用ThreadFactory创建即可。所以我们在创建线程池中指定ThreadFactory，可以决定线程池中线程的具体创建方式。比如以下几个Demo：</p><p>demo1</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleThreadFactoryDemo</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">{</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><p>该线程工厂只负责接收一个Runnable对象，并将其封装在Thread中进行执行。</p><p>demo2</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FixCountThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_THREAD<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token function">FixCountThreadFactory</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>          MAX_THREAD <span class="token operator">=</span> maxThread<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> incrementAndGet <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>incrementAndGet <span class="token operator">></span> MAX_THREAD<span class="token punctuation">)</span>          <span class="token punctuation">{</span>              count<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> null<span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><p>该线程工厂可以控制线程的数量，数量不大于设置的MAX_THREAD。</p><p>demo3</p><p>创建线程池可以指定ThreadFactory或者不指定ThreadFactory，当不指定时ThreadFactory时，使用的时默认的线程工厂类<code>DefaultThreadFactory</code>，该类也是Executors的静态方法类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//线程池数量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AtomicInteger poolNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//线程组</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ThreadGroup group<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//线程数量</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger threadNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//线程池名称</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String namePrefix<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置属性</span>    <span class="token function">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SecurityManager s <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        group <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> s<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>                              Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        namePrefix <span class="token operator">=</span> <span class="token string">"pool-"</span> <span class="token operator">+</span>            poolNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>            <span class="token string">"-thread-"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建线程</span>    <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> r<span class="token punctuation">,</span>                              namePrefix <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span>            t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="固定线程数的线程池"><a href="#固定线程数的线程池" class="headerlink" title="固定线程数的线程池"></a>固定线程数的线程池</h4><p>固定线程数量的线程池的特点：</p><ul><li>在初始化时确定其中的线程总数，运行过程中始终维持线程数量不变</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建固定线程数的线程池</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建固定线程数的线程池，且需要提供ThreadFactory创建新线程</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>两种创建方法其实都返回了一个ThreadPoolExecutor实例，ThreadPoolExecutor是一个ExecutorService接口的实现类。</p><h4 id="单个线程的线程池"><a href="#单个线程的线程池" class="headerlink" title="单个线程的线程池"></a>单个线程的线程池</h4><p>单个线程数量的线程池的特点</p><ul><li>线程数为1的固定线程池</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//需要提供ThreadFactory</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span>ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    threadFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中返回的Executor实例使用<code>FinalizableDelegatedExecutorService</code>对象进行包装。</p><p><code>FinalizableDelegatedExecutorService</code>是一个Executors的静态内部类，该类只有一个finalize()方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">FinalizableDelegatedExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">DelegatedExecutorService</span> <span class="token punctuation">{</span>    <span class="token function">FinalizableDelegatedExecutorService</span><span class="token punctuation">(</span>ExecutorService executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>FinalizableDelegatedExecutorService</code>主要是继承了<code>DelegatedExecutorService</code>，该类也是Executors的静态内部类。<code>DelegatedExecutorService</code>实现了ExecutorService的全部方法，这些方法全都是通过传入的ExecutorService实例实现的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DelegatedExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> ExecutorService e<span class="token punctuation">;</span>        <span class="token function">DelegatedExecutorService</span><span class="token punctuation">(</span>ExecutorService executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>             e <span class="token operator">=</span> executor<span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>             e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//中间方法省略</span>        <span class="token comment" spellcheck="true">//....</span>        <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                               <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>            <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>            <span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">invokeAny</span><span class="token punctuation">(</span>tasks<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>为何在单个线程的线程池中加入一个包装类？</p><p>因为返回的ThreadPoolExecutor包含一些设置线程池大小的方法——比如setCorePoolSize，对于只有单个线程的线程池来说，我们是不希望用户通过强转的方式使用这些方法的，所以需要一个包装类，只暴露ExecutorService本身的方法。</p></blockquote><h4 id="可缓冲的线程池"><a href="#可缓冲的线程池" class="headerlink" title="可缓冲的线程池"></a>可缓冲的线程池</h4><p>可缓冲的线程池的特点</p><ul><li><p>如果没有可用线程，则创建一个新线程并添加到池中</p></li><li><p>如果有线程长时间未被使用（默认60s），则从缓存中移除</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//需要提供ThreadFactory</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span>ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>线程被清理的时间可以通过ThreadFactory配置。</p><h4 id="可延迟-周期调度的线程池"><a href="#可延迟-周期调度的线程池" class="headerlink" title="可延迟/周期调度的线程池"></a>可延迟/周期调度的线程池</h4><p>可延迟/周期调度的线程池的特点</p><ul><li>可以使任务周期性或延迟后执行</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledExecutorService <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledExecutorService <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span>            <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>两种创建方法其实都返回了一个ScheduledThreadPoolExecutor实例，ScheduledThreadPoolExecutor是一个ScheduledExecutorService接口的实现类。</p><h3 id="Executors使用实例"><a href="#Executors使用实例" class="headerlink" title="Executors使用实例"></a>Executors使用实例</h3><h4 id="固定线程数的线程池使用"><a href="#固定线程数的线程池使用" class="headerlink" title="固定线程数的线程池使用"></a>固定线程数的线程池使用</h4><p>题目1：使用3个线程求1加到12，每个线程处理4个数，最后得到1加到12的总和</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//因为创建了3个对象，并且每个对象对应一个线程，因此锁是类级别的</span><span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计算加和</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> splitSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token operator">&lt;</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                String name <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"处理："</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">++</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                splitSum <span class="token operator">+=</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        sum<span class="token operator">+=</span>splitSum<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1+...+12 = "</span><span class="token operator">+</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FixedThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建有三个线程的线程池</span>        ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>thread1<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>thread2<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>thread3<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>题目2：使用2个线程轮流打印数字，一直到20</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//因为创建了2个对象，并且每个对象对应一个线程，因此锁是类级别的</span><span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                String name <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"处理："</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">20</span><span class="token punctuation">)</span>                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FixedThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>thread1<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>thread2<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="单个线程的线程池使用"><a href="#单个线程的线程池使用" class="headerlink" title="单个线程的线程池使用"></a>单个线程的线程池使用</h4><p>题目1：打印1-10这10个数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Caculate</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String name <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"处理："</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建只有一个线程的线程池</span>        ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>thread1<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor线程池Java线程池</title>
      <link href="/2019/03/22/ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/03/22/ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><p>线程池的工作流程大致是：在有任务时，线程池会给该任务分配线程执行，如果当前没有可用线程，一般会将任务放在一个等待队列中，当有线程可用时，再从等待队列中取任务执行。</p><p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt=""></p><p>线程池的引入，主要解决如下问题</p><ul><li><p>减少系统因为频繁创建和销毁线程所带来的开销</p><p>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足问题，如果不适用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过渡切换”的问题。</p></li><li><p>自动管理线程，对使用方透明，提高线程的可管理性</p><p>线程的创建和执行完全分开，方便维护</p></li></ul><h2 id="ThreadPoolExecutor线程池"><a href="#ThreadPoolExecutor线程池" class="headerlink" title="ThreadPoolExecutor线程池"></a>ThreadPoolExecutor线程池</h2><h3 id="理解原理的准备工作"><a href="#理解原理的准备工作" class="headerlink" title="理解原理的准备工作"></a>理解原理的准备工作</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>Executors中三种线程池newFixedThreadPool、newSingleThreadExecutor、newCachedThreadPool的创建都是通过ThreadPoolExecutor创建ExecuteService对象的。</p><p>ThreadPoolExecutor提供了四个构造方法，主要区别是有没有指定线程工厂或者拒绝策略</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用默认线程工厂，默认拒绝策略</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                           <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                           <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                           TimeUnit unit<span class="token punctuation">,</span>                           BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>          Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用指定的线程工厂，默认的拒绝策略</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>         threadFactory<span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用默认的线程工厂，指定的拒绝策略</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>         Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用指定的线程工厂，指定的拒绝策略</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span> keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span>                                        null <span class="token operator">:</span> AccessController<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>参数解释</p><ul><li>corePoolSize：核心线程池中的最大线程数</li><li>maximumPoolSize：总线程池中的最大线程数</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止</li><li>unit：keepAliveTime的单位</li><li>workQueue：任务队列, 保存已经提交但尚未被执行的线程</li><li>threadFactory：线程工厂(用于指定如果创建一个线程)</li><li>handler：拒绝策略 (当任务太多导致工作队列满时的处理策略)</li></ul><blockquote><p>对corePoolSize和maximumPoolSize理解：</p><p>在逻辑上对线程池种的线程分为两部分<strong>核心线程池（大小对应为corePoolSize）</strong>、<strong>非核心线程池（大小对应为maximumPoolSize - corePoolSize）</strong>。</p><p><img src="%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E9%9D%9E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt=""></p><p>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，因此当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p><p>newFixedThreadPool、newSingleThreadExecutor两类线程池的corePoolSize和maximumPoolSize相等，即只有核心线程池。</p><p>newCachedThreadPool线程池的corePoolSize为指定大小，maximumPoolSize为Integer.MAX_VALUE，拥有核心线程池和非核心线程池</p></blockquote><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>线程池有不同的工作状态，ThreadPoolExecutor中定义了5种线程池的状态。</p><ul><li><strong>RUNNING</strong> : 接受新任务, 且处理已经进入阻塞队列的任务</li><li><strong>SHUTDOWN</strong> : 不接受新任务, 但处理已经进入阻塞队列的任务</li><li><strong>STOP</strong> : 不接受新任务, 且不处理已经进入阻塞队列的任务, 同时中断正在运行的任务</li><li><strong>TIDYING</strong> : 所有任务都已终止, 工作线程数为0, 线程转化为TIDYING状态并准备调用terminated方法</li><li><strong>TERMINATED</strong> : 在terminated() 方法执行完后进入该状态</li></ul><p>状态转换</p><p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt=""></p><p>ThreadPoolExecutor通过按位划分的方式，在一个变量ctl中记录线程池状态和工作线程数——<strong>低29位保存线程数，高3位保存池状态</strong>，变量ctl是一个AtomicInteger对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//线程数所占的位数位32-3 = 29</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左移29位再减1</span><span class="token comment" spellcheck="true">//00011111 11111111 11111111 11111111</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分别左移29位</span><span class="token comment" spellcheck="true">//11100000 00000000 00000000 00000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//00000000 00000000 00000000 00000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//00100000 00000000 00000000 00000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//01000000 00000000 00000000 00000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//01100000 00000000 00000000 00000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前线程池状态</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//当前活动线程数</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//获取ctl的值</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h4 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h4><p>工作线程（Worker）是ThreadPoolExecutor内部类，ThreadPoolExecutor通过一个HashSet保存工作线程</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Set containing all worker threads in pool. Accessed only when * holding mainLock. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>线程池中的每一个线程被封装成一个Worker对象，每个工作线程（Worker）都有一个Runnable任务和一个对应的执行线程Thread，Worker类实现了AQS框架，</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Woker实现了AQS框架 * 其同步状态定义如下： * -1：初始状态 * 0：无锁状态 * 1：加锁状态 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//与该Worker关联的线程，用来处理任务的线程</span>    <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用来保存传入的任务</span>    Runnable firstTask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Per-thread task counter */</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始的同步状态值</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//执行任务</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//是否加锁</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//尝试获取锁</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//尝试释放锁</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//中断线程</span>    <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始状态不会执行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h3><h4 id="线程池提交任务"><a href="#线程池提交任务" class="headerlink" title="线程池提交任务"></a>线程池提交任务</h4><p>当在<code>threadPool.submit(thread1);</code>即提交线程语句debug时，会发现程序会先进入AbstractExecutorService的submit()方法，也就是说ThreadPoolExecutor并没有重写submit()方法，而是直接使用了父类AbstractExecutorService的submit()方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>debug到上述submit()方法中<code>execute(ftask);</code>语句时，会跳转到ThreadPoolExecutor类中的execute()方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//case1：工作线程数 &lt; corePoolSize</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//case2：创建工作线程失败或者工作线程数 >= corePoolSize</span>    <span class="token comment" spellcheck="true">//线程池是运行状态时才可以向队列中添加线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//再次检测，如果线程池状态不是运行状态，执行拒绝策略</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果线程池是运行状态，检测是否有工作线程</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//case3：添加到队列失败（队列满了），则尝试创建线程并立即运行</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>addWorker()方法在线程的创建会详细分析，这里需要说明addWorker方法的第二个参数表示是否使用核心线程池，因此整个流程如下：</p><ol><li>case1: 如果工作线程数小于核心线程池上限（CorePoolSize），则直接新建一个工作线程并执行任务；</li><li>case2: 如果工作线程数大于等于CorePoolSize，则尝试将任务加入到队列等待以后执行。</li><li>case3: 如果加入队列失败了（比如队列已满的情况），则在总线程池未满的情况下（<code>CorePoolSize ≤ 工作线程数 ＜ maximumPoolSize</code>）新建一个工作线程立即执行任务，否则执行拒绝策略。</li></ol><p><img src="%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p><blockquote><p>针对case2中<code>addWorker(null, false);</code>说明：</p><p>一般来讲每个工作线程（Worker）都有一个Runnable任务和一个对应的执行线程Thread，当我们调用addWorker方法时，如果不传入相应的任务，那么就只是新建了一个没有任务的工作线程（Worker），该Worker就会从工作队列中取任务来执行（因为自己没有绑定任务）。如果传入了任务，新建的工作线程就会执行该任务。</p><p>这条语句也正是在线程池是运行状态但没有工作线程的情况下执行，也就是队列中有任务等待执行，目前没有运行的线程，则创建一个空任务的线程去队列中取任务执行。</p></blockquote><h4 id="工作线程的创建"><a href="#工作线程的创建" class="headerlink" title="工作线程的创建"></a>工作线程的创建</h4><p>execute方法内部调用了addWorker方法来添加工作线程并执行任务。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 添加工作线程并执行任务 * * @param firstTask 如果指定了该参数, 表示将立即创建一个新工作线程执行该firstTask任务; 否则复用已有的工作线程，从工作队列中获取任务并执行 * @param core 指定使用哪个线程池的线程，true-核心线程池，false-非核心线程池 */</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 该if判断线程池是否接收新任务</span>        <span class="token comment" spellcheck="true">//1.线程池状态是STOP，TIDYING，TERMINATED不接受新任务</span>        <span class="token comment" spellcheck="true">//2.线程池状态是SHUTDOWN，且firstTask！=null，SHUTDOWN状态不接受新任务但处理队列中任务</span>        <span class="token comment" spellcheck="true">//3.线程池状态是SHUTDOWN，firstTask为null，但队列是空的，队列中无任务，不接受新任务</span>        <span class="token comment" spellcheck="true">//因此线程池是running，或者是shutdown状态，firstwork为null，队列不为空才会添加线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//工作线程的数量</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//该if判断工作线程数量是否超出限制</span>            <span class="token comment" spellcheck="true">//1. 工作线程数大于最大的线程数量，返回false</span>            <span class="token comment" spellcheck="true">//2. 当申请核心线程时，工作线程数大于corePoolSize时，返回false</span>            <span class="token comment" spellcheck="true">//3. 当申请非核心线程时，工作线程数大于maximumPoolSize时，返回false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//线程池状态不变，则线程数加一，跳出最外层循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>            <span class="token comment" spellcheck="true">//线程池状态变化，重新自旋判断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将任务和线程包装起来</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新创建的线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//重新检测线程池状态</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//加入工作线程集合</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程添加成功之和，启动线程</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果线程启动不成功，执行回滚操作</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>addworker()方法主要包括两部分</p><ol><li>第一部分是一个自旋操作，主要是对线程池的状态进行一些判断，如果状态不适合接受新任务，或者工作线程数超出了限制，则直接返回false。</li><li>第二部分是创建工作线程并执行任务，先将Runnable任务包装成一个Worker对象，然后加入到一个工作线程集合中（名为workers的HashSet），最后调用工作线程中的Thread对象的start方法执行任务。</li></ol><h4 id="工作线程的执行"><a href="#工作线程的执行" class="headerlink" title="工作线程的执行"></a>工作线程的执行</h4><p>在addWorker中使用Thread的start()方法，最终是委托到Worker的run()方法中</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//执行任务</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后会执行runWorker()方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//执行任务的线程</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//需要执行的任务</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts允许中断</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示是否因为中断而导致推出</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果有任务直接进入while循序</span>        <span class="token comment" spellcheck="true">//如果没有任务则从队列中获取任务</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * 下面这个if判断的作用如下:             * 1.保证当线程池状态为STOP/TIDYING/TERMINATED时，当前执行任务的线程wt是中断状态(因为线程池处于上述任一状态时，均不能再执行新任务)             * 2.保证当线程池状态为RUNNING/SHUTDOWN时，当前执行任务的线程wt不是中断状态             */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//执行任务</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//任务完成数加1</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>runWoker()流程大致如下：</p><ol><li><p>while循环不断地通过<code>getTask()</code>方法从队列中获取任务（如果工作线程自身携带着任务，则执行携带的任务）；</p></li><li><p>控制执行线程的中断状态，保证如果线程池正在停止，则线程必须是中断状态，否则线程必须不是中断状态；</p></li><li><p>调用<code>task.run()</code>执行任务；</p></li><li><p>处理工作线程的退出工作。</p><p>对于工作线程退出，有如下两种情况</p><ul><li>正常情况下，工作线程会存活着，不断从任务队列获取任务执行，如果获取不到任务了（getTask返回null），会置completedAbruptly 为false，然后执行清理工作——processWorkerExit(worker,false)；</li><li>异常情况下，工作线程在执行过程中被中断或出现其它异常，会置completedAbruptly 为true，也会执行清理工作——processWorkerExit(worker,true)；</li></ul></li></ol><p>对于getTask()方法:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Did the last poll() time out?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//线程池状态</span>        <span class="token comment" spellcheck="true">//如果线程池是非running状态</span>        <span class="token comment" spellcheck="true">//1. 当线程池状态是STOP，TIDYING，TERMINATED时工作线程减1，返回</span>        <span class="token comment" spellcheck="true">//2. 当线程池状态时SHUTDOWN，但队列是空时工作线程减1，返回</span>        <span class="token comment" spellcheck="true">//因为线程池状态是STOP，TIDYING，TERMINATED时时，不处理队列中的任务</span>        <span class="token comment" spellcheck="true">//该if就是判断是否还需要执行任务，不需要执行任务返回null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//工作线程数</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Are workers subject to culling?</span>        <span class="token comment" spellcheck="true">// timed变量用于判断是否需要进行超时控制。</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span>        <span class="token comment" spellcheck="true">// wc > corePoolSize为true，表示当前线程池中的线程数量大于核心线程数量；</span>        <span class="token comment" spellcheck="true">// 因此</span>        <span class="token comment" spellcheck="true">//1. 对于非核心线程需要强制进行超时控制，</span>        <span class="token comment" spellcheck="true">//2. 对于非核心线程如果allowCoreThreadTimeOut设置为true，需要进行超时控制</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//该if主要目的是控制线程的数量</span>        <span class="token comment" spellcheck="true">//当以下两个条件为true时，不再执行任务，返回null</span>        <span class="token comment" spellcheck="true">//1. 当前线程数量大于最大线程数，或者设置了线程超时控制，上次取任务时发生超时</span>        <span class="token comment" spellcheck="true">//2. 当前线程数大于1或者任务队列为空</span>        <span class="token comment" spellcheck="true">//对该判断有4种组合</span>        <span class="token comment" spellcheck="true">//如果超过最大线程数，并且线程数量大于1，回收线程</span>        <span class="token comment" spellcheck="true">//如果超过最大线程数，线程数量等于1，但队列为空，回收线程</span>        <span class="token comment" spellcheck="true">//如果没有超过最大线程数，但超时，并且线程数量大于1，回收线程</span>        <span class="token comment" spellcheck="true">//如果没有超过最大线程数，但超时，线程数量等于1，但队列为空，回收线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//根据timed来判断</span>            <span class="token comment" spellcheck="true">//如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span>            <span class="token comment" spellcheck="true">//如果为false，通过take方法在队列种取任务</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>            workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//没有获取到任务，设置超时</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>getTask方法中的第二个if判断解释：</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//该if主要目的是控制线程的数量</span> <span class="token comment" spellcheck="true">//当以下两个条件为true时，不再执行任务，返回null</span> <span class="token comment" spellcheck="true">//1. 当前线程数量大于最大线程数，或者设置了线程超时控制，上次取任务时发生超时</span> <span class="token comment" spellcheck="true">//2. 当前线程数大于1或者任务队列为空</span> <span class="token comment" spellcheck="true">//对该判断有4种组合</span> <span class="token comment" spellcheck="true">//如果超过最大线程数，并且线程数量大于1</span> <span class="token comment" spellcheck="true">//如果超过最大线程数，线程数量等于1，但队列为空</span> <span class="token comment" spellcheck="true">//如果没有超过最大线程数，但超时，并且线程数量大于1</span> <span class="token comment" spellcheck="true">//如果没有超过最大线程数，但超时，线程数量等于1，但队列为空</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> null<span class="token punctuation">;</span>     <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>针对超时情况说明（可缓冲线程池）：</code></pre><ol><li>在execute()的case3：如果加入队列失败了（比如队列已满的情况），则在总线程池未满的情况下（<code>CorePoolSize ≤ 工作线程数 ＜ maximumPoolSize</code>）新建一个工作线程立即执行任务，否则执行拒绝策略。</li><li>当该非核心线程执行完分配的任务后，该线程会去队列中取任务</li><li>如果该线程取任务超时，则需要被清理掉（可能工作队列已经是空了，不需要那么多线程了）</li></ol></blockquote><h4 id="工作线程的清理"><a href="#工作线程的清理" class="headerlink" title="工作线程的清理"></a>工作线程的清理</h4><p>在工作线程时，有两种情况线程会退出执行，然后进入线程清理。</p><ul><li>正常情况下，工作线程会存活着，不断从任务队列获取任务执行，如果获取不到任务了（getTask返回null），会置completedAbruptly 为false，然后执行清理工作——processWorkerExit(worker,false)；</li><li>异常情况下，工作线程在执行过程中被中断或出现其它异常，会置completedAbruptly 为true，也会执行清理工作——processWorkerExit(worker,true)；</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//工作线程因异常情况而退出，工作线程减1</span>    <span class="token comment" spellcheck="true">//非异常情况下，如果是非核心线程或者是核心线程也设置了超时，在getTask()方法中工作线程已经减1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span>         <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//completedTaskCount记录线程池完成的总任务数</span>        completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从工作线程集合中移除</span>        workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//根据线程池状态, 判断是否需要终止线程池</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果线程池状态是RUNNING或者SHUTDOWN</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//正常退出</span>            <span class="token comment" spellcheck="true">//判断核心线程是否设置了超时控制</span>            <span class="token comment" spellcheck="true">//如果核心线程设置了超时控制，现在线程池线程数量应该为0</span>            <span class="token comment" spellcheck="true">//如果核心线程没有设置超时控制，现在的线程池线程数量应该为corePoolSize</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果队列中还有任务，但已经没有工作线程了，需要重启一个任务为空的工作线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">>=</span> min<span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// replacement not needed</span>        <span class="token punctuation">}</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>在线程池提交任务模块分析了何时会执行拒绝策略</p><ul><li><p>case2：提交任务时，ThreadPoolExecutor已经关闭了，执行拒绝策略；</p></li><li><p>case3：当核心线程池满了以后，如果任务队列也满了，首先判断非核心线程池有没满，没有满就创建一个工作线程（归属非核心线程池）， 否则就会执行拒绝策略。</p></li></ul><p>线程池的拒绝策略是调用RejectedExecutionHandler对象的rejectedExecution()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ThreadPoolExecutor一共提供了四种拒绝策略，四种方法都是ThreadPoolExecutor的内部类</p><ol><li><p>CallerRunsPolicy</p><p>CallerRunsPolicy策略相当于以自身线程来执行任务，这样可以减缓新任务提交的速度。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallerRunsPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Executes task r in the caller's thread, unless the executor     * has been shut down, in which case the task is discarded.     *     * @param r the runnable task requested to be executed     * @param e the executor attempting to execute this task     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//线程池未关闭</span>            r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>AbortPolicy（默认）</p><p>AbortPolicy策略就是抛出一个RejectedExecutionException异常</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AbortPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Always throws RejectedExecutionException.     *     * @param r the runnable task requested to be executed     * @param e the executor attempting to execute this task     * @throws RejectedExecutionException always     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">"Task "</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                                             <span class="token string">" rejected from "</span> <span class="token operator">+</span>                                             e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>DiscardPolicy</p><p>什么都不做</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Does nothing, which has the effect of discarding task r.     *     * @param r the runnable task requested to be executed     * @param e the executor attempting to execute this task     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>DiscardOldestPolicy</p><p>DiscardOldestPolicy策略是丢弃任务队列中的最近一个任务，并执行当前任务：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardOldestPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">DiscardOldestPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Obtains and ignores the next task that the executor     * would otherwise execute, if one is immediately available,     * and then retries execution of task r, unless the executor     * is shut down, in which case task r is instead discarded.     *     * @param r the runnable task requested to be executed     * @param e the executor attempting to execute this task     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队列弹出</span>            e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h4><p>从线程池使用subtmit()方法提交任务开始，一直到processWorkerExit()任务结束，大体流程如下：</p><p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt=""></p><h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>ThreadPoolExecutor提供了两种方法关闭线程池，这两种方法的区别主要在于是否继续处理已经添加到任务队列中的任务。</p><ul><li><p>shutdown()方法可以使线程池从running状态转为shutdown状态</p></li><li><p>shutdownNow()方法可以使线程池从running状态转为stop状态</p></li></ul><p><strong>shutdown</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果线程池为RUNNING状态, 则切换为SHUTDOWN状态</span>        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//// 中断所有空闲线程</span>        <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hook for ScheduledThreadPoolExecutor</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//尝试关闭线程池</span><span class="token punctuation">}</span></code></pre><p><strong>shutdownNow</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> tasks<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>STOP<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果线程池为RUNNING或SHUTDOWN状态, 则切换为STOP状态</span>        <span class="token function">interruptWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 中断所有工作线程</span>        tasks <span class="token operator">=</span> <span class="token function">drainQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 抽空任务队列中的所有任务</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//尝试关闭线程池</span>    <span class="token keyword">return</span> tasks<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引原理</title>
      <link href="/2019/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
      <url>/2019/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Mysql中B-树特点"><a href="#Mysql中B-树特点" class="headerlink" title="Mysql中B+树特点"></a>Mysql中B+树特点</h3><ul><li>内部节点只用作索引，不存放数据</li><li>所有的叶子节点都在同一层</li><li>叶子节点存放指针（非聚簇索引，存放的是指向数据的指针）或者存放数据（聚簇索引，叶子节点存放数据）</li><li>相邻的叶子节点之间相互连接，遍历查询时，只需要定位到第一个数据的位置即可向后直接遍历查询</li></ul><h3 id="Mysql索引实现"><a href="#Mysql索引实现" class="headerlink" title="Mysql索引实现"></a>Mysql索引实现</h3><h4 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p>InnoDB存储引擎表是索引组织表，即<strong>表中数据按照主键顺序存放</strong>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h5><p>聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。</p><p>聚集索引的存放并不是物理上连续的，而是逻辑上连续。其中页通过双向链表链接，页按照主键的顺序排序，每个页中的记录也是通过双向链表维护。</p><p><img src="InnoDB%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt=""></p><h5 id="非聚集索引-辅助索引"><a href="#非聚集索引-辅助索引" class="headerlink" title="非聚集索引(辅助索引)"></a>非聚集索引(辅助索引)</h5><p>对于辅助索引（Secondary　Index），叶子节点并不包含行记录全部数据，叶子节点除了包含索引键值以外，每个叶子节点中的索引行还包含一个书签（bookmark），该书签即该行数据的聚集索引键，即书签中记录着该行数据主键的值</p><p><img src="InnoDB%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png" alt=""></p><h4 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h4><p>MyISAM索引使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。</p><p>并且其主索引（Primary key）与辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p><p>例如下图中，Col1是主键，则该图为主索引的示意图，MyISAM的索引仅仅保存数据记录的地址。</p><p><img src="MyISAM%E4%B8%BB%E7%B4%A2%E5%BC%95.png" alt=""></p><p>下图中，Col2不是主键，则该图为辅助索引的示意图，索引的叶子节点中保存的也是数据记录的地址。</p><p><img src="MyISAM%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png" alt=""></p><h3 id="索引使用原则"><a href="#索引使用原则" class="headerlink" title="索引使用原则"></a>索引使用原则</h3><p>索引选择性使用</p><ol><li>对于单列索引，当存在多个单列索引可以用时，mysql会根据查询优化策略选择其中一个单列索引，并不是每个单列索引都生效。</li><li>当同时存在单列索引和联合索引，mysql会根据查询优化策略选择其中一个索引。</li><li>对where后面的or操作，如果没一项都建立了索引，则使用索引，有任一一项没有索引，则不使用索引。</li></ol><p>索引使用的规则</p><ol><li>索引列不能参与计算，不能参与转换，比如建立了age索引，<code>age + 10 = 30</code>不会使用到索引或者建立了time索引，则<code>from_unixtime(time) = ’2014-05-29’</code>不会使用到索引。</li><li>联合索引最左匹配原则，比如建立<code>(a,b,c)</code>索引，可以理解为建立了<code>(a),(a,b),(a,b,c)</code>三个索引，因此当执行<code>where a=10 and c=20</code>时索引不可用。</li><li>=和in可以乱序，比如建立(a,b,c)索引，执行<code>where a=10 and b=20</code>和<code>where b=20 and a=10</code>都会使用到索引。</li></ol><p>不会使用索引的情况</p><ol><li>索引列参与了计算或者转换</li><li>联合索引不满足最左匹配原则</li><li>单列索引时使用范围查询（&gt;，&lt;，between，like）使用索引；联合索引即使满足最左匹配原则，范围查询之后的索引失效，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>如果建立<code>(a,b,c,d)</code>顺序的索引，d是用不到索引的，如果建立<code>(a,b,d,c)</code>的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>like语句，<code>name LIKE &#39;小%&#39;</code>使用索引，<code>name LIKE &#39;%明%&#39;</code>不使用索引 </li><li>is null和is not null不适用索引，其他情况下null使用索引，不建议列上为空，可以设置一个默认值</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><p><a href="https://houbb.github.io/2019/01/02/combine-index" target="_blank" rel="noopener">https://houbb.github.io/2019/01/02/combine-index</a></p><p><a href="https://blog.csdn.net/Abysscarry/article/details/80792876" target="_blank" rel="noopener">https://blog.csdn.net/Abysscarry/article/details/80792876</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql技术内幕阅读笔记(二)</title>
      <link href="/2019/03/08/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
      <url>/2019/03/08/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB存储引擎有多个内存块，负责如下工作</p><ul><li>维护所有进程/线程需要访问的多个内部数据结构</li><li>缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件的数据修改之前在这里缓存。</li><li>重做日志(redo log)缓冲</li></ul><p><img src="InnoDB%E6%9E%B6%E6%9E%84.png" alt=""></p><p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。并将已修改的数据文件刷新到磁盘文件，同时保证数据库发生异常的情况下InnoDB能恢复到正常运行状态。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><ol><li><p>Master Thread</p><p>主要负责将缓存池中数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓存，undo页的回收等。</p></li><li><p>IO Thread</p><p>InnoDB存储引擎大量使用了AIO（Async IO）来处理IO请求，IO Thread的工作主要负责这些IO请求的回调处理。</p><p>从InnoDB1.0版本开始，各IO Thread数量如下</p><ul><li>wrtie thread：4个</li><li>read thread：4个</li><li>insert buffer thread：1个</li><li>log IO：1个</li></ul><pre class=" language-mysql"><code class="language-mysql"># INNODB版本查询SHOW VARIABLES LIKE 'INNODB_VERSION'\G;# INNODB THREAD 数量查询SHOW VARIABLES LIKE 'innodb_%io_threads'\G;# 查询IO THREADSHOW ENGINE INNODB STATUS\G；</code></pre><p>读线程ID总是小于写线程ID</p></li><li><p>purge Thread</p><p>事务被提交之后，其所使用的undolog可能不再需要，因此需要使用purgeThread回收已经使用并分配的undo页，老版本中purge操作仅在Master Thread完成，InnoDB1.1之后，purge操作可以独立到单独线程中进行，一以此来减轻Mater Thread的工作，从而提高CPU的使用率以及提升存储引擎的性能。</p><pre><code>在配置文件中开启独立的purge Thread[mysqld]innodb_purge_threads=1 #InnoBD1.2版本之后可以设置大于1</code></pre></li><li><p>Page Cleaner Thread</p><p>完成脏页的刷新操作（之前是在Master Thread完成），减轻Master Thread的工作及对于用户查询线程的阻塞</p></li></ol><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ol><li><p>缓冲池</p><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。为了解决磁盘与内存速度不匹配问题，使用缓冲池提高数据库的整体性能。</p><ul><li>读取操作：在数据库中进行读取页操作时，首先将磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中，下一次读取相同的页时，首先判断页是否在缓冲池中，如果在，则该页在缓冲池被命中，可以直接读取，如果不再缓冲池中，需要从磁盘上读取。</li><li>修改操作：首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新到磁盘的操作并不是在每次页发生更新时触发，而是通过checkPoint机制刷新回磁盘</li></ul><p>缓冲池中缓存的数据页类型有：<strong>索引页，数据页，undo页，插入缓冲（insert buffer），自适应哈希索引，InnoDB存储的锁信息，数据字典信息</strong></p><p><img src="IoonDB%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" alt=""></p><p>InnoDB1.0版本开始，允许多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。</p></li><li><p>LRU List ，Free List，Flush List</p><p>LRU List</p><p>数据库的缓冲池是通过LRU（Latest Recent Used，最近最少使用）算法进行管理。即最频繁使用的页放在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读到的页时，将首先释放LRU列表中尾端的页。</p><p>InnoDB存储引擎中，将LRU算法进行了改进，会将新读到的页放在midpoint位置，而不是直接放在LRU列表的首部，midpoint之后的列表称为old表，之前的列表称为new表。这是为了防止在进行索引和数据的扫描操作时，需要访问很多的页，而且这些页仅在该次操作中使用，并不是活跃的热点数据，如果将新读的页放在首部，在扫描操作中很可能会将热点数据刷新出去，因此放在midpoint处，等过了设置的放置时间（innodb_old_blocks_time）后，再将表加到LRU列表的热端。</p><p><img src="LRU%E5%88%97%E8%A1%A8.png" alt=""></p><ul><li>页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young</li><li>因为<code>innodb_old_blocks_time</code>的设置而导致页没有从old部分移动到new部分的操作称为page not made young。</li></ul><p>Free List</p><p>当数据库刚启动时，LRU列表是空的，这是所有的页都存放在Free列表中。当需要从缓冲池分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。</p><p>INNODB存储引擎从1.0.X版本开始支持压缩页的功能，即将原来16KB的页压缩为1KB、2KB、4KB和8KB。由于页的大小发生了变化，所以LRU列表也有了些许的变化，对于非16KB的页，是通过unzip_LRU列表进行管理的。</p><ul><li>首先，在unzip_LRU列表中对不同压缩页大小的页进行分别管理</li><li>其次通过伙伴算法进行内存的分配。如对需要从缓冲池中申请页为4KB的大小的过程如下<ul><li>检查4KB的unzip_LRU的列表，检查是否有可用的空闲页；</li><li>若有，则直接使用</li><li>否则，检查8KB的unzip_LRU列表</li><li>若能够得到空闲页，将页分成2个4KB的页，存放到4KB的unzip_LRU列表汇总；</li><li>若不能得到空闲页，从LRU列表中申请一个16KB的页，分为1个8K的页还有2个4KB的页，分别存放到对应的unzip_LRU列表中。</li></ul></li></ul><p>Flush List</p><p>在LRU列表中的页被修改后，该页成为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过CHECKPOINT机制将脏页刷新会磁盘。</p><p> Flush列表中的页即为脏页列表。</p><p> 脏页既存在于LRU列表中，也存在与Flush列表中。LRU列表用来管理缓冲池中的页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。</p></li><li><p>重做日志缓存</p><p>InnoDB存储引擎首先将重做日志信息放在这个缓冲区中，然后按照一定的频率刷新到重做日志文件。</p><p>刷新到磁盘的策略</p><ul><li>MASTER THREAD每一秒将重做日志缓冲刷新到重做日志文件中</li><li>每个事务提交时会将重做日志缓冲刷新到重做日志文件中</li><li>当重做日志缓冲池剩余空间小于一半时，重做日志缓冲刷新到重做日志文件中。</li></ul></li></ol><h3 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h3><p>一条DML语句会使得产生脏页（内存的数据比磁盘新），那就需要刷新到磁盘中。基本上是采用<code>Write Ahead Log</code>策略。即当事务提交时，先写重做日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。</p><p> 而Checkpoint技术是为了解决这个过程的痛点：</p><ul><li><p>缩短数据库恢复的时间</p><p> 由于checkpoint之前的数据都刷回去磁盘了，所以只需要对checkpoint后的重做日志进行恢复。大大缩短了恢复时间。</p></li><li><p>缓冲池不够用时，将脏页刷新到磁盘</p><p> LRU算法会溢出最近最少使用的页，如果是脏页，强制Checkpoint。</p></li><li><p>重做日志不可用时，刷新脏页。</p><p> 重做日志的空间是循环使用的，当要被重用的时候，被重用的部分必须进行checkpoint。</p></li></ul><p>在InnoDB存储引擎内部，有两种Checkpoint，分别为：</p><ul><li><p>Sharp Checkpoint</p><p> 是在数据库关闭时刷新全部脏页到磁盘。这是默认的工作方式，参数是<code>innodb_fast_shutdown=1</code></p></li><li><p>Fuzzy Checkpoint</p><p> 运行时使用，指刷新一部分脏页。</p><ul><li><p><code>Master Thread Checkpoint</code></p><p> 每秒或者每十秒刷新从缓冲池的脏页列表中刷新一定比例的页回磁盘。</p></li><li><p><code>FLUSH_LRU_LIST Checkpoint</code></p><p> 因为InnoDB存储引擎需要保障LRU列表中需要有足够多的空闲页可使用。</p><p> 在InnoDB 1.1.x版本之前，检查LRU列表中是否有足够空间操作发生在用户查询线程中，而且如果查询空间不足，会将尾端的页移除，如果有脏页就进行Checkpoint。</p><p> 在InnoDB1.2.x版本开始，这个操作会放在Page Cleaner 线程中进行。</p><p> 可以通过参数进行设置预留的空间大小，设置LRU列表需要保留多少个空闲页的空间</p><pre><code>SHOW VARIABLES LIKE &#39;innodb_lru_sacn_depth&#39;\G;</code></pre></li><li><p><code>Async/Sync Flush Checkpoint</code></p><p> 是指重做日志文件不可用（空间快用完了）的情况，这时需要强制将一些页刷新会磁盘，而此时脏页是从脏页列表中选取的。</p></li><li><p>Dirty Page too much Checkpoint</p><p> 脏页的数量太多，导致InnoDB强制进行CheckPoint。可以由参数来配置，表示缓冲中脏页的数量占据百分比为多少后，进行脏页的刷新。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql技术内幕阅读笔记(一)</title>
      <link href="/2019/03/07/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
      <url>/2019/03/07/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql体系结构和存储引擎"><a href="#Mysql体系结构和存储引擎" class="headerlink" title="Mysql体系结构和存储引擎"></a>Mysql体系结构和存储引擎</h2><h3 id="数据库与实例"><a href="#数据库与实例" class="headerlink" title="数据库与实例"></a>数据库与实例</h3><ul><li>数据库：数据库是文件的集合，是依照某种数据模型组织起来并存放于存储器中的数据集合</li><li>实例：数据库实例是程序，是位于用户和操作系统之间的一层数据管理软件，用户对数据库中的数据做任何的操作，包括数据定义、数据查询、数据维护、数据库运行控制等等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。</li></ul><p>Mysql是一个单进程多线程的应用，Mysql实例在系统上表现就是一个进程。</p><p>数据库是一个个文件组成的，要对这些文件执行诸如select，insert，updata，delete之类的数据库操作是不能简单通过操作文件来更改数据库的内容，需要通过数据库实例来完成对数据库的操作。</p><h3 id="Mysql体系结构"><a href="#Mysql体系结构" class="headerlink" title="Mysql体系结构"></a>Mysql体系结构</h3><p><img src="Mysql%E6%9E%B6%E6%9E%84.png" alt=""></p><p>Mysql由以下几个部分组成</p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲组件</li><li>插件式储存引擎</li><li>物理文件</li></ul><h3 id="Mysql存储引擎"><a href="#Mysql存储引擎" class="headerlink" title="Mysql存储引擎"></a>Mysql存储引擎</h3><p>存储引擎是基于表的，而不是数据库</p><p>存储引擎的好处就是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表，下面简介两个存储引擎</p><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>InnoDB存储引擎支持事务，其设计目标主要是面向在线事务处理（OLTP）的应用，是Mysql默认的存储引擎</p><ul><li>行锁设计</li><li>支持外键</li><li>非锁定读，即默认读取操作不会产生锁</li></ul><p>InnoDB通过使用多版本并发控制(MVCC)来获得高并发性，其实现了SQL标准的四种隔离级别，默认为REPEATABLE级别，它使用一种被称为next-keylocking的策略来避免幻读现象的产生。InnoDB还提供插入缓冲、二次写、自适应哈希索引、预读等高性能和高可用功能。</p><p>表中数据采用聚集的方式存放，因此每场表的储存都是按主键的顺序进行存放，如果没有显式指定主键，则会为每一行生成一个6字节的ROWID，并作为主键。</p><h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><p>MyISAM主要面向一些OLAP数据库应用。</p><ul><li>不支持事务</li><li>表锁设计</li><li>支持全文索引</li></ul><p>MyISAM引擎的缓冲池只缓存索引文件，而不缓冲数据文件，MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase客户端API</title>
      <link href="/2019/02/23/Hbase%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/"/>
      <url>/2019/02/23/Hbase%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/</url>
      
        <content type="html"><![CDATA[<h2 id="客户端API"><a href="#客户端API" class="headerlink" title="客户端API"></a>客户端API</h2><p>java客户端向Hbase服务端发起请求的使用流程</p><ol><li>构建一个 Configuration实例，该实例包含了一些客户端配置项，最重要的必需的两个配置项是 HBase 集群的 ZooKeeper 地址与端口。 </li><li>ConnectionFactory 根据 Configuration 实例创建一个 Connection 对象， 该 Connection 对象线程安全，封装了连接到一个 HBase 集群所需要的所有信息，如元数据缓存、客户端与 HMaster 和 HRegionServer 的连接等。由于创建 Connection 开销较大， 类似于关系型数据库的连接池，因此实际使用中会将该 Connection 缓存起来重复使用。 </li><li>从 Connection 获取需要操作的 Table 的实例，该 Table 实例非线程安全。因为获取 Table 是一个轻量级操作， 所以每次请求都需要获取一个新的 Table 实例。 </li><li>根据所需要做的操作类型调用 Table 实例的不同方法， Get 方法可以直接得到结果，Scan 操作可以得到一个 ResultScanner 游标，调用 ResultScanner.next 可以遍历Scan结果。 </li><li>从 Connection 也可以获取一个 Admin 实例，可以用来创建表、删除表、 触发分区压缩、触发分区拆分、管理镜像和管理分区等操作。 </li></ol><p><img src="%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png" alt=""></p><p>获取连接</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Connection connection <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TABLENAME <span class="token operator">=</span> <span class="token string">"AttackLog"</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TABLEFAMILLY <span class="token operator">=</span> <span class="token string">"AttackInformation"</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String COLUMN1<span class="token operator">=</span><span class="token string">"IP"</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String COLUMN2<span class="token operator">=</span><span class="token string">"Paylod"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建连接</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//设置属性</span>    Configuration configuration <span class="token operator">=</span> HBaseConfiguration<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    configuration<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"hbase.zookeeper.quorum"</span><span class="token punctuation">,</span> <span class="token string">"master"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    configuration<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"hbase.zookeeper.property.clientPort"</span><span class="token punctuation">,</span> <span class="token string">"2181"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建连接</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        connection <span class="token operator">=</span> ConnectionFactory<span class="token punctuation">.</span><span class="token function">createConnection</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="数据定义语言"><a href="#数据定义语言" class="headerlink" title="数据定义语言"></a>数据定义语言</h2><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>表名：AttackLog，列族：AttackInformation</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建表</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">createTable</span><span class="token punctuation">(</span>String tableName<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> familyNames<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Admin admin <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getAdmin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>admin<span class="token punctuation">.</span><span class="token function">tableExists</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//通过HTableDescriptor类描述一个表，HColumnDescriptor描述一个列族</span>    HTableDescriptor tableDescriptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTableDescriptor</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String familyName <span class="token operator">:</span> familyNames<span class="token punctuation">)</span><span class="token punctuation">{</span>        HColumnDescriptor family <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HColumnDescriptor</span><span class="token punctuation">(</span>familyName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置行键的编码格式</span>        family<span class="token punctuation">.</span><span class="token function">setDataBlockEncoding</span><span class="token punctuation">(</span>DataBlockEncoding<span class="token punctuation">.</span>PREFIX<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置数据保留多版本</span>        family<span class="token punctuation">.</span><span class="token function">setMaxVersions</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tableDescriptor<span class="token punctuation">.</span><span class="token function">addFamily</span><span class="token punctuation">(</span>family<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    admin<span class="token punctuation">.</span><span class="token function">createTable</span><span class="token punctuation">(</span>tableDescriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//删除表</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">deleteTable</span><span class="token punctuation">(</span>String tableName<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Admin admin <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getAdmin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>admin<span class="token punctuation">.</span><span class="token function">tableExists</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除之前将表禁用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>admin<span class="token punctuation">.</span><span class="token function">isTableDisabled</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        admin<span class="token punctuation">.</span><span class="token function">disableTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    admin<span class="token punctuation">.</span><span class="token function">deleteTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="数据操作语言"><a href="#数据操作语言" class="headerlink" title="数据操作语言"></a>数据操作语言</h2><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//添加数据</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">putData</span><span class="token punctuation">(</span>String rowkey<span class="token punctuation">,</span>String IP<span class="token punctuation">,</span>String payload<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Table table <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>TABLENAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Put put <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Put</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//向put对象种组装数据</span>    put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>TABLEFAMILLY<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>COLUMN1<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>IP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>TABLEFAMILLY<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>COLUMN2<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//向表中插入数据</span>    table<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>put<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"插入"</span><span class="token operator">+</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">;</span>    table<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//get操作</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getData</span><span class="token punctuation">(</span>String rowkey<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Table table <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>TABLENAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//新建get对象</span>    Get get <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Get</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 显示所有版本</span>    <span class="token comment" spellcheck="true">// get.setMaxVersions();</span>    <span class="token comment" spellcheck="true">// 显示指定版本</span>    <span class="token comment" spellcheck="true">// get.setMaxVersions(maxVersions);</span>    <span class="token comment" spellcheck="true">// 显示指定时间戳的版本</span>    <span class="token comment" spellcheck="true">// get.setTimeStamp(timeStamp);</span>    Result result <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>    Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> cells <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">rawCells</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Cell cell <span class="token operator">:</span> cells<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>            <span class="token string">"行键:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getRow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">+</span> <span class="token string">" 列族："</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneFamily</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">+</span> <span class="token string">" 列:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneQualifier</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">+</span> <span class="token string">" 值:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneValue</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    table<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="scan操作"><a href="#scan操作" class="headerlink" title="scan操作"></a>scan操作</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//scan操作</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scanData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Table table <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>TABLENAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构建扫描器，指定扫描的起始行和结束行，不指定的话，表示扫描全表，还可以指定其他限定</span>    Scan scan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// scan.setStartRow(startRow);</span>    <span class="token comment" spellcheck="true">// scan.setStopRow(stopRow);</span>    <span class="token comment" spellcheck="true">//执行全表扫描</span>    ResultScanner results <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">getScanner</span><span class="token punctuation">(</span>scan<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Result result <span class="token operator">:</span> results<span class="token punctuation">)</span><span class="token punctuation">{</span>        Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> cells <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">rawCells</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Cell cell <span class="token operator">:</span> cells<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                <span class="token string">"行键:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getRow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">" 列族："</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneFamily</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">" 列:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneQualifier</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">" 值:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneValue</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    table<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="delete操作"><a href="#delete操作" class="headerlink" title="delete操作"></a>delete操作</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//删除数据</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteData</span><span class="token punctuation">(</span>String rowkey<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Table table <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>TABLENAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建delete对象</span>    Delete delete <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Delete</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//向delete对象组装数据，如果不组装数据则删除的行键的数据</span>    <span class="token comment" spellcheck="true">//删除最先版本的数据，保留旧版本</span>    <span class="token comment" spellcheck="true">//delete.addColumn(Bytes.toBytes(TABLEFAMILLY),Bytes.toBytes(COLUMN1));</span>    <span class="token comment" spellcheck="true">//删除全部版本的数据</span>    delete<span class="token punctuation">.</span><span class="token function">addColumns</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>TABLEFAMILLY<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>COLUMN1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    delete<span class="token punctuation">.</span><span class="token function">addColumns</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>TABLEFAMILLY<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>COLUMN2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>delete<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除"</span><span class="token operator">+</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">;</span>    table<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>HbaseDemo.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>client<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>io<span class="token punctuation">.</span>encoding<span class="token punctuation">.</span>DataBlockEncoding<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Bytes<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HbaseDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Connection connection <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TABLENAME <span class="token operator">=</span> <span class="token string">"AttackLog"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TABLEFAMILLY <span class="token operator">=</span> <span class="token string">"AttackInformation"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String COLUMN1<span class="token operator">=</span><span class="token string">"IP"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String COLUMN2<span class="token operator">=</span><span class="token string">"Paylod"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建连接</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//设置属性</span>        Configuration configuration <span class="token operator">=</span> HBaseConfiguration<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configuration<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"hbase.zookeeper.quorum"</span><span class="token punctuation">,</span> <span class="token string">"master"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configuration<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"hbase.zookeeper.property.clientPort"</span><span class="token punctuation">,</span> <span class="token string">"2181"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            connection <span class="token operator">=</span> ConnectionFactory<span class="token punctuation">.</span><span class="token function">createConnection</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建表</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">createTable</span><span class="token punctuation">(</span>String tableName<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> familyNames<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Admin admin <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getAdmin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>admin<span class="token punctuation">.</span><span class="token function">tableExists</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//通过HTableDescriptor类描述一个表，HColumnDescriptor描述一个列族</span>        HTableDescriptor tableDescriptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTableDescriptor</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String familyName <span class="token operator">:</span> familyNames<span class="token punctuation">)</span><span class="token punctuation">{</span>            HColumnDescriptor family <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HColumnDescriptor</span><span class="token punctuation">(</span>familyName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置行键的编码格式</span>            family<span class="token punctuation">.</span><span class="token function">setDataBlockEncoding</span><span class="token punctuation">(</span>DataBlockEncoding<span class="token punctuation">.</span>PREFIX<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置数据保留多版本</span>            family<span class="token punctuation">.</span><span class="token function">setMaxVersions</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tableDescriptor<span class="token punctuation">.</span><span class="token function">addFamily</span><span class="token punctuation">(</span>family<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        admin<span class="token punctuation">.</span><span class="token function">createTable</span><span class="token punctuation">(</span>tableDescriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除表</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">deleteTable</span><span class="token punctuation">(</span>String tableName<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Admin admin <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getAdmin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>admin<span class="token punctuation">.</span><span class="token function">tableExists</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//删除之前将表禁用</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>admin<span class="token punctuation">.</span><span class="token function">isTableDisabled</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            admin<span class="token punctuation">.</span><span class="token function">disableTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        admin<span class="token punctuation">.</span><span class="token function">deleteTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//添加数据</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">putData</span><span class="token punctuation">(</span>String rowkey<span class="token punctuation">,</span>String IP<span class="token punctuation">,</span>String payload<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Table table <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>TABLENAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Put put <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Put</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向put对象种组装数据</span>        put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>TABLEFAMILLY<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>COLUMN1<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>IP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>TABLEFAMILLY<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>COLUMN2<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向表中插入数据</span>        table<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>put<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"插入"</span><span class="token operator">+</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">;</span>        table<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除数据</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteData</span><span class="token punctuation">(</span>String rowkey<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Table table <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>TABLENAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建delete对象</span>        Delete delete <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Delete</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向delete对象组装数据，如果不组装数据则删除的行键的数据</span>        <span class="token comment" spellcheck="true">//删除最先版本的数据，保留旧版本</span>        <span class="token comment" spellcheck="true">//delete.addColumn(Bytes.toBytes(TABLEFAMILLY),Bytes.toBytes(COLUMN1));</span>        <span class="token comment" spellcheck="true">//删除全部版本的数据</span>        delete<span class="token punctuation">.</span><span class="token function">addColumns</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>TABLEFAMILLY<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>COLUMN1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        delete<span class="token punctuation">.</span><span class="token function">addColumns</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>TABLEFAMILLY<span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>COLUMN2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        table<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>delete<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除"</span><span class="token operator">+</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">;</span>        table<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//scan操作</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scanData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Table table <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>TABLENAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 构建扫描器，指定扫描的起始行和结束行，不指定的话，表示扫描全表，还可以指定其他限定</span>        Scan scan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// scan.setStartRow(startRow);</span>        <span class="token comment" spellcheck="true">// scan.setStopRow(stopRow);</span>        <span class="token comment" spellcheck="true">//执行全表扫描</span>        ResultScanner results <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">getScanner</span><span class="token punctuation">(</span>scan<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Result result <span class="token operator">:</span> results<span class="token punctuation">)</span><span class="token punctuation">{</span>            Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> cells <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">rawCells</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Cell cell <span class="token operator">:</span> cells<span class="token punctuation">)</span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                        <span class="token string">"行键:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getRow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token operator">+</span> <span class="token string">" 列族："</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneFamily</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token operator">+</span> <span class="token string">" 列:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneQualifier</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token operator">+</span> <span class="token string">" 值:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneValue</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        table<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//get操作</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getData</span><span class="token punctuation">(</span>String rowkey<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Table table <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getTable</span><span class="token punctuation">(</span>TableName<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>TABLENAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//新建get对象</span>        Get get <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Get</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>rowkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 显示所有版本</span>        <span class="token comment" spellcheck="true">// get.setMaxVersions();</span>        <span class="token comment" spellcheck="true">// 显示指定版本</span>        <span class="token comment" spellcheck="true">// get.setMaxVersions(maxVersions);</span>        <span class="token comment" spellcheck="true">// 显示指定时间戳的版本</span>        <span class="token comment" spellcheck="true">// get.setTimeStamp(timeStamp);</span>        Result result <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>        Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> cells <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">rawCells</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Cell cell <span class="token operator">:</span> cells<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                    <span class="token string">"行键:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getRow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">" 列族："</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneFamily</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">" 列:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneQualifier</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">" 值:"</span> <span class="token operator">+</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneValue</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        table<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        HbaseDemo<span class="token punctuation">.</span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HbaseDemo hbaseDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HbaseDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hbaseDemo<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">"sql_1583306678344"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>pom.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.Hbase<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>HbaseTest<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repositories</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repository</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>apache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://maven.apache.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repository</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repositories</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.hbase<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hbase-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务隔离级别</title>
      <link href="/2019/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2019/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是并发控制的基本单位，所谓事务，它是一个操作序列，这个操作要么都执行，要么都不执行，它是一个不可分割的工作单位，需要满足ACID原则。</p><ul><li>一致性：在事务开始之前和事务结束之后，数据库的完整性没有被破坏。</li><li>原子性：一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务没有执行过一样。即，事务不可分割，不可简约。</li><li>隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</li><li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>对一致性的解释，以银行转钱为例：</p><pre><code>数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。假设A有200，B有200，现在A给B转100，不论事务成功还是失败，应该保证事务结束后，A和B得总金额为400元。</code></pre><h2 id="并发事务会产生的问题"><a href="#并发事务会产生的问题" class="headerlink" title="并发事务会产生的问题"></a>并发事务会产生的问题</h2><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p><strong>A事务撤销时，把已经提交的B事务的更新数据覆盖了</strong></p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center">查询余额为100元</td><td align="center"></td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>提交事务</strong></td></tr><tr><td align="center">T7</td><td align="center">取出10把余额改为90</td><td align="center"></td></tr><tr><td align="center">T8</td><td align="center"><strong>撤销事务</strong></td><td align="center"></td></tr><tr><td align="center">T9</td><td align="center">余额为100</td><td align="center"></td></tr></tbody></table><p><strong>A事务提交时，把已经提交的B事务的更新数据覆盖了</strong></p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center">查询余额为100元</td><td align="center"></td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>提交事务</strong></td></tr><tr><td align="center">T7</td><td align="center">取出10把余额改为90</td><td align="center"></td></tr><tr><td align="center">T8</td><td align="center"><strong>提交事务</strong></td><td align="center"></td></tr><tr><td align="center">T9</td><td align="center">余额为90</td><td align="center"></td></tr></tbody></table><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>读到未提交更新的数据</strong></p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T5</td><td align="center">查询余额为110元</td><td align="center"></td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>撤销事务，余额为100</strong></td></tr><tr><td align="center">T7</td><td align="center">存入100把余额改为210</td><td align="center"></td></tr><tr><td align="center">T8</td><td align="center"><strong>提交事务</strong></td><td align="center"></td></tr></tbody></table><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据</strong></p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T4</td><td align="center">查询余额为100元</td><td align="center"></td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>提交事务</strong></td></tr><tr><td align="center">T7</td><td align="center">查询余额为110元</td><td align="center"></td></tr></tbody></table><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><strong>读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据</strong></p><p><strong>不可重复读和幻读的区别：</strong> 简单来说，不可重复读是由于数据修改引起的，幻读是由数据插入或者删除引起的。</p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center">查询交易记录为3条</td><td align="center"></td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>提交事务</strong></td></tr><tr><td align="center">T7</td><td align="center">查询交易记录为4条</td><td align="center"></td></tr></tbody></table><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>Mysql中事务的隔离级别一共分为四种，分别如下：</p><ul><li><p>序列化（SERIALIZABLE）:提供了事务之间最大限度隔离，事务一个接一个顺序执行，没有脏读，不可重复读，幻读    </p><pre><code>如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，这种隔离级别提供了事务之间最大限度的隔离。</code></pre></li><li><p>可重复读（REAPETABLE　READ）：解决了不可重复读，但是幻读则未解决</p><pre><code>在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。（因为正在执行的事务所产生的数据变化不能被外部看到）。</code></pre></li><li><p>提交读（READ　COMMITTED）：主要解决了脏读的问题，对于不可重复读和幻象读则未解决</p><pre><code>READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。</code></pre></li><li><p>未提交读（READ UNCOMMITTED）:存在脏读，不可重复读以及幻读问题</p><pre><code>READ UNCOMMITTED 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。</code></pre></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻想读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>READ　COMMITTED</td><td>不允许</td><td>允许</td><td>允许</td></tr><tr><td>REAPETABLE　READ</td><td>不允许</td><td>不允许</td><td>允许</td></tr><tr><td>SERIALIZABLE</td><td>不允许</td><td>不允许</td><td>不允许</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="/2019/02/10/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/10/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，就是虚拟机的类加载机制。</p><p>在Java语言中，类型的加载，连接和初始化过程都是在程序运行期间完成的，即动态加载，动态连接。</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，类的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析三阶段统称为连接。</p><p><img src="%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p><p>虚拟机规范中没有对什么时候开始类加载进行强制约束，但是对于初始化阶段，虚拟机规范则严格规定了有且只有5种情况必须立即对类进行“初始化”</p><ol><li>遇到new，getstatic，putstatic，invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。分别对应的场景如下：<ul><li>new：使用new关键字实例化对象的时候</li><li>getstatic，putstatic：读取或设置一个类的静态字段（被final修饰，已在编译期将结果放入常量池的静态字段除外）</li><li>invokestatic：调用一个类的静态方法的时候</li></ul></li><li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类时，如果其父类没有进行过初始化，则需要先触发其父类的初始化。对于接口在初始化时，并不要求其父接口全部初始化，只有在真正使用到父类接口时才会初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li><li>使用动态语言的特殊场景（没有接触过，现在就不讨论了）</li></ol><p>这5种场景称为对一个类的主动引用，除此以外，所有引用类的方式都不会触发初始化，举例说明主动引用和备用引用的区别：</p><p>补充：</p><ul><li>静态代码块：static声明，JVM加载类时，仅执行一次</li><li>构造代码块：类种直接用{}定义，每次创建对象时执行</li><li>执行顺序：<ul><li>无继承：静态代码块—-&gt; main()  —-&gt; 构造代码块 —-&gt; 构造方法</li><li>有继承：父类静态代码块 —-&gt;子类静态代码块 —-&gt;父类构造代码块，构造函数 —-&gt;子类构造代码块，构造函数</li></ul></li></ul><p><strong>主动引用情况1</strong></p><p>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>A</code></pre><p><strong>主动引用情况2</strong></p><p>使用new关键字实例化对象的时候</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        B b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>B</code></pre><p><strong>主动引用情况3</strong></p><p>读取或设置一个类的静态字段</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>B<span class="token number">100</span></code></pre><p><strong>主动引用情况4</strong></p><p>当初始化一个类时，如果其父类没有进行过初始化，则需要先触发其父类的初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>BA</code></pre><p><strong>被动引用情况1</strong></p><p>通过子类引用父类的静态字段，不会导致类初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>B<span class="token number">100</span></code></pre><p><strong>被动引用情况2</strong></p><p>通过数组定义来引用类，不会触发类的初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        B<span class="token punctuation">[</span><span class="token punctuation">]</span> bs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//无输出</span></code></pre><p><strong>被动引用情况3</strong></p><p>常量在编译阶段会存入调用类的常量池种，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span><span class="token number">100</span></code></pre><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成3件事情</p><ul><li>通过一个类的全限定名来获取此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为<strong>方法区的运行时数据结构</strong></li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个可类的各种数据的访问入口</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证时连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p><p>验证阶段大致完成下面4个阶段的检验工作</p><ol><li><p>文件格式验证：验证字节码是否符合Class文件格式规范</p><p>该验证阶段主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个java类型信息的要求。该阶段地验证是基于二进制字节流进行地，只有通过了这个阶段地验证后，字节流才会进入内存的方法区中进行存储，后面的3个阶段全部是基于方法区的存储结构进行的。</p></li><li><p>元数据验证：对字节码描述的信息进行语义分析</p></li><li><p>字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的</p></li><li><p>符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用时，该转化发生在连接的第三阶段解析阶段。符号引用验证可以看做时对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</p></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段时正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行匹配。</p><ul><li>进行内存分配的仅包括类变量，而不包括实例变量</li><li>初始值为数据类型的零值（常量要初始化为对应的值）</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</p><ul><li>符号引用：符号引用以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。</li><li>直接引用：直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>到了初始化阶段，才真正开始执行类中定义的java程序代码。</p><p>初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程，对&lt; clinit &gt;的要求有如下</p><ol><li>方法由编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态语句块（static{}块）中的语句合并产生，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问</li><li>方法于类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证子类的&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()方法已经执行完毕</li><li>方法对于类和接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，则编译器不会生成该方法</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此也会生成&lt; clinit &gt;方法，但执行接口的方法时，不需要先执行父接口的&lt; clinit &gt; 的方法，只有当父接口中定义的变量使用时，父接口的方法才会初始化</li><li>虚拟机会保证一个类的&lt; clinit &gt;方法在多线程环境下正确的执行</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类命名空间。</p><p>3种系统提供的类加载器</p><ol><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责将存放在<JAVA_HOME>/lib的类库加载到虚拟机内存中</li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：负责将存放在<JAVA_HOME>/lib/ext的类库加载到虚拟机内存中</li><li><strong>应用程序类加载器（Application ClassLoader）</strong>：负责加载用户路径（ClassPath）上所指定的类库</li></ol><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>类加载器之间的层次关系，称为类加载器的双亲委派模型</p><p><strong>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应由自己的父类加载器</strong></p><p><img src="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt=""></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ClassLoader loader <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>loader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>loader<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            loader <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取其父类加载器</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>双亲委派模型的工作过程：</p><pre><code>如果一个类的加载器收到类加载请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都传送到顶层的类加载器中，只有当父类加载器反馈自己无法完成这个请求时（它的搜索范围中没有找到需要的类）时，子加载器才会尝试自己去加载。</code></pre><p>好处</p><ul><li>核心类不会被篡改</li><li>保证一些特殊类的唯一性，比如java.lang.Object，所有类的父类</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元数据</title>
      <link href="/2019/02/06/%E5%85%83%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/02/06/%E5%85%83%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="元数据概述"><a href="#元数据概述" class="headerlink" title="元数据概述"></a>元数据概述</h3><p>元数据（Metadata）是关于数据的数据。元数据打通了源数据，数据仓库，数据应用，记录了数据从产生到消费的全过程。元数据主要记录数据仓库中模型的定义，各层级间的映射关系，监控数据仓库的数据状态以及ETL的任务运行状态。</p><p>元数据按用途可以分为两类</p><ol><li>技术元数据：是存储关于数据仓库系统技术细节的数据，是用于开发 和管理数据仓库使用的数据<ul><li>分布式计算系统存储元数据，例如表，列，分区等信息</li><li>分布式计算系统运行元数据，例如运行作业信息，作业类型，输入输出等信息</li><li>数据开发平台中数据同步，计算任务，任务调度等信息，包括数据同步的输入输出表和字段，以及同步任务本身的节点信息。</li><li>数据质量和运维相关元数据，如任务监控，运维报警，数据质量，故障等信息。</li></ul></li><li>业务元数据：从业务角度描述了数据仓库中的数据，它提供了介于使用者和实际系统之间的语义层，使得不懂计算机技术的业务人员也能够 “读懂”数据仓库中的数据<ul><li>维度及属性，业务过程，指标等规范化定义</li><li>数据应用元数据，如数据报表，数据产品等的配置和运行元数据。</li></ul></li></ol><p>元数据有重要的应用价值，是数据管理，数据内容，数据应用的基础，在数据管理方面为集团数据提供j计算，存储，成本，质量，安全，模型等治理领域上的数据支持。</p><p>元数据建设的目标是打通数据接入到加工，再到数据消费整个链路，规范元数据体系和模型，提供统一的元数据服务出口，保证元数据产出的稳定性和质量。</p><p>统一元数据建设思路：</p><p><img src="onemate%E4%BD%93%E7%B3%BB.png" alt=""></p><ol><li><p>首先梳理清楚元仓底层数据，对元数据做分类，如计算元数据，存储元数据，质量元数据等，减少数据重复建设，保证数据唯一性。而且也要丰富表和字段使用说明，方便使用和理解</p></li><li><p>根据元仓底层数据构建元仓中间层，建设元数据基础宽表，也就是元数据中间层，打通从数据产生到消费整个链路，不断丰富中间层数据</p></li><li><p>基于元数据中间层，对外提供标准统一的元数据服务出口， 保障元数据产出的质量。</p><p>丰富的元数据中间层不仅能够为集团数据提供 在计算、存储、成本、质量、安全、模型等治理领域上的数据支持，形 成一套完整的 ROI 数据体系，而且为集团数据进行数据内容、数据域、 数据主题、业务属性等的提取和分析提供了数据素材。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据建模</title>
      <link href="/2019/02/06/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/"/>
      <url>/2019/02/06/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="维度建模"><a href="#维度建模" class="headerlink" title="维度建模"></a>维度建模</h2><p>维度建模从分析决策的需求触发构建模型，为分析需求服务，因此它重点关注用户如何更快速地完成需求分析，同时具有较好的大规模复杂查询的响应性能。其设计分为以下几个步骤：</p><ul><li>选择需要进行分析决策的业务流程</li><li>选择粒度，粒度是维度的一个组合</li><li>识别维表</li><li>选择事实，确定分析需要衡量的指标。</li></ul><h2 id="维度设计"><a href="#维度设计" class="headerlink" title="维度设计"></a>维度设计</h2><h3 id="维度设计基础"><a href="#维度设计基础" class="headerlink" title="维度设计基础"></a>维度设计基础</h3><h4 id="维度的概念"><a href="#维度的概念" class="headerlink" title="维度的概念"></a>维度的概念</h4><p>维度是维度建模的基础，在维度建模中，度量称为“事实”，环境描述为“维度”，维度是用于分析事实所需要的多样环境。例如在分析交易过程时，可以通过卖家，买家，商品和交易时间等维度描述交易发生的环境。</p><p>维度所包含的表示维度的列，称为维度属性。维度属性时查询约束条件，分组和表标签生成的基本来源。，</p><p>维度使用主键表示其唯一性，主键也是确保与之相连的任何事实表之间存在引用完整性的基础。主键有两种，他们都是用于标识某维度的具体值：</p><ul><li>代理键：不具有业务含义的键，一般用于处理缓慢变化维</li><li>自然键：具有业务含义的键</li></ul><h4 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h4><p>维度的设计过程就是确定维度属性的过程，如何生成维度属性，以及所生成的维度属性的优劣，决定了维度使用的方便性，以电商商品维度为例：</p><ol><li>选择维度或新建维度，一定要保证维度的唯一性</li><li>确定主维表，主维表一般是ODS表，直接与业务系统同步</li><li>确定相关维表，根据业务，确定哪些表与主维表存在关联关系，并选择其中的某些表用于生成维度属性，比如商品与类目，卖家，店铺存在关联关系</li><li>确定维度属性，包括从主维表中选择维度属性或生成新的维度属性，从相关维表中选择维度属性或生成新的维度属性</li></ol><p>确定维度属性的几点提示</p><ul><li><p>尽可能生成丰富的属性维度</p></li><li><p>尽可能多地给出包括一些富有意义地文字性描述</p></li><li><p>区分数值型属性和事实</p><p>通常用于查询约束条件或分组统计作为维度属性；通常用于参与度量的计算作为事实</p></li><li><p>尽可能沉淀出通用的维度属性</p></li></ul><h4 id="维度的层次结构"><a href="#维度的层次结构" class="headerlink" title="维度的层次结构"></a>维度的层次结构</h4><p><strong>度中的一些描述属性以层次方法或一对多相互关联，可以被理解为包含连续主从关系的属性层次。</strong>比如商品维度，有卖家，类目，品牌等。商品属于类目，类目属于行业，其中类目的最低级别是叶子类目，叶子类目属于二级类目，二级类目属于一级类目。</p><h4 id="规范化与反规范化"><a href="#规范化与反规范化" class="headerlink" title="规范化与反规范化"></a>规范化与反规范化</h4><p>当属性层次被实例化为一系列列维度，而不是单一的维度时，被称为<strong>雪花模式</strong>。大多数联机事务处理系统（OLTP）的底层数据结构在设计时采用这种模式，通过规范化处理将重复属性移至自身所属的表中，删除冗余数据（和数据库三范式的第二范式类似，每一项都要都要于主键有关）</p><p><img src="%E8%A7%84%E8%8C%83%E5%8C%96.png" alt=""></p><p>而对于联机分析处理系统（OLAP），数据是稳定的。将维度的属性层次合并到单个维度中的操作称为反规范化。对于分析系统，采用雪花模式，用户在统计分析的过程中需要大量的关联操作，使用复杂度较高，同时查询性能很差；而采用反规范化方法，方便，易用且性能好。</p><p><img src="%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96.png" alt=""></p><p>采用雪花模式，除了可以节约一部分存储外，对于 OLAP 系统来说 没有其他效用 。 而现阶段存储的成本非常低,出于易用性和性能的考虑， 维表一般是很不规范化的。</p><h4 id="一致性维度和交叉探查"><a href="#一致性维度和交叉探查" class="headerlink" title="一致性维度和交叉探查"></a>一致性维度和交叉探查</h4><p>数据仓库总线架构的重要基石之一就是一致性维度。在针对不同数 据域进行迭代构建或并行构建时，存在很多需求是对于不同数据域的业 务过程或者同一数据域的不同业务过程合并在一起观察。<strong>将不同数据域的商品的事实合并在一起进行数据探查，称为交叉检查。</strong></p><p>如果不同数据域的计算过程使用的维度不一致，就会导致交叉探查存在问题；当存在重复维度，但维度属性或维度属性的值不一致时，会导致交叉探查无法进行或结果错误。</p><p>维度一致性的变现形式如下</p><ol><li>共享维表。</li><li>一致性上卷，其中一个维度属性是另一个维度属性的自己，且两个维度的公共维度属性结构和内容相同。</li><li>交叉属性，两个维度具有部分相同的维度属性。</li></ol><h3 id="维度设计高级主题"><a href="#维度设计高级主题" class="headerlink" title="维度设计高级主题"></a>维度设计高级主题</h3><h4 id="维度整合"><a href="#维度整合" class="headerlink" title="维度整合"></a>维度整合</h4><p>数据仓库的重要数据来源是大量的、分散的面向应用的操作型环 境。不同的应用在设计过程中，可以自由决策，主要满足本应用的需求， 很少会考虑和其他系统进行数据集成。应用之间的差异具体表现在如下 几个方面：</p><ul><li>应用在编码，命名习惯，度量单位等方面存在较大差异</li><li>应用出于性能和扩展性考虑，或者随技术架构演变，以及业务发展，采用不同的物理实现</li></ul><p>所以数据由面向应用操作型环境进入数据仓库后，需要进行数据集成。</p><ul><li>命名规范的统一</li><li>字段类型的统一</li><li>公共代码以及代码值得统一</li><li>业务含义相同的表的统一<ul><li>采用主从表设计，将两个b表或者多个表d都有的字段放在主表中，从属信息分表放在各自的从表中。</li><li>直接合并，共享信息和个性信息都放在一个表中。如果表字段的重合度较低，则会出现d大量空值。</li><li>不合并。因为源表的表结构以及主键等差异较大，无法合并</li></ul></li></ul><p>表级别的整合有两种表现形式</p><ol><li><p>垂直整合：不同的来源表包含相同的数据集，只是存储的信息不同</p><p>比如，会员表中有会员基础信息表，会员扩展信息表，会员等价表，这些表都属于会员相关信息表，依据维度设计方法，尽量整合至会员维度模型</p></li><li><p>水平整合：不同的来源表包含不同的数据集，不同子集之间无交叉，也可以存在部分交叉</p><p>包含不同的数据集，先判断各个数据集有无交叉，如果有交叉，则需要去重；如果不存在交叉，则考虑自然键是否冲突，如果不冲突，则可以将各个子集的自然键作为整合后的表的联合主键。</p></li></ol><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>维度通常需要按照类别或类型进行细分，设计维度有如下两种方法</p><ol><li>方案一：将维度的不同分类实例化为不同的维度，同时在主维度中保存公共属性</li><li>方案二：维护单一维度，包含所有可能的属性</li></ol><p>在设计过程中应该考虑以下三个原则</p><ol><li>扩展性</li><li>效能：性能和成本方面取得平衡</li><li>易用性：模型可l理解性高，访问复杂度低</li></ol><p>在维度进行水平拆分时，主要考虑如下两个依据</p><ol><li><p>维度的不同分类的属性差异情况</p><p>当维度属性随类型变化较大时，将所有可能的属性建立在一个表中不切实际，建议采用方案一。定义一个主维度用于存放公共属性；同时定义多个子维度，其中除了包含公共属性外，还包括各自的特殊属性。</p></li><li><p>依据业务的关联程度</p><p>两个相关性较低的业务，耦合在一起弊大于利，对模型的稳定性和易用性影响较大，可以采用方案二。</p></li></ol><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>由于维度分类的不同而存在特殊的维度属性，可以通过水平拆分解决该问题。</p><p>对于某些维度属性的来源表产出时间较早，而某些维度属性的来源表产出时间较晚；或者某些维度属性的热度高，使用频繁，而某些维度属性比较稳定。处于扩展性，产出时间，易用性等方面考虑，设计主从维度，主维表存放未定，产出时间早，热度高的属性；在维表存放变化比较快，产生时间晚，热度低的属性。</p><h3 id="维度变化"><a href="#维度变化" class="headerlink" title="维度变化"></a>维度变化</h3><h4 id="缓慢变化维"><a href="#缓慢变化维" class="headerlink" title="缓慢变化维"></a>缓慢变化维</h4><p>数据仓库的重要特点之一是反应历史变化。因为现实世界中，维度的属性并不是静态的，它会随着时间的流逝发生缓慢的变化，与数据增长较块的事实表相比，维度变化相对缓慢，这种缓慢变化的维度称为缓慢变化维。</p><p>有三种处理缓慢变化维的方式</p><ol><li><p>重写维度值，不保留历史数据，始终取最新数据。</p></li><li><p>插入新的维度行，保留历史数据，维度变化前的事实和过去的维度值相关，维度变化后的事实与当前维度值关联</p><p>该方式不能将变化前后记录的事实归一为变化前的维度或者归一为变化后的维度</p></li><li><p>添加维度列，该列存储旧的维度值</p></li></ol><h4 id="快照维表"><a href="#快照维表" class="headerlink" title="快照维表"></a>快照维表</h4><p>一般使用代理键作为每个维表的主键，用于处理缓慢变化维。但对于分布式计算系统，不存在事务的概念，对于每个表的记录生成稳定（某条记录每次生成的代理键相同）的全局唯一的代理键难度较大。而且使用代理键会大大增加ETL（数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程）的复杂性，对ETL任务的开发和维护成本很高。</p><p>处理缓慢变化维可以使用快照方式。数据仓库的计算周期一般是每天一次，基于此周期，处理缓慢变化维的方式就是每天保留一份全量快照数据。比如商品维度，每天保留一份全量商品快照数据，任意一天的事实均可以获取当天的商品信息，也可以获取最新的商品信息。（即每天的事实表对应每天的维度表）</p><p>优点：</p><ul><li>简单有效，开发和维护成本低</li><li>使用方便，理解性好</li></ul><p>弊端主要是存储的极大浪费。</p><h4 id="极限存储"><a href="#极限存储" class="headerlink" title="极限存储"></a>极限存储</h4><p><strong>历史拉链</strong>是另一种处理缓慢变化维的方法。这种处理方法是通过新增两个时间戳字段，将所有以天为粒度的变更数据都记录下来。</p><p>比如，如下表记录商品上架下架信息</p><p><img src="%E5%95%86%E5%93%81%E4%B8%8A%E4%B8%8B%E6%9E%B6%E4%BF%A1%E6%81%AF.png" alt=""></p><p>采用历史拉链存储，对于不变的数据，不再重复存储。</p><p><img src="%E6%95%B0%E6%8D%AE%E6%8B%89%E9%93%BE.png" alt=""></p><p>这种存储方式对下游使用存在一定的理解障碍，另外，这种存储方式用start_dt和end_dt做分区，随着时间推移，分区数量会极度膨胀。可以利用极限存储方式处理。</p><p><strong>透明化</strong></p><p>底层的数据还是使用历史拉链存储，但上层做一个视图操作，通过分析语句的分析树，把极限存储前的表的查询转换成对极限存储表的查询</p><p><strong>分月做历史拉链</strong></p><p>在每个月月初重新做历史拉链。</p><p>该方法极大压缩了全量存储的成本，又可以对下游用户透明的效果。但其产出效率很低，并且对变化频率较高的数据并不能达到节约成本的效果。因此在实际生产中，做极限存储需要进行一些额外的处理</p><ul><li>在做极限存储前有一个全量存储表，全量存储表仅保留最近一段时间的全量分区数据，历史数据通过映射的方式关联到极限存储表。即用户只访问全量存储表，所以对用户来说极限存储是不可见的。</li><li>对于部分变化频率频繁的字段需要过滤。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据仓库</title>
      <link href="/2019/02/05/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
      <url>/2019/02/05/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h2><p>数据仓库的定义：<strong>数据仓库是一个面向主题的，集成的，非易失的且随时间变化的数据集合，用来支持管理人员决策</strong>。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="面向主题的"><a href="#面向主题的" class="headerlink" title="面向主题的"></a>面向主题的</h4><p><strong>与传统数据库面向应用进行数据组织的特点相对应，数据仓库中的数据是面向主题进行组织的。</strong>在逻辑意义上，主题是对应企业中某一宏观分析领域所涉及的分析对象。面向主题的数据组织方式，就是在较高层次上对分析对象的数据的一个完整，一致的描述，能完整，统一地刻画各个分析对象所涉及地企业各项数据。</p><h4 id="集成的"><a href="#集成的" class="headerlink" title="集成的"></a>集成的</h4><p><strong>数据仓库的数据是从原有的分散的数据库数据抽取来的，数据仓库的重要数据来源是大量的、分散的面向应用的操作型环境</strong>。数据由面向应用的操作型环境进人数据仓库后，需要进行数据集成。将面向应用的数据转换为面向主题的数据仓库数据，本身就是一 种集成。</p><h4 id="不可更新的"><a href="#不可更新的" class="headerlink" title="不可更新的"></a>不可更新的</h4><p><strong>数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一般情况下并不进行修改操作。</strong>数据仓库的数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据，而不是联机处理的数据。</p><h4 id="随时间变化的"><a href="#随时间变化的" class="headerlink" title="随时间变化的"></a>随时间变化的</h4><p>数据仓库的数据是随时间的变化而不断变化的</p><ul><li>数据仓库随时间变化不断增加新的数据内容</li><li>数据仓库随时间变化不断删去旧的数据内容</li><li>数据仓库中包含有大量的综合数据，这些综合数据中很多跟时间有关，如数据经常按照时间段进行综合，或隔一定的时间片进行抽样等等</li></ul><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>数据仓库可以分为三层，自下而上为：<strong>操作数据层（ODS，Operation Data Store），公共数据层（CMD，Common Data Model）和应用数据层（ADS，Application Data Service）</strong></p><ol><li><p>操作数据层</p><p><strong>将原始数据几乎无处理的存放在数据仓库系统，结构上与源系统基本保持一致，是数据仓库的数据准备区。</strong></p><ul><li>同步：结构化数据增量或全量同步到计算框架</li><li>结构化：非架构化（日志）结构化处理并存储到计算框架</li><li>累计历史，清洗：根据数据业务需求以及稽核和审计要求保存历史数据，清洗数据</li></ul></li><li><p>公共数据层</p><p><strong>主要完成数据加工与整合，建立一致性的维度，构建可复用的面向分析和统计的明细事实表，以及汇总公共粒度的指标。</strong></p><p>存放<strong>明细事实数据、维表数据及公共指标汇总数据</strong> ， 其中明细事实数据、维表数据一般根据 ODS 层数据加工 生成 ，公共指标汇总数据一般根据维表数据和明细事实数据加工生成。</p><p>CDM层又可以细分为明细数据层（DWD层）和汇总数据层（DWS层）</p><ul><li>明细数据层：采用维度模型方法作为理论基础，更多地采用一些维度退化手法，将维度退化至事实表中，减少事实表和维表的关联，提高明细数据表的易用性 </li><li>汇总数据层：加强指标的维度退化，采取更多的宽表化手段构建公共指标数据层，提升公共指标的复用性，减少重复加工。</li></ul></li><li><p>应用数据层</p><p><strong>存放数据产品个性化的统计指标数据，根据CDM与ODS层加工生成。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HbaseShell</title>
      <link href="/2019/02/03/HbaseShell/"/>
      <url>/2019/02/03/HbaseShell/</url>
      
        <content type="html"><![CDATA[<h2 id="Hbase-Shell"><a href="#Hbase-Shell" class="headerlink" title="Hbase Shell"></a>Hbase Shell</h2><p>HBase提供了一个非常方便的命令行交互工具HBase Shell。</p><p>以下表（s_behavior）为例</p><p><img src="%E8%A1%A8.png" alt=""></p><h3 id="数据定义语言"><a href="#数据定义语言" class="headerlink" title="数据定义语言"></a>数据定义语言</h3><p>数据定义语言（Data Definition Language，DDL），包括数据库表的创建，修改等语句。</p><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><pre><code>create &lt;table&gt;, &lt;NAME =&gt; 列族&gt;create &#39;s_behavior&#39;, {NAME =&gt; &#39;pc&#39;},{NAME =&gt; &#39;ph&#39;}</code></pre><h4 id="查看所有表"><a href="#查看所有表" class="headerlink" title="查看所有表"></a>查看所有表</h4><pre><code>list</code></pre><h4 id="查看建表"><a href="#查看建表" class="headerlink" title="查看建表"></a>查看建表</h4><pre><code>describe &#39;s_behavior&#39;</code></pre><p>表的属性解释</p><ul><li>DATA_BLOCK_ENCODING：数据块编码。用类似于压缩算法的编码形式来节省存储空间。</li><li>BLOOMFILTER：布隆过滤器。数据查询Scan操作的时候用来排除待扫描的StoreFile文件。</li><li>REPLICATION_SCOPE：集群间数据赋值开关。1表示开启赋值。</li><li>VERSIONS：HBase对表的数据行可以保留多个数据版本，以时间戳来区分。</li><li>COMPRESSION：压缩方式。HBase提供多种压缩方式用来在数据存储到磁盘之前压缩以减少存储空间。</li><li>TTL：  数据的有效时长，超过TTL的数据在主压缩时会被删除。</li><li>KEEP_DELETED_CELLS：保留了删除的数据，当主压缩后删除的数据才会被清理，如果开启集群间复制，则必须为true，否则会导致数据复制失败</li><li>BLOCKSIZE：HBase读取数据的最小单元，默认为64KB。</li></ul><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><p>修改表需要先将表下线，然后执行修改命令，再上线</p><pre><code>disable &#39;s_behavior&#39; #下线alter &#39;s_behavior&#39;, {NAME =&gt; &quot;cf&quot;, REPLICATION_SCOPE =&gt; &quot;1&quot;, KEEP_DELETED_CELLS =&gt; &quot;TRUE&quot;} #改变表enable &#39;s_behavior&#39; #上线</code></pre><h3 id="数据操作语言"><a href="#数据操作语言" class="headerlink" title="数据操作语言"></a>数据操作语言</h3><p>数据操作语言（Data Manipulation Language，DML），包括数据的修改，查询，删除等语句。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>put命令用来插入一行数据到HBase表</p><pre><code>put &lt;table&gt;, &lt;rowkey&gt;, &lt;列族:列标识符&gt;, &lt;值&gt;#插入pc值put &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, &#39;pc:v&#39;, &#39;1001&#39;#插入ph值put &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, &#39;ph:o&#39;, &#39;1001&#39;</code></pre><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>get命令用来根据行键获取HBase表的一条记录</p><pre><code>get &lt;table&gt;, &lt;rowkey&gt;#获取一条数据get &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;# 获取一条数据某时刻的镜像get &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, {TIMESTAMP =&gt; &#39;151692489001&#39;}#获取多个版本的数据(get命令支持获取数据的多个版本，建表是指定VERSIONS属性即可)alter &#39;s_behavior&#39;, NAME=&gt;&#39;pc&#39;, VERSIONS=&gt;3 #改表put &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, &#39;pc:v&#39;, &#39;1002&#39; #放一个新数据，之前已经有该键get &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, {COLUMN =&gt; &#39;pc:v&#39;, VERSIONS =&gt; 2}</code></pre><h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h3><p>Scan命令用来扫描表的数据，Scan可以有多种用法</p><pre><code>scan &lt;table&gt;#扫描表scan &#39;s_behavior&#39;#获取时间区间内数据scan &#39;s_behavior&#39;, {TIMERANGE =&gt; [151423996739,151513996739]}#获取多版本数据scan &#39;s_behavior&#39;, {VERSIONS =&gt; 2}#获取用户(ID=12345)前5行数据scan &#39;s_behavior&#39;, {FILTER =&gt; &quot;PrefixFilter(&#39;12345_&#39;)&quot;, COLUMNS =&gt; [&#39;pc&#39;], LIMIT=&gt;5}#获取用户(ID=12345)某个时间区间的PC端行为数据scan &#39;s_behavior&#39;, {STARTROW =&gt; &#39;12345_151423996739&#39;,STOPROW =&gt; &#39;12345_151513996739&#39;, COLUMNS =&gt; [&#39;pc&#39;]}#获取用户对商品(ID=1001)的行为数据scan &#39;s_behavior&#39;, FILTER =&gt; &quot;ValueFilter(=,&#39;binary:1001&#39;)&quot;#获用户对商品(ID包含1002)的行为数据scan &#39;s_behavior&#39;, FILTER =&gt; &quot;ValueFilter(=,&#39;substring:1002&#39;)&quot;</code></pre><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>delete用来删除某列数据</p><pre><code>delete &lt;table&gt;, &lt;roekey&gt;, &lt;列族:列标识符&gt;, [&lt;time stamp&gt;]delete &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, &#39;ph:o&#39;</code></pre><h3 id="DeleteAll"><a href="#DeleteAll" class="headerlink" title="DeleteAll"></a>DeleteAll</h3><p>deleteall删除整行数据</p><pre><code>deleteall &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;</code></pre><h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><p>truncate删除整个表</p><pre><code>truncate &#39;s_behavior&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka-生产者</title>
      <link href="/2019/02/03/kafka-%E7%94%9F%E4%BA%A7%E8%80%85/"/>
      <url>/2019/02/03/kafka-%E7%94%9F%E4%BA%A7%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>生产者发送消息过程如下：</p><ol><li>首先创建一个ProducerRecord 对象，该对象包含目标主题和要发送的内容。还可以指定键或分区，在发送ProducerRecordd对象时，生产者先把键和值对象序列化成字节数组，再发送到网络上</li><li>数据被传送到分区器。如果在ProducerRecord指定了分区器，那么分区器则不会再做任何事，直接将指定的分区返回。如果没有指定分区，分区器会根据 ProducerRecord 对象的键来选择一个分区。选好分区以后，生产者就知道该往哪个主题和分区发送这条记录了。紧接着，这条记录被添加到一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。有一个独立的线程负责把这些记录批次发送到相应的 broker 上。 </li><li>服务器在收到这些消息时会返回一个响应。如果消息成功写入 Kafka，就返回 一个 RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败， 则会返回一个错误</li></ol><p><img src="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B5%81%E7%A8%8B.png" alt=""></p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><h4 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h4><p>向Kafka 写入消息，首先要创建一个生产者对象，并设置一些属性。 Kafka 生产者有 3 个必选的属性。</p><ul><li><p>bootstrap.servers</p><p>指定 broker （kafka实例）的地址，地址的格式为 host:port</p></li><li><p>key.deserializer</p><p>key.deserializer必须被设置为一个实现了org.apache.kafka.common.serialization.Serializer接口的类，生产者会使用这个类把键对象序列化成字节数组。 </p></li><li><p>value.deserializer</p><p>value.deserializer指定的类会将值序列化</p></li></ul><pre class=" language-java"><code class="language-java">Properties props<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span><span class="token string">"116.62.141.178:9092"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.serializer"</span><span class="token punctuation">,</span><span class="token string">"org.apache.kafka.common.serialization.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.serializer"</span><span class="token punctuation">,</span><span class="token string">"org.apache.kafka.common.serialization.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Producer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h4><p>生 产者的 send()方法将 ProducerRecord对象作为参数并发送</p><pre class=" language-java"><code class="language-java">String key <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>data <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"kafkaTest"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的例子也是发送消息的第一种方式——发送并忘记，即不关系发送的结果，只是将数据发送</p><h5 id="同步发送消息"><a href="#同步发送消息" class="headerlink" title="同步发送消息"></a>同步发送消息</h5><p>producer.send()方法先返回一个 Future 对象，然后调用 Future 对象的 get() 方法等待 Kafka 响应。如果服务器返回错误， get()方法会抛出异常。如果没有发生错 误，我们会得到一个 RecordMetadata 对象，可以用它获取消息的偏移量。</p><pre class=" language-java"><code class="language-java">String key <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>data <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">{</span>    producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"kafkaTest"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h5><p>同步发送消息需要等待响应，因为kafka会将目标主题，分区信息和消息的偏移量发送回来，而发送端的应用通常不会用到这些信息，因此大多数情况下我们不需要等待响应。但是在遇到消息发送失败时，我们需要抛出异常，记录错误日志，或者将消息写入“错误消息”文件种，我们可以使用异步发送消息</p><p>为了在异步发送消息的同时能够对异常情况进行处理，生产者提供了回调支持</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//定义一个实现了org.apache.kafka.clients.producer.Callback接口的类，该类只有一个onCompletion方法</span><span class="token comment" spellcheck="true">//如果Kafka返回一个错误，onCompletion方法会抛出一个非空异常</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">DemoProducerCallback</span> <span class="token keyword">implements</span> <span class="token class-name">Callback</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCompletion</span><span class="token punctuation">(</span>RecordMetadata recordMetadata<span class="token punctuation">,</span> Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">!=</span>null<span class="token punctuation">)</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>String key <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>data <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"kafkaTest"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DemoProducerCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="发送消息的配置"><a href="#发送消息的配置" class="headerlink" title="发送消息的配置"></a>发送消息的配置</h4><ol><li><p>acks</p><p>acks参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功</p><ul><li>acks=0， 生产者在成功写入消息之前不会等待任何来自服务器的响应，即生产者不管服务器响应</li><li>acks=1，只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应。</li><li>acks=all，只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自 服务器的成功响应。</li></ul></li><li><p>buffer.memory</p><p>设置生产者内存缓冲区的大小，生产者用它缓冲要发送到服务器的消息</p></li><li><p>compression.type</p><p>该参数可以设置为 snappy、 gzi.p 或 lz4，它指定了消息被发送给 broker之前使用哪一种压缩算法进行压缩。 </p></li><li><p>retries </p><p>retries 参数的值决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试并返回错误</p></li><li><p>batch.size</p><p>当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算</p></li><li><p>linger.ms </p><p>指定了生产者在发送批次之前等待更多消息加入批次的时间。 KafkaProducer会在 批次填满或linger.ms 达到上限时把批次发送出去。</p></li><li><p>max.in.flight.requests.per.connection </p><p>该参数指定了生产者在收到服务器晌应之前可以发送多少个消息。它的值越高，就会占用越多的内存，不过也会提升吞吐量。 把它设为 1 可以保证消息是按照发送的顺序写入服务 器的，即使发生了重试。</p></li><li><p>timeout.ms，request.timeout.ms 和 metadata.fetch. timeout. ms</p><ul><li><p>timeout.ms指定了 broker 等待同步副本返回消息确认的时间，与 asks 的配置相匹配一一如果在指定时间内没有收到同步副本的确认，那么 broker 就会返回 一个错误。</p></li><li><p>request.timeout.ms指定了生产者在发送数据时等待服务器返回响应的时间</p></li><li><p>metadata.fetch. timeout. ms指定了生产者在获取元数据时等待服务器返回响应的时间</p></li></ul></li><li><p>max.block.ms</p><p>调用 send()方法或使用partitionFor()方法获取元数据时生产者的阻塞时间。当生产者的发送缓冲区已满，或者没有可用的元数据时，这些方法就会阻塞。在阻 塞时间达到max.block.ms时，生产者会抛出超时异常。</p></li><li><p>max.request.size </p><p>控制生产者发送的请求大小</p></li></ol><h4 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestProducer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Properties props<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span><span class="token string">"116.62.141.178:9092"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"acks"</span><span class="token punctuation">,</span><span class="token string">"all"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"retries"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"batch.size"</span><span class="token punctuation">,</span><span class="token number">16384</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"linger.ms"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"buffer.memory"</span><span class="token punctuation">,</span><span class="token number">33554432</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.serializer"</span><span class="token punctuation">,</span><span class="token string">"org.apache.kafka.common.serialization.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.serializer"</span><span class="token punctuation">,</span><span class="token string">"org.apache.kafka.common.serialization.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Producer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> messageNum<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">120</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>messageNum<span class="token operator">&lt;</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>            String key<span class="token operator">=</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>messageNum<span class="token punctuation">)</span><span class="token punctuation">;</span>            String data<span class="token operator">=</span><span class="token string">"@@@@hello kafka message"</span><span class="token operator">+</span>key<span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"kafkaTest"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            messageNum<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        producer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意发送完数据要关闭，否则可能出错</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>ProducerRecord对象包含了目标主题、键和值，也可以不包含键，只包含目标主题和值</p><pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"kafkaTest"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"kafkaTest"</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li>如果键值为 null， 并且使用了默认的分区器，那么记录将被随机地发送到主题内各个可用 的分区上。分区器使用轮询（Round Robin）算法将消息均衡地分布到各个分区上。</li><li>如果键不为空，并且使用了默认的分区器，那么Kafka会对键进行散列（使用 Kafka 自己 的散列算法）,然后根据散列值把消息映射 到特定的分区上。</li></ol><p>当我们需要将特定的数据放在一个分区上时，我们需要自己定义分区方法，如下，将key=special的数据放在最后一个分区，其他的放在剩余的分区上。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SpecialPartitioner</span> <span class="token keyword">implements</span> <span class="token class-name">Partitioner</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> configs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>String topic<span class="token punctuation">,</span> Object key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keyBytes<span class="token punctuation">,</span> Object value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> valueBytes<span class="token punctuation">,</span> Cluster cluster<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取主题分区信息</span>        List<span class="token operator">&lt;</span>PartitionInfo<span class="token operator">></span> partitionInfos <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numPartition <span class="token operator">=</span> partitionInfos<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>keyBytes <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidRecordException</span><span class="token punctuation">(</span><span class="token string">"We expect all messages to have customer name as key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"special"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> numPartition<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//其他记录分散到其他分区</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>Utils<span class="token punctuation">.</span><span class="token function">murmur2</span><span class="token punctuation">(</span>keyBytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>numPartition<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka介绍</title>
      <link href="/2019/02/03/kafka%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/02/03/kafka%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="kafka是流处理平台"><a href="#kafka是流处理平台" class="headerlink" title="kafka是流处理平台"></a>kafka是流处理平台</h3><p>流处理平台有三种特性</p><ul><li>发布和订阅可以流式记录</li><li>可以存储流式记录，并且有较好的容错性</li><li>可以在流式记录产生时进行处理</li></ul><p>kafka具有如下特性</p><ul><li>kafka作为一个集群，可以在一台或者多台服务器上运行</li><li>kafka通过topic对存储的流数据进行分类</li><li>每条记录有一个key，一个value和一个timestamp</li></ul><p>kafka有四个核心的API</p><ul><li><strong>Producer API</strong>：允许一个应用程序发布一串流式的数据到一个或者多个Kafka topic。</li><li><strong>Cosumer API</strong>：允许一个应用程序订阅一个或多个 topic ，并且对发布给他们的流式数据进行处理。</li><li><strong>Streams API</strong>：允许一个应用程序作为一个<em>流处理器</em>，消费一个或者多个topic产生的输入流，然后生产一个输出流到一个或多个topic中去，在输入输出流中进行有效的转换。</li><li><strong>Connector API</strong>：允许构建并运行可重用的生产者或者消费者，将Kafka topics连接到已存在的应用程序或者数据系统。比如，连接到一个关系型数据库，捕捉表（table）的所有变更内容。</li></ul><p><img src="./kafka-apis.png" alt=""></p><h3 id="Kafka的构成"><a href="#Kafka的构成" class="headerlink" title="Kafka的构成"></a>Kafka的构成</h3><h4 id="Topics和日志"><a href="#Topics和日志" class="headerlink" title="Topics和日志"></a>Topics和日志</h4><p>Topic是数据主题，是数据记录发布的地方，可以用来区分业务系统。kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费者来订阅其数据。</p><p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，只要如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力：</p><p><img src="./kafka-%E5%88%86%E5%8C%BA.png" alt=""></p><p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，称之为offset，<em>offset</em>用来唯一的标识分区中每一条记录。</p><p>Kafka 集群保留所有发布的记录—无论他们是否已被消费—并通过一个可配置的参数——保留期限来控制. 举个例子， 如果保留策略设置为2天，一条记录发布后两天内，可以随时被消费，两天过后这条记录会被抛弃并释放磁盘空间。Kafka的性能和数据大小无关，所以长时间存储数据没有什么问题。</p><p>在每一个消费者中唯一保存的元数据是offset（偏移量）即消费在log中的位置，偏移量由消费者控制。</p><p><img src="./kafka-consumers.png" alt=""></p><p>日志的分区具有如下用途</p><ol><li>当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可能有多个分区，因此可以处理无限量的数据</li><li>可以作为并行的单元集。</li></ol><p>日志的分区partition （分布）在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性。</p><p>每个分区都有一台 server 作为 “leader”，零台或者多台server作为 follwers 。leader server 处理一切对 partition （分区）的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers 中的一台服务器会自动成为新的 leader。每台 server 都会成为某些分区的 leader 和某些分区的 follower，因此集群的负载是平衡的。</p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>生产者可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(例如：记录中的key)来完成。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>consumer group 是 Kafka 提供的可扩展且具有容错性的消费者机制。一个consumer group有多个consumer，它们共享一个公共的group id。其有如下特点</p><ol><li>consumer group 下可以有一个或多个 consumer instance，consumer instance可以是一个进程，也可以是一个线程。</li><li>group.id 是一个字符串，唯一标识一个 consumer group</li><li>consumer group 订阅的 topic 下的每个分区只能分配给该 group 下的一个 consumer 消费。当然该分区还可以被分配给其他 consumer group。</li></ol><p>对于第三点的理解：组内的所有消费者协调在一起来消费订阅主题的所有分区，partition中的每个message只能被组（Consumer group ）中的一个consumer（consumer 线程）消费，如果一个message被多个consumer消费的话，那么这些consumer必须在不同的组。</p><h4 id="高可用保证"><a href="#高可用保证" class="headerlink" title="高可用保证"></a>高可用保证</h4><ol><li>生产者发送到特定topic partition 的消息将按照发送的顺序处理</li><li>一个消费者实例按照日志中的顺序查看记录.</li><li>对于具有N个副本的主题，我们最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录.</li></ol><h3 id="Kafka使用场景"><a href="#Kafka使用场景" class="headerlink" title="Kafka使用场景"></a>Kafka使用场景</h3><p>它可以用于两大类别的应用:</p><ol><li>构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。 (相当于message queue)</li><li>构建实时流式应用程序，对这些流数据进行转换或者影响。 (就是流处理，通过kafka stream topic和topic之间内部进行变化)</li></ol><p>引用场景</p><ul><li>消息系统</li><li>存储系统</li><li>流处理：在Kafka中，流处理器不断地从输入的topic获取流数据，处理数据后，再不断生产流数据到输出的topic中去。</li><li>批处理：</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YARN简介</title>
      <link href="/2019/01/31/YARN%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/01/31/YARN%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="YARN简介"><a href="#YARN简介" class="headerlink" title="YARN简介"></a>YARN简介</h3><p>YARN（Yet Another Resource Negotiator）是Hadoop的集群资源管理系统。</p><p>分布式计算框架（MapReduce，Spark）作为YARN应用运行在集群计算层（YARN）和集群存储层（HDFS和Hbase）之上。而Pig，Hive等都是运行在MapReduce，Spark之上的处理框架，它们不和YARN直接打交道。</p><p>HDFS，HBase -&gt; YARN -&gt; MapReduce,Spark -&gt;Hive,Pig</p><h3 id="YARN运行机制"><a href="#YARN运行机制" class="headerlink" title="YARN运行机制"></a>YARN运行机制</h3><p>YARN通过两类长期运行的守护进程提供自己的核心服务：管理集群上资源使用的资源管理器（resource manager），运行在集群所有节点且能够启动和监控容器的节点管理器（node manager）</p><p>YARN上运行一个应用：</p><ol><li>客户端要求资源管理器运行一个application master进程</li><li>资源管理器找到一个能够在容器中启动application master的节点管理器</li><li>application master运行起来能做什么依赖于应用本身</li></ol><p>ResourceManager</p><ul><li>处理客户端请求</li><li>启动/监控ApplicationMaster</li><li>监控NodeManager</li><li>资源分配与调度</li></ul><p>NodeManager</p><ul><li>单个节点上的资源管理</li><li>处理ResourceManager的命令</li><li>处理ApplicationMaster的命令</li></ul><p>ApplicationMaster</p><ul><li>数据切分</li><li>为应用程序申请资源，并分配给内部任务</li><li>任务监控与容错</li></ul><p>Container</p><ul><li>对任务运行环境的抽象，封装CPU，内存等资源以及环境变量，启动命令等任务运行相关信息</li></ul><h3 id="YARN中的调度"><a href="#YARN中的调度" class="headerlink" title="YARN中的调度"></a>YARN中的调度</h3><p>YARN调度器是根据既定策略为应用分配资源，有三个调度器：</p><ul><li>FIFO调度器</li><li>容量调度器</li><li>公平调度器</li></ul><h5 id="FIFO调度器"><a href="#FIFO调度器" class="headerlink" title="FIFO调度器"></a>FIFO调度器</h5><p>FIFO调度器将应用放置在一个队列中，然后按照提交的顺序运行应用，先进先出。</p><h5 id="容量调度器"><a href="#容量调度器" class="headerlink" title="容量调度器"></a>容量调度器</h5><p>在FIFO中容易出现小作业阻塞，即等待大作业完成之后才能运行。</p><p>在容量调度器中，设置了一个独立的专门队列保存小作业，一提交就可以启动。与FIFO对比，容量调度器大作业执行时间要长。<br>在capacity-scheduler.xml文件中配置各个队列大小。</p><h5 id="公平调度器"><a href="#公平调度器" class="headerlink" title="公平调度器"></a>公平调度器</h5><p>不需要预留资源，调度器会在所有运行的作业之间动态平衡资源。</p><p>第一个大作业启动，它是唯一运行的作业，则会获得集群所有的资源。当第二个小作业启动，它被分配到集群的一半资源，但是它需要等待第一个作业将这一半资源释放。等第二个作业完成之后，大作业将会再次得到全部的资源。</p><p>在fair-scheduler.xml中配置各个队列大小（分配权重），用于公平共享计算。</p><p>抢占：允许调度器终止那些占用资源超过其公平共享份额的队列的容器，资源释放后可以分配给资源数量低于应得份额的队列。抢占功能有两个抢占超时设置：</p><ul><li>最小共享<br>在指定时间内未获得被承若的最小共享资源，调度器会抢占其他容器。</li><li>公平共享<br>在指定时间呃逆获得的资源仍然低于其公平共享份额的一半，调度器会抢占其他容器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS简介</title>
      <link href="/2019/01/19/HDFS%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/01/19/HDFS%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="HDFS简介"><a href="#HDFS简介" class="headerlink" title="HDFS简介"></a>HDFS简介</h2><h3 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h3><p>HDFS上的文件被划分为块大小的多个分块，作为独立的存储单元，默认大小128M，并且不到一个块大小的文件不会占用多余的空间，比如10M的文件，只会占用10M的大小，而且一个块的大小。</p><p>分布式文件系统抽象为块有如下好处</p><ul><li>一个文件的大小可以大于网络上任意一个磁盘的容量，文件可以不存放在一个磁盘上</li><li>简化了存储子系统的设计，例如可以简化管理</li><li>适合用于数据备份进而提供数据容错能力和提高可用性</li></ul><h3 id="namenode和datanode"><a href="#namenode和datanode" class="headerlink" title="namenode和datanode"></a>namenode和datanode</h3><p>HDFS集群有两类节点以管理节点-工作节点模式运行，即一个namenode和多个datanode。</p><h4 id="namenode"><a href="#namenode" class="headerlink" title="namenode"></a>namenode</h4><ul><li>namenode管理文件系统的命名空间，它维护着文件系统树及整棵树内所有的文件和目录。这些信息以命名空间镜像文件和编辑日志文件两个文件形式永久保存在本地磁盘上。</li><li>namenode在内存中保存文件系统中每个文件和每个数据块的引用关系。</li><li>namenode负责管理文件系统的名字空间以及客户端对文件的访问</li><li>namenode全权管理数据块的复制，它周期性得从集群中每个Datanode接收心跳信号（存活的象征）和块状态报告（节点上所有数据块的列表）。</li><li>跟文件内容相关的数据流不经过namenode，只会询问它跟哪个datanode联系</li><li>目录作为元数据保存在namenode中</li></ul><h5 id="datanode"><a href="#datanode" class="headerlink" title="datanode"></a>datanode</h5><ul><li>datanode是文件系统的工作结点。它们根据需要存储并检索数据块，并定期向namenode发送它们所存储的块的列表。</li><li>datanode启动后向namenode注册，通过后，定期向NameNode上报信息</li><li>心跳是每秒3次，心跳返回结果会带有复制数据，删除数据等命令。如果超过10分钟没有收到某个datanode的心跳，则认为该节点不可用</li></ul><h5 id="数据损坏的处理"><a href="#数据损坏的处理" class="headerlink" title="数据损坏的处理"></a>数据损坏的处理</h5><ol><li>当datanode读取block时，会计算checksum</li><li>如果计算的checksum与block创建时值不一样，说明block已坏，Client读取其他datanode上的block</li><li>namenode标记该块已经损坏，然后复制block达到预期设置的文件备份数</li><li>datanode在其文件创建三周后验证其checksum</li></ol><h3 id="namenode的容错与高可用"><a href="#namenode的容错与高可用" class="headerlink" title="namenode的容错与高可用"></a>namenode的容错与高可用</h3><p>当namenode服务器毁坏，文件系统上所有的文件会丢失，因此对namenode的容错很重要</p><ul><li>备份组成文件系统元数据持久状态的文件，使namenode在多个文件系统上保存元数据的持久状态</li><li>运行一个辅助namenode，可以定期合并编辑日志和命名空间镜像文件，并且会在namenode发生故障时启用。</li><li>活动-备用namenode，当活动namenode失效，备用namenode会接管它的任务并开始接收客户端的请求，不会有明显中断（实现namenode的高可用）<ul><li>namenode之间需要通过高可用共享存储实现编辑日志的共享。当备用namenode接管工作之后，可以通读共享编辑日志直至末尾，以实现活动namenode的状态同步</li><li>datanode需要同时向两个namenode发送数据块处理报告，数据块的映射信息存储在namenode的内存中</li><li>辅助namenode的角色被备用namenode所包含，备用namenode为活动的namenode命名空间设置周期性检查点</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop存储系统</title>
      <link href="/2019/01/19/Hadoop%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/01/19/Hadoop%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Hadoop存储系统"><a href="#Hadoop存储系统" class="headerlink" title="Hadoop存储系统"></a>Hadoop存储系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="namenode"><a href="#namenode" class="headerlink" title="namenode"></a>namenode</h4><p>HDFS采用Master/Slave架构。NameNode是HDFS的Master架构，主要负责HDFS文件系统的管理工作，具体包括名称空间（namespace）管理，文件Block管理。NameNode提供的是始终被动接收服务的server，主要有三类协议接口</p><ul><li>ClientProtocol：提供给客户端用于访问NameNode</li><li>DataNodeProtocol：用于DataNode访问NameNode</li><li>NameNodeProtocol：用于NameNode之间的通信</li></ul><p>在HDFS中，一个文件被分成一个或多个Block，这些Block存储在DataNode集合中，NameNode负责管理文件Block的所有元数据信息，这些元数据信息主要包括</p><ul><li><p>“文件名”——&gt;“数据块”映射</p><p>保存在磁盘上进行持久化存储</p></li><li><p>“数据块”——&gt;“DataNode列表”映射</p><p>NameNode不保存该映射，该映射是DataNode上报给NameNode建立起来的</p></li></ul><p>NameNode执行文件系统的名称空间（namespace）操作，例如打开，关闭，重命名文件和目录，同时决定文件数据块到具体的DataNode节点的映射</p><p>Secondary NameNode ，主要是定时对NameNode的数据snapshots进行备份，降低NameNode崩溃之后导致数据丢失的风险，其所做的工作就是从NameNode获得fsimage和edits后将两者重新合并发给NameNode。既可以减轻NameNode的负担，又能安全备份，且一旦HDFS的Master架构失效，可以使用Secondary NameNode进行数据恢复。</p><h4 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h4><p>DataNode是负责存储数据的组件，一个数据块Block会在多个DataNode中进行冗余备份。为了减轻NameNode的负担，NameNode上并不永久保存哪个DataNode上有哪些数据块的信息，而是通过DataNode启动时的上报来更新NameNode上的映射表。</p><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p>HDFS的基本数据单元是块，当一个文件大小小于HDFS的块大小时，实际存储所占的大小并不占用一个块的大小。在创建Block时，NameNode服务器会给每个Block分配一个唯一不变的Block标识。</p><h3 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h3><h4 id="Master-Salve架构"><a href="#Master-Salve架构" class="headerlink" title="Master/Salve架构"></a>Master/Salve架构</h4><p>一个HDFS集群包括一个单独的Master节点和多个Slave节点服务器，一个单独的Master节点可能是单NameNode集群或者是双NameNode集群。</p><p><img src="HDFS%E6%9E%B6%E6%9E%84.png" alt=""></p><p>NameNode负责保存和管理所有的HDFS元数据，因此文件数据的读写是直接在DataNode上进行的。</p><h4 id="NameNode和Secondary-NameNode通信模型"><a href="#NameNode和Secondary-NameNode通信模型" class="headerlink" title="NameNode和Secondary NameNode通信模型"></a>NameNode和Secondary NameNode通信模型</h4><ul><li><p>fsimage </p><p> 它是在NameNode启动时对整个文件系统的快照</p></li><li><p>edit logs -</p><p>它是在NameNode启动后，对文件系统的改动序列</p></li></ul><p>NameNode将对文件系统的改动追加保存到本地文件系统上的一个日志文件edit logs。</p><p>NameNode启动时</p><ol><li>首先从一个映像文件（fsimage）中读取HDFS的状态</li><li>执行日志文件中的编辑操作</li><li>将新的HDFS状态写入fsimage中</li><li>使用一个空的edit logs文件开始正常操作</li></ol><p>NameNode只会在启动阶段才合并fsimage和edit logs，当时间长了日志文件会很大。</p><p>而Secondary NameNode会定期合并fsimage和edit logs日志，将edit logs日志文件大小控制在一个限度下，NameNode和Secondary NameNode通过HTTP协议通信。</p><h4 id="文件存取机制"><a href="#文件存取机制" class="headerlink" title="文件存取机制"></a>文件存取机制</h4><p>block、packet、chunk</p><ul><li><p>block<br>这个大家应该知道，文件上传前需要分块，这个块就是block，一般为128MB，当然你可以去改，不顾不推荐。因为块太小：寻址时间占比过高。块太大：Map任务数太少，作业执行速度变慢。它是最大的一个单位。</p></li><li><p>packet<br>packet是第二大的单位，它是client端向DataNode，或DataNode的PipLine之间传数据的基本单位，默认64KB。</p></li><li><p>chunk<br>chunk是最小的单位，它是client向DataNode，或DataNode的PipLine之间进行数据校验的基本单位，默认512Byte，因为用作校验，故每个chunk需要带有4Byte的校验位。所以实际每个chunk写入packet的大小为516Byte。由此可见真实数据与校验值数据的比值约为128 : 1。（即64*1024 / 512）</p></li></ul><p>读文件数据流</p><ol><li>client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。</li><li>就近挑选一台datanode服务器，请求建立输入流 。</li><li>DataNode向输入流中中写数据，以packet为单位来校验。</li><li>关闭输入流</li></ol><p><img src="HDFS%E8%AF%BB%E6%95%B0%E6%8D%AE.png" alt=""></p><ul><li><p>写文件数据流</p><ol><li>客户端向NameNode发出写文件请求。</li><li>检查是否已存在文件、检查权限。若通过检查，直接先将操作写入edit logs，并返回输出流对象。<br>（注：WAL，write ahead log，先写Log，再写内存，因为edit logs记录的是最新的HDFS客户端执行所有的写操作。如果后续真实写操作失败了，由于在真实写操作之前，操作就被写入edit logs中了，故edit logs中仍会有记录，我们不用担心后续client读不到相应的数据块，因为在第5步中DataNode收到块后会有一返回确认信息，若没写成功，发送端没收到确认信息，会一直重试，直到成功）</li><li>client端按128MB的块切分文件。<br>client将NameNode返回的分配的可写的DataNode列表和Data数据一同发送给最近的第一个DataNode节点，此后client端和NameNode分配的多个DataNode构成pipeline管道，client端向输出流对象中写数据。client每向第一个DataNode写入一个packet，这个packet便会直接在pipeline里传给第二个、第三个…DataNode。<br>（注：并不是写好一个块或一整个文件后才向后分发）</li><li>每个DataNode写完一个块后，会返回确认信息。<br>（注：并不是每写完一个packet后就返回确认信息，个人觉得因为packet中的每个chunk都携带校验信息，没必要每写一个就汇报一下，这样效率太慢。正确的做法是写完一个block块后，对校验信息进行汇总分析，就能得出是否有块写错的情况发生）</li><li>写完数据，关闭输输出流。</li><li>发送完成信号给NameNode。<br>（注：发送完成信号的时机取决于集群是强一致性还是最终一致性，强一致性则需要所有DataNode写完后才向NameNode汇报。最终一致性则其中任意一个DataNode写完后就能单独向NameNode汇报，HDFS一般情况下都是强调强一致性）</li></ol><p><img src="HDFS%E5%86%99%E6%95%B0%E6%8D%AE.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/01/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><strong>时间复杂度：</strong>$O(n^2)$</p><p><strong>方法：</strong>依次找到数组中第一小，第二小，第三小…的数，并放置在对应的位置上</p><p><strong>每次排序后的结果：</strong>每次将未排序的数中的最小值排到正确的位置上</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> position <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到未排序的数中最小的数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span><span class="token punctuation">{</span>                min <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                position <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将找到的数放置在对应位置</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>        num<span class="token punctuation">[</span>position<span class="token punctuation">]</span> <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>时间复杂度：</strong>$O(n^2)$</p><p><strong>方法：</strong>当前的数与后一个数比较，如果比后面小，互换位置继续比较；如果比后面大，则用后面的代替该数继续比较</p><p><strong>每次排序后的结果：</strong>每次将未排序的数中的最大数放置在对应的位置</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> len <span class="token operator">=</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">int</span> max <span class="token operator">=</span> num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//每次选定第一个数，每一轮后第（len-i）排好序</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果后面小，不用变动数据位置，直接将下一个设置为最大</span>                  max <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果比后面大，则交换位置</span>                  num<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                  num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> num<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><strong>时间复杂度：</strong>$ O(n^2) $</p><p><strong>方法：</strong>选定一个数，向前比较，将它插入到比它大的数之前</p><p><strong>每次排序后的结果：</strong>放置好之后的数（包括该数）之前有序，即形成局部有序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sortNum <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//排第i个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>sortNum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 将比他大的数换一下位置</span>                num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sortNum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>时间复杂度：</strong>$O(n * logn)$</p><p><strong>方法：</strong>选定一个数，然后从前向后指针找比该数大的数，从后向前指针找比该数小的数，再交换这两个数，直到从前向后的坐标大于从后向前的坐标，之后再将选定的数与从前向后的最后指向的数交换位置，迭代进行</p><p><strong>每次排序后的结果：</strong>将选定的数排在正确的位置，左边全是比它小的数，右边全是比它大的数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//num为待排序的数组，left为左边界，right为右边界，每次选定数组的最左边的元素为待排元素</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sortNum <span class="token operator">=</span> num<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span>right<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//找比选定的数大的数</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">&amp;&amp;</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>sortNum<span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找比选定的数小的数</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">&amp;&amp;</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>sortNum<span class="token punctuation">)</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//交换</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//交换选定元素sortNum和最后left指定的数</span>    num<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sortNum<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分别对前半部分，后半部分排序，迭代</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>left<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">></span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>时间复杂度：</strong>$O(n*logn)$</p><p><strong>方法：</strong>自低向上，不断合并每个小有序数据，最后形成最终有序</p><p><strong>每次排序后的结果：</strong>每个小有序数据合并成大的有序数列</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergerSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//只有一个元素时直接返回</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">==</span> left<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> answer <span class="token operator">=</span> <span class="token punctuation">{</span>num<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> answer<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> answer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftNum<span class="token punctuation">;</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightNum<span class="token punctuation">;</span>     <span class="token keyword">int</span> leftMid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>left<span class="token operator">+</span>mid<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> rightMid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>right<span class="token operator">+</span>mid<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     leftNum <span class="token operator">=</span> <span class="token function">mergerSort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>left<span class="token punctuation">,</span>leftMid<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>     rightNum <span class="token operator">=</span> <span class="token function">mergerSort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>rightMid<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//合并</span>     <span class="token keyword">int</span> leftLen <span class="token operator">=</span> leftNum<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token keyword">int</span> rightLen <span class="token operator">=</span> rightNum<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>leftLen <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>rightLen<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>leftNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>rightNum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             answer<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftNum<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>leftNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>rightNum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             answer<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightNum<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>leftLen<span class="token punctuation">)</span><span class="token punctuation">{</span>         answer<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftNum<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">&lt;</span>rightLen<span class="token punctuation">)</span><span class="token punctuation">{</span>         answer<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightNum<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> answer<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase数据模型</title>
      <link href="/2019/01/15/Hbase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/01/15/Hbase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Hbase很适合存储不确定列，不确定大小的半结构化数据</p><h2 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h2><p>Hbase是一个键值（key-value）型数据库。Hbase数据行列值可以是空白的，且这些空白行列值不占用存储空间，所以Hbase存储的数据是稀疏的。</p><ul><li><p>表（table）：类似于关系型数据库中的表，即数据行的集合。一个表可以包含一个或者多个分区（region）</p></li><li><p>行键（row key）：用来标识表中唯一的一行数据，类似于关系型数据库中表的主键（不同的是从底层储存来说，行键不能唯一标识一行数据，因为Hbase数据行可以有多个版本，版本用时间戳表示），表中的数据按行键的字典序排序</p></li><li><p>列族（column family）：<strong>Hbase是一个列式存储数据库</strong>，所谓的列式就是根据列族存储，每个列族有一个存储仓库（Store），每个Store有一个内存仓库（MemStore）和多个存储文件（StoreFile）</p></li><li><p>列限定符（column qualifier）：每个列族可以有任意个列限定符用来标识不同的列，这个列类似于关系型数据库中的一列，不同的是，列可以在表创建时不指定，在需要使用时动态插入</p></li><li><p>单元格（cell）：由<strong>行键，列族，列限定符，时间戳，类型</strong>唯一决定，是Hbase数据的存储单元，以字节码的形式存储</p></li><li><p>版本（version）：Hbase数据写入后无法被修改的，数据的PUT操作在写入预写入日志（write-ahead-log）（类似于redo log）后，先写入内存仓库（MemStore），同时在内存中按行键排序，最后再将MemStore中的数据刷新到磁盘的StoreFile文件。因为数据已经排序，所以只需要顺序写入磁盘，这样的顺序写入对磁盘来说效率很高。由于数据不会被修改，因此数据会有多个版本，这些数据都会有一个时间戳用来标识数据写入的时间</p></li><li><p>分区（region）：Hbase的分区时集群中高可用，动态扩展，负载均衡的最小单元。</p></li></ul><p>例如表</p><p><img src="%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt=""></p><ul><li>行键可以定位到一行数据</li><li>列族用来定位到列族文件</li><li>列限定符定位到数据的某一列即某个键值对</li><li>时间戳定位到键值对的某一个时间版本数据</li></ul><h2 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h2><p>Hbase是一个列式存储数据库，数据按照列族聚簇存储再存储文件中，空白的列单元不会被存储。</p><ol><li>HBase中表按照行键的范围被划分为不同的分区，各个分区由分区服务器负责管理并提供数据读写服务，HBase主节点进程（HMaster）负责分区的分配以及在集群中的集群</li><li>一个分区同时有且仅有一个分区服务器提供服务，一个分区下的每个列族都会有一个存储仓库</li><li>每个Store（存储仓库）有且仅有一个MemStore（内存仓库），但是可以有多个存储文件，存储文件只会顺序写入，不支持修改</li><li>数据块（block）是Hbase中数据读取的最小单元，StoreFile由数据块组成，可以在建表时按列族指定表数据的数据块大小</li></ol><p>物理视图如下：</p><p><img src="%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BE.png" alt=""></p><p>HBase模块交互如下</p><p><img src="%E6%A8%A1%E5%9D%97%E4%BA%A4%E4%BA%92.png" alt=""></p><ul><li>HMaster：负责监控集群中所有的分区服务器进程（HRegionServer），负责所有数据的更新，负责分区在分区服务器中的负载均衡，在一个分布式环境中，HMaster进程通常与Hadoop的NameNode运行在同一个节点，每个集群中会部署至少两个HMaster节点，一个作为活跃节点提供服务，一个作为备用节点提供快速的灾备切换，保证集群高可用。</li><li>HRegionServer：管理其负责的分区，处理分区的读写请求，分区增大的拆分，以及分区的压缩。Hbase客户端对数据的读写直接与分区服务器交互，因此对分区的读写不会对HMater造成压力。HRegionServer通常与Hadoop的DataNode运行在一个节点，这样对数据的读写可以尽量做到本地读取，减少网络请求。</li><li>WAL：默认情况下一个分区服务器仅有一个WAL，Hbase客户端数据请求操作会先写入WAL文件再写入内存仓库MemStore，当MemStore到达配置大小或者集群中所有MemStore使用的总内存达到配置的阈值百分比时，MemStore会刷新一个StoreFile到磁盘。当服务器宕机时，可以用WAL来恢复分区服务器的状态。</li><li>MemStore：MemStore位于分区服务器的堆内存，数据再写入MemStore时候会按行键的字典序排序，Mem作为一个内存级缓存，能够提供对新写入数据的快速访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase模式设计实例</title>
      <link href="/2019/01/15/Hbase%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/01/15/Hbase%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="用户行为日志系统"><a href="#用户行为日志系统" class="headerlink" title="用户行为日志系统"></a>用户行为日志系统</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p><strong>数据类型</strong></p><ul><li>用户商品浏览记录</li><li>用户商品下单记录</li></ul><p><strong>统计需求</strong></p><ul><li>需要查询同一个用户一段时间内浏览过的商品，用来做用户商品推荐以提高转化率</li><li>需要统计某个商品在某天的转化率，用来分析各渠道或者营销方式的优劣</li></ul><p><strong>数据特征</strong></p><ul><li>数据一旦写入就不会被修改</li><li>越旧的数据使用越少，越新的数据使用越多</li><li>数据通常需要被大批量读取用作分析</li></ul><h3 id="行键设计"><a href="#行键设计" class="headerlink" title="行键设计"></a>行键设计</h3><h4 id="两个需求"><a href="#两个需求" class="headerlink" title="两个需求"></a>两个需求</h4><p><strong>查询同一个用户一段时间内浏览过的商品</strong></p><p>该需求有两个数据查询维度，第一个为用户，第二个为时间。</p><ul><li>为了提高查询性能，将同一个用户的数据聚簇地放在一起，因此将用户ID作为行键地开始</li><li>需要根据时间查询，类似Mysql中的聚集索引，可以将时间放在第二个位置，格式为：[用户ID]_[时间戳]</li><li>假设极端情况，用户同时打开多个商品，这些商品的时间戳可能相同，可以在行键最后加上一个序列号</li></ul><p>最后设计的行键：[用户ID]_ [时间戳]_[序列号]</p><p><strong>统计某个商品某天的专户率</strong></p><p>转化率的定义是商品下单数除以商品浏览数，需要三个维度的数据，第一个是商品，第二个是数据类型（0表示浏览，1表示记录），第三个是时间。</p><p>根据上一个例子，该行键可以设计为：[商品ID] _[数据类型] _[时间戳] _[序列号]</p><h4 id="行键与二级索引"><a href="#行键与二级索引" class="headerlink" title="行键与二级索引"></a>行键与二级索引</h4><p>如果一张表同时满足以上两个需求，可以考虑在用户维度构建行键存储数据，按商品维度建立二级索引满足商品维度统计需求。如下：</p><p><img src="%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E8%A1%A8.png" alt=""></p><p>行键1：[用户ID]_ [时间戳]_ [序列号]，例如12345_1510720956000_1</p><p>行键2：[分区开始键]_ [索引名称] _[商品ID] _[数据类型] _[时间戳] _ [数据行键]，该行键是一个二级索引</p><ul><li>使用分区开始键作为行键的前缀是为了让索引和数据在同一个分区，这样读取索引和数据的请求会落在同一个分区服务器，否则可能需要在一个分区服务器读取索引后，再到另一个分区服务器读取数据</li><li>索引名称，就是给这个二级索引起一个名字</li><li>数据行键，指得是行键1，相当于就是二级索引。行键2过滤数据后再定位到行键1，再读取数据，多级索引</li><li>二级索引，一般会根据索引行键得到数据行键，再根据数据行键去查询数据</li></ul><p><strong>读取数据示例</strong></p><ul><li><p><strong>查询同一个用户一段时间内浏览过的商品</strong></p><p>扫描请求只需要指定该用户的最小行键和最大行键。例如，用户查询用户12345从2017年12月1日到2018年1月1日之间的浏览记录，只需要指定查询区间[12345_ 1512086400000，12345_1514764800000]</p></li><li><p><strong>统计某个商品某天的专户率</strong></p><p>利用二级索引查询。例如，查询2018年1月1日当天的1001的转化率，需要扫描的区间为[12345_idx1_1001_0_151476400000, 12345_idx1_1001_1_1514851200000]，并且只需要扫描索引索引行键，拿到所有的索引行键再根据数据类型过滤即可。</p></li></ul><h2 id="微信朋友圈"><a href="#微信朋友圈" class="headerlink" title="微信朋友圈"></a>微信朋友圈</h2><p>朋友圈的核心是每个用户各自拥有一个自己发布的相册和一个用户关注的好友的动态，称之为时间线。</p><p>假如：A发朋友圈，B是A的好友，B刷新朋友圈刷到A干刚刚发布的内容</p><ul><li>A发布一张朋友圈图片，该图片会上传到A最近的CDN缓存服务器，上传成功后返回一个图片引用地址</li><li>A的微信客户端将朋友圈的内容以及图片引用地址发布到微信服务器自己的相册</li><li>查找那些用户关注了A，将A发布的朋友圈内容以及图片插入到这些用户的TimeLine（时间线）</li><li>B刷新自己的朋友圈，直接从B的时间线表查询数据即可</li></ul><p>上诉过程一共设计到四张表的设计</p><ul><li><p>user表，记录用户ID与微信昵称的对应关系</p><p><img src="%E7%94%A8%E6%88%B7%E8%A1%A8.png" alt=""></p></li><li><p>好友表，记录用户之间是否关注</p><p>可以使用高表或者宽表记录，该表只能查询关注的用户，查询关注自己的用户，需要构建另一张与此类似的表</p><ul><li><p>宽表，用户ID为行键，一行的数据为该用户关注的所有用户</p><p><img src="%E7%94%A8%E6%88%B7%E5%85%B3%E7%B3%BB%E8%A1%A8-%E5%AE%BD%E8%A1%A8.png" alt=""></p></li><li><p>高表，用户ID和关注的用户混合行键</p><p><img src="%E7%94%A8%E6%88%B7%E5%85%B3%E7%B3%BB%E8%A1%A8-%E9%AB%98%E8%A1%A8.png" alt=""></p></li></ul></li><li><p>用户朋友圈表，记录用户发布的朋友圈内容</p><p><img src="%E7%94%A8%E6%88%B7%E6%9C%8B%E5%8F%8B%E5%9C%88.png" alt=""></p><ul><li>行键：用户ID_时间戳</li><li>t：朋友圈内容</li><li>p：图片链接</li></ul></li><li><p>用户时间线表，记录关注的好友发布的朋友圈内容</p><p><img src="%E6%97%B6%E9%97%B4%E7%BA%BF.png" alt=""></p><ul><li>行键：用户ID_时间戳 _发布者ID</li><li>t：朋友圈内容</li><li>p：图片链接</li><li>u：发布者个人基本信息（昵称头像）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaAgent</title>
      <link href="/2019/01/15/JavaAgent/"/>
      <url>/2019/01/15/JavaAgent/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="RASP简介"><a href="#RASP简介" class="headerlink" title="RASP简介"></a>RASP简介</h3><p>目前主流的Web应用安全防护产品方案较多的是 WAF(Web Application Firewall)和RASP(Runtime Application Self-Protection)。</p><p>WAF</p><ul><li>WAF是门卫模型，通常部署在Web应用系统的外部边界，所有正常或恶意流量都需要通过特征规则和模式识别，通过特定的规则和模式识别出恶意请求，并且把它们拒之门外，拒绝向高风险的Web请求提供服务。</li><li>WAF虽然可以有效个过滤出绝大多数恶意请求，但是不知道应用运行时的上下文，必然会造成一定程度的误报。并且WAF严重依赖于特征库，各种花式绕过，导致特征编写很难以不变应万变。</li></ul><p>RASP</p><ul><li>RASP的不同就在于运行在应用之中，RASP代码与应用代码融为一体，可以获取到应用运行时的上下文行为，根据运行时上下文或者敏感行为操作，对攻击进行精准的识别或拦截。</li><li>RASP运行在应用之中，只要检测点选取合理，获取到的payload已经是解码过的真实payload，可以减少由于WAF规则的不完善导致的漏报。</li></ul><h3 id="RASP实现"><a href="#RASP实现" class="headerlink" title="RASP实现"></a>RASP实现</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Java版的RASP技术使用Javaagent实现。在启动服务器时，利用javaagent参数可以动态修改Java字节码，对敏感函数进行监测。比如数据库操作，文件读取，命令执行等等函数。当服务器被攻击时，RASP会通过检测函数的参数，并对其进行识别判断最后做出拦截或者上传报警等操作。</p><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ul><li>启动时首先会进入Javaaagent的premain函数，该函数在main函数执行之前执行</li><li>javaagent通过字节码修改工具可以修改应用中的函数对其进行监测</li></ul><h2 id="Instrumentation技术"><a href="#Instrumentation技术" class="headerlink" title="Instrumentation技术"></a>Instrumentation技术</h2><p>RASP需要使用到Java Instrument技术。使用Instrument，开发者可以构建一个独立于应用程序的代理（Agent）程序，用来协助或监测在JVM上运行上的程序，也可以替换或修改某些类的定义，这种特性提供了虚拟机级别的AOP实现。</p><p>让Instrument代理在main函数运行前执行，需要如下几个步骤</p><ul><li><p>编写premain函数</p><p>编写一个java类，包含如下两个方法中的任何一个</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">,</span> Instrumentation instrument<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre><p>agentArgs 是 premain 函数得到的程序参数，随同 “<code>– javaagent</code>”一起传入。</p><p>instrument是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。</p><p>在这个premain函数中，可以定义各种对类的操作。</p></li><li><p>jar文件打包</p><p>将带有premain函数的类打包成一个jar文件，并在其中的 manifest 属性当中加入” Premain-Class”来指定步骤 1 当中编写的那个带有 premain 的 Java 类。</p></li><li><p>运行</p><p>利用javaagent参数运行随应用程序运行jar包</p><pre class=" language-java"><code class="language-java">java <span class="token operator">-</span>javaagent<span class="token operator">:</span>jar文件的位置 <span class="token punctuation">[</span><span class="token operator">=</span> 传入 premain 的参数 <span class="token punctuation">]</span></code></pre></li></ul><p>Instrument的主要方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Instrumentation</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 注册一个Transformer，从此之后的类加载都会被 transformer 拦截。     * ClassFileTransformer 的 transform 方法可以直接对类的字节码进行修改，但是只能修改方法体，不能变更方法签名、增加和删除方法/类的成员属性     */</span>    <span class="token keyword">void</span> <span class="token function">addTransformer</span><span class="token punctuation">(</span>ClassFileTransformer transformer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 对JVM已经加载的类重新触发类加载，使用上面注册的 ClassFileTransformer 重新对类进行修饰。     */</span>    <span class="token keyword">void</span> <span class="token function">retransformClasses</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> classes<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnmodifiableClassException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 重新定义类，不是使用 transformer 修饰，而是把处理结果(bytecode)直接给JVM。     * 调用此方法同样只能修改方法体，不能变更方法签名、增加和删除方法/类的成员属性     */</span>    <span class="token keyword">void</span> <span class="token function">redefineClasses</span><span class="token punctuation">(</span>ClassDefinition<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> definitions<span class="token punctuation">)</span> <span class="token keyword">throws</span>  ClassNotFoundException<span class="token punctuation">,</span> UnmodifiableClassException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取一个对象的大小     */</span>    <span class="token keyword">long</span> <span class="token function">getObjectSize</span><span class="token punctuation">(</span>Object objectToSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 将一个jar加入到bootstrap classloader 的 classpath 里     */</span>    <span class="token keyword">void</span> <span class="token function">appendToBootstrapClassLoaderSearch</span><span class="token punctuation">(</span>JarFile jarfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 将一个jar加入到 system classloader 的 classpath 里     */</span>    <span class="token keyword">void</span> <span class="token function">appendToSystemClassLoaderSearch</span><span class="token punctuation">(</span>JarFile jarfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取当前被JVM加载的所有类对象     */</span>    Class<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAllLoadedClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="动态字节码技术"><a href="#动态字节码技术" class="headerlink" title="动态字节码技术"></a>动态字节码技术</h2><p>javassist是一个开源的分析、编辑和创建java字节码的类库。Javassist 中最为重要的是 ClassPool，CtClass ，CtMethod 以及 CtField 这几个类。</p><ul><li><p>ClassPool：一个基于 Hashtable 实现的 CtClass 对象容器，其中键是类名称，值是表示该类的 CtClass 对象。</p></li><li><p>CtClass：CtClass 表示类，一个 CtClass (编译时类）对象可以处理一个 class 文件，这些 CtClass 对象可以从 ClassPool 获得。</p></li><li><p>CtMethods：表示类中的方法。</p></li><li><p>CtFields ：表示类中的字段。</p></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Agent程序"><a href="#Agent程序" class="headerlink" title="Agent程序"></a>Agent程序</h3><p>带有premain函数的类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>Instrumentation<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">,</span> Instrumentation instrumentation<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        <span class="token function">Agent</span><span class="token punctuation">(</span>agentArgs<span class="token punctuation">,</span>instrumentation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Agent</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">,</span> Instrumentation instrumentation<span class="token punctuation">)</span><span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Agent atguments:"</span><span class="token operator">+</span>agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>        JavassistTransformer transformer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JavassistTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要修改的类</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"test.Target"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            instrumentation<span class="token punctuation">.</span><span class="token function">addTransformer</span><span class="token punctuation">(</span>transformer<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            instrumentation<span class="token punctuation">.</span><span class="token function">retransformClasses</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            instrumentation<span class="token punctuation">.</span><span class="token function">removeTransformer</span><span class="token punctuation">(</span>transformer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实现ClassFileTransformer接口的类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>ClassPool<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>CtClass<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>CtMethod<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>ClassFileTransformer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>IllegalClassFormatException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ProtectionDomain<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavassistTransformer</span> <span class="token keyword">implements</span> <span class="token class-name">ClassFileTransformer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transform</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> String className<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> classBeingRedefined<span class="token punctuation">,</span>                            ProtectionDomain protectionDomain<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classfileBuffer<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalClassFormatException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取全部的CtClass对象</span>            ClassPool cp <span class="token operator">=</span> ClassPool<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//获取对应的类</span>            CtClass ctClass <span class="token operator">=</span> cp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classBeingRedefined<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//需要修改的方法</span>            CtMethod ctMethod <span class="token operator">=</span> ctClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//在方法执行之前之后加入两个输出语句</span>            ctMethod<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token string">"System.out.println(\"Before say hello.\");"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ctMethod<span class="token punctuation">.</span><span class="token function">insertAfter</span><span class="token punctuation">(</span><span class="token string">"System.out.println(\"After say hello.\");"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> ctClass<span class="token punctuation">.</span><span class="token function">toBytecode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ctClass<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> classData<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> classfileBuffer<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>pom.xml打包文件</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>agent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdk.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdk.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaassist.version</span><span class="token punctuation">></span></span>3.21.0-GA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaassist.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${javaassist.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fork</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fork</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>${jdk.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>${jdk.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-resources-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>useDefaultDelimiters</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>useDefaultDelimiters</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>overwrite</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>overwrite</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delimiters</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delimiter</span><span class="token punctuation">></span></span>@<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delimiter</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delimiters</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-jar-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestFile</span><span class="token punctuation">></span></span>src/main/resources/META-INF/MANIFEST.MF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestFile</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-assembly-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appendAssemblyId</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appendAssemblyId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRefs</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRef</span><span class="token punctuation">></span></span>jar-with-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRef</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRefs</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestFile</span><span class="token punctuation">></span></span>src/main/resources/META-INF/MANIFEST.MF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestFile</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>make-assembly-package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>single<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>打包配置文件MANIFEST.MF</p><pre><code>Premain-Class: com.test.AgentDemoCan-Retransform-Classes: true</code></pre><h3 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h3><p>启动类（带main函数）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Target</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Target类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>类启动配置(IntelliJ在VM option中配置)</p><pre><code>-javaagent:C:/Users/10920/Downloads/Program/Java/AgentDemo/target/agent-1.0-SNAPSHOT.jar=&quot;I am agent arguments&quot;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1426685" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1426685</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html</a></p><p><a href="https://www.cnblogs.com/chiangchou/p/javassist.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiangchou/p/javassist.html</a></p><p><a href="https://blog.csdn.net/helowken2/article/details/103110368" target="_blank" rel="noopener">https://blog.csdn.net/helowken2/article/details/103110368</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读扩散写扩散</title>
      <link href="/2019/01/15/%E8%AF%BB%E6%89%A9%E6%95%A3%E5%86%99%E6%89%A9%E6%95%A3/"/>
      <url>/2019/01/15/%E8%AF%BB%E6%89%A9%E6%95%A3%E5%86%99%E6%89%A9%E6%95%A3/</url>
      
        <content type="html"><![CDATA[<p>在阅读HBase入门与实践这本书时，模式设计模块有一部分内容写到，微信朋友圈运用写扩散模型提高读的效率，即将一个用户发的朋友圈同步到该用户好友的时间线中。这次找到资料，稍微了解了解读扩散与写扩散。</p><h2 id="读扩散-VS-写扩散"><a href="#读扩散-VS-写扩散" class="headerlink" title="读扩散 VS 写扩散"></a>读扩散 VS 写扩散</h2><p>消息同步模型中，有写扩散和读扩散两种模型，讨论这两种模型涉及下面两个相关概念</p><ul><li>收件箱：该用户收到的消息</li><li>发件箱：该用户发出的消息</li></ul><h3 id="写扩散"><a href="#写扩散" class="headerlink" title="写扩散"></a>写扩散</h3><p>写扩散就是push模式，即每个消息都直接发送到该用户的收件箱中。</p><ul><li>优点：读优化，用户每次只需要去读取自己收件箱的消息即可</li><li>缺点：写很重，如果一条消息是群发消息，那么一个群成员发送出去的消息将拷贝到所有其余群成员的收件箱中</li></ul><p>朋友圈系统也是如此，将一个用户发的朋友圈内容同步到其所有好友的时间线中，当其好友刷新朋友圈时，直接到其好友的时间线中读取消息即可。</p><p><img src="%E5%86%99%E6%89%A9%E6%95%A3.png" alt=""></p><h3 id="读扩散"><a href="#读扩散" class="headerlink" title="读扩散"></a>读扩散</h3><p>读扩散就是pull模式，用户每次到消息发送者的发件箱去拉取信息</p><ul><li>优点：写优化，每次发送的消息只需要写到一个地方，由收件者自己拉取消息即可</li><li>缺点：读操作很重，假设用户重新登陆，要去其全部好友的发件箱读取消息</li></ul><p><img src="%E8%AF%BB%E6%89%A9%E6%95%A3.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.codedump.info/post/20190608-im-msg-storage/" target="_blank" rel="noopener">https://www.codedump.info/post/20190608-im-msg-storage/</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域</title>
      <link href="/2019/01/13/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/01/13/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>JDK7的内存区域如下</p><ul><li>线程私有：虚拟机栈，本地方法栈，程序计数器</li><li>线程共享：堆内存，方法区</li></ul><p><img src="java7%E5%86%85%E5%AD%98.png" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>虚拟机中的程序计数器和计算机的程序计数器(PC)作用类似，可以看成当前线程所执行的字节码的行号指示器，用来记录下一条要执行的指令。</p><p>该区域没有规定任何OutMemeryError情况</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈用来描述<strong>java方法</strong>执行的内存模型，每个方法在执行的同时会创建一个栈帧。</p><p>栈帧中存放局部变量表，操作数栈，动态链接，方法出口</p><p>其中局部变量表存放编译器可知的各种数据类型，对象引用，returnAddress类型(执行下一条指令)，局部变量表所需要的内存空间在编译期间完成分配</p><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt=""></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆中存放所有的对象实例以及数组</p><p>堆内部也进行了分块划分，如下，这个划分会在垃圾回收时使用。</p><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86.png" alt=""></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区存储已被虚拟机加载的<strong>类信息</strong>，<strong>常量</strong>，<strong>静态常量</strong>，<strong>即时编译器编译的代码</strong>，该区域通常被称为“永久代”</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池时方法区的一部分，用于存放编译期生成的各种字面量和符号的引用</p><h3 id="jdk1-8的变化"><a href="#jdk1-8的变化" class="headerlink" title="jdk1.8的变化"></a>jdk1.8的变化</h3><ol><li>将方法区除运行时常量池部分移动到了直接内存</li><li>将运行时常量池部分移动到了堆中</li></ol><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt=""></p><h2 id="java的对象"><a href="#java的对象" class="headerlink" title="java的对象"></a>java的对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当虚拟机遇到一个new指令时</p><p><img src="java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.png" alt=""></p><ul><li><p>检查类是否已经加载</p><p>判断该类是否已被加载，解析，初始化，若没有的话，必须先执行类加载过程</p></li><li><p>为对象分配内存</p><p>对象所需要的内存大小在类加载完成之后便可完全确定。在类加载检查通过后，虚拟机将为对象分配内存。</p></li><li><p>初始化零值</p><p>内存分配完之后，虚拟机将分配到的内存空间都初始化为零值。这一步保证对象的实例字段在java代码中可以不赋初始值就可以直接使用，程序能访问这些字段的数据类型所对应的零值</p></li><li><p>对象头信息设置</p><p>虚拟机堆对对象进行必要的设置，例如对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码等等，这些信息都在对象头之中</p></li><li><p>执行init方法</p><p>最后一步即把对象按照程序员的意愿进行初始化</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机第二版》</p><p><a href="https://blog.csdn.net/bruce128/article/details/79357870" target="_blank" rel="noopener">https://blog.csdn.net/bruce128/article/details/79357870</a></p><p><a href="https://juejin.im/post/5a14de6751882555cc417df7" target="_blank" rel="noopener">https://juejin.im/post/5a14de6751882555cc417df7</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码阅读</title>
      <link href="/2019/01/12/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2019/01/12/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>Hashmap存储键值对，其根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，遍历顺序与插入顺序不一致。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。</p><p>特点</p><ul><li>根据键的hashcode值存储</li><li>hashmap通过Node&lt;K,V&gt;类型的table数组存储数据</li><li>hash冲突通过链表和红黑树解决，table数组中的元素指向链表或者红黑树</li><li>当链表长度大于8时，链表转为红黑树；当红黑树的节点个数少于6时，红黑树转为链表</li></ul><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>静态常量参数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认容量为16，hashmap的容量必须是2的正次幂</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">//最大容量，2^30</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//装载因子，用于判断是否需要扩容</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表转换为红黑树的阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红黑树转为链表的阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化。否则桶内元素太多时会扩容，而不是树形化。</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span></code></pre><p>属性参数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//hash桶，数组长度是2的整次幂</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//元素缓存set</span><span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//元素个数</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改次数，包括添加删除</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//扩容的阈值，当size大于threshold进行扩容</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//装载因子=(size/capacity),即所有元素比上桶的数量，默认0.75</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span></code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>hashmap一共提供了三个构造方法，这三个方法仅仅是将给一些参数复制，并没有初始化table数组，而等到放入第一个元素时，即调用put方法时，数组才会初始化，后面讲诉。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认的构造方法，默认的加载因子为0.75，该地方没有指定大小，会在resize()方法中指定默认大小</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all other fields defaulted</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定大小，使用默认的加载因子0.75</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定大小个装载因子</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设定装载因子</span>        <span class="token comment" spellcheck="true">/*这个地方比较迷，如下：          1. threshold是指扩容的阈值，当size大于threshold时，数据会扩容。          2. tableSize返回的是最小的大于等于initialCapacity的2的整次幂，例如，给定10，返回16          3. 根据threshold的定义，其threshold = table.length*loadFactor        */</span>        <span class="token comment" spellcheck="true">/*         *你会发现，threshold大于等于初始化的大小，比数组大小还大，根据其定义根本无法扩容。         *当debug到数组初始化时，会发现将threshold赋值给数组的大小         *这里threshold就是代表数组的长度，而随后threshold会根据长度*加载因子计算出        */</span>        <span class="token comment" spellcheck="true">/*          我自己的想法如下：          1. HashMap中没有表示数组长度的参数，获取数组长度通过table.length获取          2. 因为没有表示长度的参数，所以先使用threshold暂时表示数组的长度        */</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>HashMap中table数组长度是2的整次幂，通过如下实现</p><ul><li><p>初始化时，通过tableSizeFor()方法计算给定大小initialCapacity的最小的大于等于initialCapacity的2的整次幂，再通过threshold参数暂时表示数组长度。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//该方法实现：返回最小的大于等于输入参数cap的2的整次幂。</span><span class="token comment" spellcheck="true">//原理如下:</span><span class="token comment" spellcheck="true">/* 先来假设n的二进制为01xxx…xxx * 对n右移1位：001xx...xxx，再位或：011xx...xxx * 对n右移2为：00011...xxx，再位或：01111...xxx * 每一操作就是将1的个数翻倍 * 该算法就是将最高位的1后面的位全变为1。 * 最后再n+1就可以得到2的整次幂了 * * 而对于最开始的cap-1是针对cap本身就是2的整次幂这种特殊情况 * 例如：当给定16，即10000时，若不减1，先会得到11111，再加1，得到100000，为32，扩大二倍 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>给一个详细的例子：</p><p><img src="tableSizeFor.png" alt=""></p></li><li><p>在resize()方法中，每次扩容都会将数组长度扩大二倍</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>         threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>         <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>              oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//oldCap左移一位，即扩大二倍</span>         newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold，新的threshold为老的二倍</span> <span class="token punctuation">}</span></code></pre></li></ul><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>HashMap有几个非常重要的辅助方法，比如计算元素在table中位置的方法，即hash机制，以及每次table数组空间不够时要进行扩容时使用的扩容函数。</p><h4 id="hash机制"><a href="#hash机制" class="headerlink" title="hash机制"></a>hash机制</h4><p>hash机制主要是计算元素应该放在table数组哪一个位置，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1. 先去key的hashCode值，32位整数。</span><span class="token comment" spellcheck="true">//2. 将hashCode无符号右移，即将高16位放在低16位上</span><span class="token comment" spellcheck="true">//3. 将1和2的结果或，即hashCode的高16位与低16位或的结果放在低16位，高16位不变</span><span class="token comment" spellcheck="true">//4. 高16位与低16与的好处就是可以使用hashcode的所有特征，增加随机性，利于数据分散</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//无符号右移，左边部分总是以0填充，右边部分舍弃</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面是定位取数操作(选自put方法)，n表示数组的长度</span><span class="token comment" spellcheck="true">//位置结果为n减1再与hash值与，分析如下</span><span class="token comment" spellcheck="true">//1. n为2的整次幂，例如10000，减一之后为01111，设1的个数为x</span><span class="token comment" spellcheck="true">//2. (n-1)与hash与，即保持后x位不变，前(32-x)位全为0，而后x位的值表示的就是该元素的下标</span>tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span></code></pre><p>例如，一个值经过hash之后为<strong>10100101 11000100 00100101</strong>，当前长度为16，即n-1=15，所以有如下结果</p><pre><code>    10100101 11000100 00100101&amp;   00000000 00000000 00001111    //15----------------------------------    00000000 00000000 00000101    //高位全部归零，只保留末四位</code></pre><p>将数组长度设置为2的整次幂，当减1之后，得到的数就像一个掩码一样，取后面几位。</p><p>整体过程如下：</p><p><img src="hash%E6%9C%BA%E5%88%B6.png" alt="hash机制"></p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>扩容机制是非常重要的,其保证table长度始终是2的整次幂。</p><p>扩容函数除了将数组扩大二倍之外，在初始化数组中也会应用到。</p><p>在resize()函数中，会先创建一个扩容后的数组，然后再将原来的数据移动到新的数组中，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第一步是先计算新的数组长度和扩容阈值，这里分为三种情况</span>    <span class="token comment" spellcheck="true">//1. 已经初始化过数组，只需要将长度扩大二倍，扩容阈值扩大二倍，注意要检查是否超出最大的范围</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                 oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先将数据长度扩大二倍，再将扩容阈值扩大二倍</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//下面两种情况是还没有初始化数组，现在要先进行初始化</span>    <span class="token comment" spellcheck="true">// 2. 对于HashMap(int initialCapacity)，HashMap(int initialCapacity, float loadFactor)，这两种情况均指定了threshold,大小为2的整次幂，即代表数组的长度，现在将扩容阈值复制给数组长度</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>         newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//3. 对于默认情况，仅定义了loadFactor，初始化为默认大小，扩容阈值=数组长度*扩容因子</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//继续接情况2，2情况下只指明了数组大小，没有指明扩容阈值，下面计算扩容阈值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计算扩容阈值</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据新长度new出一个数组</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是第一次放元素，即oldTab为null，会直接返回新创建的数组</span>    <span class="token comment" spellcheck="true">//第二步，将老数组中的元素移动到新数组中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//获取老数组中的元素</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将老数组清空，垃圾回收</span>                <span class="token comment" spellcheck="true">//将老数组中元素移动到新数组也分为三种情况</span>                <span class="token comment" spellcheck="true">//1. 桶中只有一个元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">//计算在数组中的位置的方法和之前一样</span>                    <span class="token comment" spellcheck="true">//注意这里是新的数组的长度，在二进制表示上，相当于多了一位1，会有下面两种情况</span>                    <span class="token comment" spellcheck="true">//假设，之前数组长度为16（15=1111），现在为32（31=11111）</span>                    <span class="token comment" spellcheck="true">//（1）.当其hash值第5位为1，则在新位置比老位置多了oldCap的长度</span>                    <span class="token comment" spellcheck="true">//（2）.当其hash值第5位为0，则在老位置不变换</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//2. 桶中结构是红黑树</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//3. 桶中结构是链表</span>                    <span class="token comment" spellcheck="true">//和桶中只有一个元素的情况一样，判断多出来的一位是0还是1</span>                    <span class="token comment" spellcheck="true">/** 首先是先将老数组的元素分发到两个链表中                     *  多出的一位为0，将数据放在lohead，loTail链表中                     *  多出的一位为1，将数据放在hiHead，hiTail链表中                     */</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//链表中下一个位置</span>                        <span class="token comment" spellcheck="true">//将多出一位为0的数，放在头元素是loHead，尾元素是loTail的链表中</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//将多出的一位为1的数，放在头元素是hiHead，尾元素是hiTail的链表中</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//将上述的两个链表放在对应的桶中，并且不会改变数据的相对位置</span>                    <span class="token comment" spellcheck="true">//多出一位为0的，在原位置不动</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//多出一位为1的，新位置比原位置大了oldCap</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上诉判断新坐标过程如下：</p><p>扩容前长度为16，key1的坐标为5，key2的坐标为5</p><p>扩容后长度为32，key1的坐标为5，key2的坐标为21</p><p><img src="%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.png" alt=""></p><p>key2的变化如下：</p><p><img src="%E6%89%A9%E5%AE%B9%E7%BB%93%E6%9E%9C.png" alt=""></p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>常用的操作主要有添加，删除，查找这三种，这里也主要阅读了这三个方法的源码。</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//put方法会将要添加的数据添加到对应的桶中，而且table数组的初始化也放生在第一次添加数据时</span><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数组还未初始化，调用resize()方法，返回初始化的数组</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//下面开始存放元素，分为3种情况</span>    <span class="token comment" spellcheck="true">//1. 桶中没有任何元素，直接放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>         K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//仍然对应第一种情况，如果存在元素，key也相同，替换元素即可</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2. 桶中有元素，结构为红黑树</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//3. 桶中有元素，结构为链表</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//添加到链表尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果超过树形化的阈值，将链表转为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//找到key相同的值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//当找到key相同时，替换元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断是否需要扩容</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span>         null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">,</span> Object value<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> null<span class="token punctuation">,</span> e<span class="token punctuation">;</span>         K k<span class="token punctuation">;</span>         V v<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//删除分为三种情况，分两步</span>        <span class="token comment" spellcheck="true">//第一步先找到要删除的元素</span>        <span class="token comment" spellcheck="true">//1. 当桶中第一个即为删除元素时</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//2. 当桶中结构为红黑树时</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//3. 当桶中结构为链表时</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                         <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//第二步删除找到的元素，也是分为红黑树，链表，桶中第一个元素三种情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                             <span class="token punctuation">(</span>value <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">else</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">;</span>     K k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查找分为三种情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1. 桶中第一个元素即为查找的元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//2. 桶中结构为红黑树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//3. 桶中结构为链表</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u010983881/article/details/78637763" target="_blank" rel="noopener">https://blog.csdn.net/u010983881/article/details/78637763</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce工作机制与计算过程</title>
      <link href="/2019/01/12/MapReduce%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/01/12/MapReduce%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="MapReduce介绍"><a href="#MapReduce介绍" class="headerlink" title="MapReduce介绍"></a>MapReduce介绍</h2><p>Hadoop Map/Reduce是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上T级别的数据集。</p><p>一个Map/Reduce <em>作业（job）</em> 通常会把输入的数据集切分为若干独立的数据块，由 <em>map任务（task）</em>以完全并行的方式处理它们。框架会对map的输出先进行排序， 然后把结果输入给<em>reduce任务</em>。通常作业的输入和输出都会被存储在文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p><h2 id="MapReduce工作机制"><a href="#MapReduce工作机制" class="headerlink" title="MapReduce工作机制"></a>MapReduce工作机制</h2><p>可以在 Job 对象上面调用 submit() 方法或者 waitForCompletion() 方法来运行一个 MapReduce 作业。</p><p>一个MapReduce运行过程如下：</p><p><img src="MapReduce%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt=""></p><p>作业运行中涉及到5个实体：</p><ul><li>客户端，提交MapReduce作业</li><li>YARN资源管理器（resource manager），负责协调集群上计算i机资源的分配</li><li>YARN节点管理器（node manager），负责启动和监视集群中机器上的计算容器（container）</li><li>MapReduce的application master，负责协调运行MapReduce作业的任务。它和MapReduce任务在容器中运行</li><li>分布式文件系统</li></ul><h3 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h3><p>在 Job 对象上面调用 submit() 方法，在内部创建一个 JobSubmitter 实例，然后调用该实例的 submitJobInternal() 方法（上图步骤1）。如果使用waitForCompletion() 方法来进行提交作业，该方法每隔 1 秒轮询作业的进度，如果进度有所变化，将该进度报告给控制台（console）。<br>JobSubmitter 所实现作业提交过程如下：</p><ol><li>向资源管理器申请一个新应用ID （上图步骤二）</li><li>检查作业的输出说明。例如，如果没有指定输出目录或输出目录已经存在，作业不提交</li><li>计算作业的输入分片。如果分片无法计算，比如输入路径不存在作业不提交</li><li>将运行作业所需要的资源（包括作业JAR文件，配置文件等）复制到共享文件系统中一个以作业ID命名的目录下（上图步骤三）</li><li>调用资源管理器的submitApplication()提交作业（上图步骤四）</li></ol><h3 id="作业初始化"><a href="#作业初始化" class="headerlink" title="作业初始化"></a>作业初始化</h3><p>当资源管理器接受到 submitApplication() 方法的调用，它把请求递交给 YARN 调度器（scheduler）。调度器分配了一个容器（container），资源管理器在该容器中启动 application master 进程，该进程被节点管理器管理（上图步骤5a 和 5b）。</p><ol><li>application master通过创建多个薄记对象完成对作业的初始化，用以保持对作业进度的跟踪。（上图步骤6）</li><li>然后，application master将从共享文件系统的中获取客户端计算的输入分片。（上图步骤7）</li><li><strong>再对每一个分片创建一个map任务对象。</strong>任务ID也在此时分配。</li><li>最后，application master在任务运行之前，设置输出目录以及任务输出的临时工作空间</li></ol><h3 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h3><p>application master需要判断如何运行构成MapReduce作业的各个任务。如果作业很小，就选择和自己在同一个JVM上运行任务。否则应该为该作业的所有map任务和reduce任务向资源管理器请求容器（上图步骤8），首先Map任务发出请求，直到有5%的map任务已经完成时，reduce任务的请求才会发出。</p><p>reduce任务能够在集群任意位置运行，但是map任务有着数据本地化局限：</p><ul><li>理想情况下，任务的数据本地化，意味着任务在分片驻留的同一节点运行</li><li>任务可能是机架本地化，分片在同一机架而非同一节点上运行</li><li>还有可能是别的机架h获取所需数据</li></ul><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>  一旦资源调度器在一个特定的节点上为一个任务分配一个容器所需的资源，application master 通过连接节点管理器来启动这个容器(上图步骤9a 和9b)。任务通过一个主类为 YarnChild 的 Java 应用程序来执行。在它运行任务之前，它会将任务所需的资源本地化，包括作业配置，JAR 文件以及一些在分布式缓存中的文件(上图步骤10)。最后，它运行 map 或者 reduce 任务(上图步骤11)。</p><p>YarnChild 在一个指定的 JVM 中运行，所以任何用户自定义的 map 和 reduce 函数的 bugs（或者甚至在 YarnChild）都不会影响到节点管理器。</p><h3 id="进度和状态更新"><a href="#进度和状态更新" class="headerlink" title="进度和状态更新"></a>进度和状态更新</h3><p>MapReduce 作业是长时间运行的批处理作业（long-running batch jobs），运行时间从几十秒到几小时。由于可能运行时间很长，所以用户得到该作业的处理进度反馈是很重要的。</p><p>作业和任务都含有一个状态，包括运行状态、maps 和 reduces 的处理进度，作业计数器的值，以及一个状态消息或描述（可能在用户代码中设置）。这些状态会在作业的过程中改变。</p><p>当一个任务运行，它会保持进度的跟踪（就是任务完成的比例）。<strong>对于 map 任务，就是被处理的输入的比例</strong>。对于 reduce 任务，稍微复杂一点，但是系统任然能够估算已处理的 reduce 输入的比例。通过把整个过程分为三个部分，对应于 shuffle 的三个阶段。例如，如果一个任务运行 reducer 完成了一半的输入，该任务的进度就是 5/6，因为它已经完成了 copy 和 sort 阶段（1/3 each）以及 reduce 阶段完成了一半（1/6）。</p><blockquote><p><strong>MapReduce 的进度组成</strong><br> 进度不总是可测的，但是它告诉 Hadoop 一个任务在做的一些事情。例如，任务的写输出记录是有进度的，即使不能用总进度的百分比来表示进度报告非常重要（因为它自己也可能不知道到底有多少输出要写，也可能不知道需要写的总量）。</p><p>如下的操作构成了进度：</p><ul><li>读取输入记录（在 mapper 或者 reducer 中）。</li><li>写输出记录（在 mapper 或者 reducer 中）。</li><li>设置状态描述（由 Reporter 的或 TaskAttempContext 的 setStatus() 方法设置）。</li><li>计数器的增长（使用 Reporter 的 incrCounter() 方法 或者 Counter 的 increment() 方法）。</li><li>调用 Reporter 的或者 TaskAttemptContext 的 progress() 方法。</li></ul></blockquote><p>任务有一些计数器，它们在任务运行时记录各种事件，这些计数器要么是框架内置的，例如：已写入的map输出记录数，要么是用户自定义的。</p><p>当 map 或 reduce 任务运行时，子进程使用 umbilical 接口和父 application master 进行通信。任务每隔三秒钟通过 umbilical 接口报告其进度和状态（包括计数器）给 application master，application master会形成一个作业的聚合视图。</p><p>在作业执行的过程中，客户端每秒通过轮询 application master 获取最新的状态（间隔通过 mapreduce.client.progressmonitor.polinterval 设置）。客户端也可使用 Job 的 getStatus() 方法获取一个包含作业所有状态信息的 JobStatus 实例，过程如下：</p><p><img src="MapReduce%E7%8A%B6%E6%80%81.png" alt=""></p><h3 id="作业完成"><a href="#作业完成" class="headerlink" title="作业完成"></a>作业完成</h3><p>当 application master 接受到最后一个任务完成的通知，它改变该作业的状态为 “successful”。当 Job 对象轮询状态，它知道作业已经成功完成，所以它打印一条消息告诉用户以及从 waitForCompletion() 方法返回。此时，作业的统计信息和计数器被打印到控制台。</p><p>Application master 也可以发送一条 HTTP 作业通知，如果配置了的话。当客户端想要接受回调时，可以通过 mapreduce.job.end-notification.url 属性进行配置。</p><p>最后，当作业完成，application master 和作业容器清理他们的工作状态（所以中间输入会被删除），然后 OutputCommiter 的 commitJob() 方法被调用。作业的信息被作业历史服务器存档，以便日后用户查询。</p><h2 id="MapReduce计算过程"><a href="#MapReduce计算过程" class="headerlink" title="MapReduce计算过程"></a>MapReduce计算过程</h2><p>MapReduce通常由三个操作组成</p><ul><li>map操作：map操作是一类将输入记录集转换为中间格式记录集的独立任务，其应用于本地数据。</li><li>shuffle操作：工作节点根据输出键（由 map 函数生成）重新分配数据，对数据映射排序、分组、拷贝，目的是属于一个键的所有数据都位于同一个工作节点上。</li><li>reduce操作：Reduce操作将与一个key关联的一组中间数值集归约（reduce）为一个更小的数值集。</li></ul><p><img src="MapReduce%E6%B5%81%E7%A8%8B.png" alt=""></p><p>其中map阶段与reduce阶段之间的关系如下，而shuffle阶段就是将map输出的键相同的值汇聚在一起以供reduce处理</p><p><img src="Map%E4%B8%8EReduce%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt=""></p><p>整个计算过程：<strong>输入分片 —&gt; map阶段  —&gt; shuffle阶段 —&gt; reduce阶段</strong></p><h3 id="输入分片"><a href="#输入分片" class="headerlink" title="输入分片"></a>输入分片</h3><p>在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split），<strong>每个输入分片（input split）针对一个map任务</strong>，输入分片（input split）存储的并非数据本身，而是一个分片长度和一个记录数据的位置的数组。</p><p>对于不可分的文件，一个文件一个分片。</p><p>对于可分的文件会被分成不大于块大小的分片，例如文件大小为140M，会被分为128M+12M两个分片；文件大小为100M，则为100M大小的分片。因此，如果可以在运行MapReduce程序之前合并一些小文件对优化作业有很大帮助。</p><p>为什么默认分片大小和块大小相同？</p><pre><code>If the split spanned two blocks, it would be unlikely that any HDFS node stored both blocks</code></pre><p>即</p><pre><code>如果分片跨越了两个数据块，那么不太可能所有的 HDFS 节点都存储了分片中的两个数据块，（也就是意味着总会存在网络传输的情况）</code></pre><h3 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h3><p> Map在输入的数据中获取一个键值对，然后返回一个键值对的列表：</p><pre class=" language-java"><code class="language-java"><span class="token function">Map</span><span class="token punctuation">(</span>k1<span class="token punctuation">,</span>v1<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">list</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span>v2<span class="token punctuation">)</span></code></pre><p>Map函数会被并行调用，应用于输入数据集中的每个键值对（keyed by K1），然后每个调用返回一个键值对（keyed by K2）列表。</p><p>以计算词频为例，Map阶段如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 继承的Mapper类中 *    第一个参数：LongWritable是输入的键，此处表示一行的起始偏移量 *    第二个参数：Text是输入的值，此处表示一行的文本内容 *    第三个参数：Text是输出的键，此处表示每一个单词 *    第四个参数：IntWritable是输出的值，此处表示每个单词的数量都是1(不管重复不重复) */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token operator">&lt;</span>LongWritable<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> IntWritable<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * map方法是提供给map task进程来调用的，map task进程是每读取一行文本来调用一次自定义的map方法     * map task在调用map方法时，传递的参数：     *         一行的起始偏移量LongWritable作为key     *         一行的文本内容Text作为value     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span>LongWritable key<span class="token punctuation">,</span> Text value<span class="token punctuation">,</span>Context context<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//拿到一行文本内容，转换成String 类型</span>        String line <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将这行文本切分成单词</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token operator">=</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出&lt;单词，1></span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String word<span class="token operator">:</span>words<span class="token punctuation">)</span><span class="token punctuation">{</span>            context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Shuffle阶段"><a href="#Shuffle阶段" class="headerlink" title="Shuffle阶段"></a>Shuffle阶段</h3><p>shuffle阶段是承接map和reduce，其也可以分为map shuffle和reduce shuffle</p><h4 id="map-shuffle"><a href="#map-shuffle" class="headerlink" title="map shuffle"></a>map shuffle</h4><p>在Map端的shuffle过程是对Map的结果进行分区、排序、分割，然后将属于同一分区的输出合并在一起并写在磁盘上，最终得到一个分区有序的文件，分区有序的含义是map输出的键值对按分区进行排列，具有相同partition值的键值对存储在一起，每个分区里面的键值对又按key值进行升序排列（默认），其流程大致如下：</p><p><img src="MapShuffle.png" alt=""></p><h5 id="写缓存区"><a href="#写缓存区" class="headerlink" title="写缓存区"></a>写缓存区</h5><p>每个map任务都是有一个<strong>环形缓冲区</strong>的用于存储任务的输出。在默认情况下，缓冲区的大小为100MB，其值可以通过改变io.sort.mb来调整。一旦缓冲内容达到阈值(io.sort,spill,percent，默认是0.8)，一个后台线程会将内容spill到磁盘。在spill到磁盘的过程中，map输出并不会停止往缓冲区写入数据，但如果在此期间缓冲区被写满，map会被阻塞知道写磁盘过程完成。溢出写过程安装轮询方式将缓冲区的内容写到mapred.local.dir指定的作业特定子目录中的目录中。</p><h5 id="分区，排序，合并"><a href="#分区，排序，合并" class="headerlink" title="分区，排序，合并"></a>分区，排序，合并</h5><p>写磁盘之前，线程首先根据数据最终要传的reducer把数据划分成相应的分区。在每个分区中，后台线程按键在内存中排序，如果有一个combiner，它就在排序后的输出上运行。运行combinner使得map输出结果更紧凑，因此可以减少写到磁盘的数据和传递给reducer的数据。</p><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><p>每次内存缓冲区达到溢出阈值，就会新建一个溢出文件(spill file)，因此在map任务写完其最后一个输出记录之后，会有几个溢写文件。在任务完成之前，溢出文件被合并成一个已分区且已排序的输出文件。配置属性io.sort.factor控制着一次最多能合并多少流，默认是10。</p><p>如果至少存在3个溢出文件(通过min.num.spills.for.combine属性设置)时，<strong>则combiner就会在输出文件写到磁盘之前再次运行</strong>。combiner可以在输入上反复运行，单不影响最终的结果。如果只有一两个溢出文件，那么对map输出的减少不值得调用combiner，就不会为map输出再次运行combiner。</p><h5 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h5><p>在将压缩map输出写到磁盘的过程中对它进行压缩往往是个好主意，因为这样就会写磁盘的速度更快，更加节约时间，并且减少传给reducer的数据量。在默认情况下，输出是不压缩的，但是只要将mapred.compress.map.output设置为true，就可以启用这个功能。使用的压缩库由mapred.map.output.compression.codec指定。</p><p>Reducer是通过HTTP的方式得到输出文件的分区。</p><h4 id="reduce-shuffle"><a href="#reduce-shuffle" class="headerlink" title="reduce shuffle"></a>reduce shuffle</h4><p>集群中往往一个mr任务会有若干map任务和reduce任务，map任务运行有快有慢，reduce不可能等到所有的map任务都运行结束再启动，因此只要有一个任务完成，reduce任务就开始复制其输出。复制线程的数量由mapred.reduce.parallel.copies属性来改变，默认是 5。</p><blockquote><p>Reducer如何知道map输出的呢？</p><p>map任务完成之后，它们会使用心跳机制通知它们的application master。因此，对于指定作业，application master知道map输出和主机位置的映射关系。reducer中一个线程定期询问master以便获得map输出主机的位置，知道获得所有的输出。</p></blockquote><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>Reduce对map输出的不同大小也有相应的调优处理。如果map输出相当小，会被复制到reduce任务JVM的内存(缓冲区大小由mapred.job.shuffle.input.buffer.percent属性控制，指定用于此用途的堆空间的百分比)，否则，map输出会被复制到磁盘。一旦内存缓冲区达到阈值(由mapred.job.shuffle.merge.percent决定)或达到map的输出阈值(mapred.inmem.merge,threshold控制)，则合并后溢出写到磁盘中。如果指定combiner，则在合并期间运行它已降低写入磁盘的数据量。</p><p>随着磁盘上副本的增多，后台线程会将它们合并为更大的，排序好的文件。这会为后面的合并节省一些时间。注意，为了合并，压缩的map输出(通过map任务)都必须在内存中解压缩。</p><h5 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h5><p>复制完所有的map输出后，reduce任务进入排序阶段(更加恰当的说法是合并阶段，因为排序是在map端进行的)，这个阶段将合并map的输出，维持其顺序排序。这是循环进行的。比如，有50个map输出，而合并因子是10(默认值是10，由io.sort.factor属性设置，与map的合并类似)，合并将进行5趟。每趟将10个文件合并成一个文件，因此最后有5个中间文件。</p><p>在最后阶段，即reduce阶段，直接把数据输入reduce函数，从而省略了一次磁盘往返行程，并没有将这5个文件合并成一个已排序的文件最为最后一趟。最后的合并可以来自内存和磁盘片段。</p><p>每趟合并的文件数实际上比上面例子中展示的有所不同的。目标是合并最小数据量的文件以便满足最后一趟的合并系数。因此，如果有40个文件，我们不会再四趟中每趟合并10个文件而得到4个文件。相反，第一趟只合并4个文件，随后的三塘合并10个文件。最后一趟中，4个已经合并的文件和剩余的6个文件合计是个文件进行合并。如下图所述：</p><p>注意这并没有改变合并的次数，它只是一个优化措施，目的是尽量减少写到磁盘的数据量，因为最后一趟总是直接合并到reduce。</p><p>![](reduce shuffle.png)</p><h3 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h3><p>Reduce 是对一个列表的元素进行适当的合并，将map阶段的键值对处理成我们想要的结果</p><pre class=" language-java"><code class="language-java"><span class="token function">Reduce</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span> <span class="token function">list</span> <span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">list</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span></code></pre><p>以计算词频为例，Reduce阶段如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 继承的Reducer类中 *    第一个参数：Text是输入的键,和Map阶段的输出键一样，此处表示每个单词 *    第二个参数：IntWritable是输入的值，和Map阶段的输出值一样，此处表示每个单词的数量是1 *    第三个参数：Text是输出的键，此处表示不重复的单词 *    第四个参数：IntWritable是输出的值，此处表示每个单词的数量（不重复） */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token operator">&lt;</span>Text<span class="token punctuation">,</span> IntWritable<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> IntWritable<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">/*     * reduce方法提供给reduce task进程来调用     *      * reduce task会将shuffle阶段分发过来的大量kv数据对进行聚合，聚合的机制是相同key的kv对聚合为一组     * 然后reduce task对每一组聚合kv调用一次我们自定义的reduce方法     * 比如：&lt;hello,1>&lt;hello,1>&lt;hello,1>&lt;tom,1>&lt;tom,1>&lt;tom,1>     *  hello组会调用一次reduce方法进行处理，tom组也会调用一次reduce方法进行处理     *  调用时传递的参数：     *          key：一组kv中的key     *          values：一组kv中所有value的迭代器     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span>Text key<span class="token punctuation">,</span> Iterable<span class="token operator">&lt;</span>IntWritable<span class="token operator">></span> values<span class="token punctuation">,</span>Context context<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定义一个计数器</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过value这个迭代器，遍历这一组kv中所有的value，进行累加</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>IntWritable value<span class="token operator">:</span>values<span class="token punctuation">)</span><span class="token punctuation">{</span>            count<span class="token operator">+=</span>value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//输出这个单词的统计结果</span>        context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5bb59f87f265da0aeb7118f2" target="_blank" rel="noopener">https://juejin.im/post/5bb59f87f265da0aeb7118f2</a></p><p><a href="https://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/2019/01/12/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2019/01/12/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="是否垃圾回收"><a href="#是否垃圾回收" class="headerlink" title="是否垃圾回收"></a>是否垃圾回收</h2><h3 id="对象是否存活："><a href="#对象是否存活：" class="headerlink" title="对象是否存活："></a>对象是否存活：</h3><ul><li><p>引用计数法：给对象添加一个引用计数器，当被引用时加1，当引用失效时减1，当引用计数器为0时，表示该对象没有被引用。</p></li><li><p>可达性分析：以“GC Roots“为起点，并开始向下搜索，搜索所走的路径称为<strong>引用链</strong>，一个对线到GC Roots没有引用链时，则表示该对象不可用。</p><p>GC Roots:</p><ul><li>虚拟机栈（栈帧中本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul></li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>java将引用分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）</p><ul><li>强引用：类似<code>Object obj = new Object();</code>只要强引用存在，则该被引用对象永远不会被回收。</li><li>软引用：用来描述一些有用但并非必需的对象。在内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存，如果在回收还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用：也用来描述非必需对象的，它的强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾回收发生之前。</li><li>虚引用：是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是在这个对象被回收时收到一个系统通知。</li></ul><h3 id="被标记不可用即可删除？"><a href="#被标记不可用即可删除？" class="headerlink" title="被标记不可用即可删除？"></a>被标记不可用即可删除？</h3><p>一个对象死亡，至少要经历两次标记过程。</p><p>如果对象在进行可达性分析后发现没有与GC Roots相连的引用链，则它将被第一次标记并且进行一次筛选。筛选的条件是<strong>此对象是否有必要执行<code>finalize()</code>方法</strong></p><ul><li>如果对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，则认为没有必要执行<code>finalize()</code>方法，则直接回收该对象</li><li>如果覆盖了<code>finalize()</code>方法，那么对象会被放置在一个叫做<code>F-Queue</code>的队列之中。然后由一个虚拟机自动创建的，低优先级的Finalizer线程去执行它，该执行是指会触发该方法，当并不承诺等待它运行结束。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对<code>F-Queue</code>中的对象进行第二次标记。<ul><li>如果在<code>finalize()</code>方法中将该对象重新与引用链上任何一个对象建立关联，例如将自己（this）赋值给类变量或者对象的成员变量，则该对象即可不被清除</li><li>否则，如果该对象被标记为清除，则回收该对象</li></ul></li></ul><p><code>finalize()</code>方法特点：</p><ul><li>一个对象的<code>finalize()</code>方法最多会被系统自动调用一次</li><li>何时执行<ol><li>所有对象被Garbage Collection时自动调用,比如运行System.gc()的时候.</li><li>程序退出时为每个对象调用一次finalize方法。</li><li>显式的调用finalize方法</li></ol></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法："><a href="#标记-清除算法：" class="headerlink" title="标记-清除算法："></a>标记-清除算法：</h3><ul><li>思想：首先标记所有需要回收的对象，在标记完成之后统一回收所有标记对象。</li><li>特点：<ol><li>标记和清除两个过程效率都不高</li><li>标记清除之后会产生大量不连续的内存碎片</li></ol></li></ul><p><img src="%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt=""></p><h3 id="复制算法："><a href="#复制算法：" class="headerlink" title="复制算法："></a>复制算法：</h3><ul><li>思想：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li><li>特点：<ol><li>每次都对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li><li>将内存缩小为原来的一半，浪费空间。</li><li>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低</li><li>该回收方法用来收集新生代</li></ol></li></ul><p><img src="%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt=""></p><h3 id="标记-整理算法："><a href="#标记-整理算法：" class="headerlink" title="标记-整理算法："></a>标记-整理算法：</h3><ul><li>思想：首先标记所有需要回收的对象，然后让所有存活的对象都向一端移动，再直接清理掉端边界以外的内存</li><li>特点：<ol><li>适用于老年代回收</li></ol></li></ul><p><img src="%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9.png" alt=""></p><h3 id="分代回收："><a href="#分代回收：" class="headerlink" title="分代回收："></a>分代回收：</h3><ul><li>思想：把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，使用“标记-清理”或“标记-整理”算法来进行回收。</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是一个单线程收集器，它具有如下特点</p><ol><li>虚拟机运行在Client模式下默认的新生代收集器</li><li>它只会使用一个CPU或者一个线程完成垃圾收集工作，因此在单CPU环境下有最高的效率</li><li>它进行垃圾收集之前，必须暂停其他所有的工作线程（Stop the world），直到它收集结束</li><li>新生代使用复制算法，老年代采用标记-整理算法</li><li>参数控制：<ul><li><strong>-XX:+UseSerialGC</strong>  串行收集器</li></ul></li></ol><p><img src="Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器是Serial收集器的多线程版本，具有以下特点：</p><ol><li>用作运行在Server模式下的虚拟机的新生代收集器</li><li>使用多条线程进行垃圾收集</li><li>它进行垃圾收集之前，必须暂停其他所有的工作线程（Stop the world），直到它收集结束</li><li>新生代使用复制算法，老年代采用标记-整理算法</li><li>参数控制：<ul><li><strong>-XX:+UseParNewGC</strong>  ParNew收集器    </li><li><strong>-XX:ParallelGCThreads</strong> 限制线程数量</li></ul></li></ol><p><img src="ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个关注吞吐量（运行用户代码时间/（运行用户代码时间+垃圾收集时间））的垃圾收集器，具有以下特点：</p><ol><li>新生代收集器</li><li>并行的多线程收集器</li><li>新生代使用复制算法，老年代使用标记-压缩算法</li><li>具有“GC自适应的调节策略”：使用<code>-XX:+UseAdaptiveSizePolicy</code>参数，就不需要手动指定新生代大小，Eden与Survivor区的比例，今生老年代对象大小等细节参数。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量</li><li>参数控制：<ul><li><strong>-XX:+UseParallelGC</strong>  使用Parallel收集器+ 老年代串行。</li><li><strong>-XX:+MaxGCPauseMillis</strong>  控制最大垃圾收集停顿时间</li><li><strong>-XX:+GCTimeRatio</strong>  设置吞吐量大小</li></ul></li></ol><h3 id="Serial-Old收集器："><a href="#Serial-Old收集器：" class="headerlink" title="Serial Old收集器："></a>Serial Old收集器：</h3><p>Serial Old收集器是Serial收集器的老年代版本，具有如下特点：</p><ol><li><p>用作运行在Client模式下的虚拟机的老年代收集器</p></li><li><p>是一个单线程收集器</p></li><li><p>新生代使用复制算法，老年代使用标价-整理算法</p></li></ol><h3 id="Parallel-Old收集器："><a href="#Parallel-Old收集器：" class="headerlink" title="Parallel Old收集器："></a>Parallel Old收集器：</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，具有如下特点：</p><ol><li>适合用于注重吞吐量，以及CPU资源敏感的场合（使用Paraller Scanvenge+Parallel Old组合）</li><li>是一个多线程收集器</li><li>老年代使用标记-整理算法</li><li>参数控制<ul><li><strong>-XX:+UseParallelOldGC</strong> 使用Parallel收集器+ 老年代并行</li></ul></li></ol><h3 id="CMS收集器："><a href="#CMS收集器：" class="headerlink" title="CMS收集器："></a>CMS收集器：</h3><p>CMS是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，具有以下特点</p><ol><li><p>CMS适合应用在互联网网站或者B/S系统的服务端</p></li><li><p>CMS收集器是基于<strong>标记-清除</strong>算法实现的</p></li><li><p>收集过程有四个步骤</p><ul><li><strong>初始标记</strong><ul><li>需要Stop the World</li><li>只标记GC Roots直接关联到的对象，速度很快</li></ul></li><li><strong>并发标记</strong><ul><li>进行GC Roots Tracing</li><li>和用户程序一起运行</li></ul></li><li><strong>重新标记</strong><ul><li>需要Stop the World</li><li>修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</li></ul></li><li><strong>并发清除</strong><ul><li>和用户程序一起运行</li></ul></li></ul><p><img src="CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p></li></ol><p>CMS收集器有以下缺点</p><ul><li><p>CMS收集器对CPU资源非常敏感。因为回收线程和用户程序一起运行，会导致应用程序变慢，总吞吐量变低，应尽量减少回收线程独占CPU的时间</p></li><li><p>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致赢一次Full GC的产生。</p><ul><li>浮动垃圾是并发清除阶段产生的新垃圾</li><li>因为并发清除时，用户程序改在运行，因此需要给用户程序预留一定的内存空间，而不是像其他收集器一样等到老年代几乎用完再进行垃圾收集。如果预留的空间无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟器启动Serial Old收集器重新进行老年代的垃圾收集，这样停顿的时间就很长了。</li></ul></li><li><p>因为使用标记-清除算法，因此会出现碎片</p></li></ul><h3 id="G1收集器："><a href="#G1收集器：" class="headerlink" title="G1收集器："></a>G1收集器：</h3><p>G1收集器是目前技术发展的最前沿成果之一，具有以下特点</p><ol><li>G1是一款面向服务端应用的垃圾收集器</li><li>并行与并发：充分利用CPU缩短Stop The World的停顿时间，执行GC时可以让用户程序并发运行</li><li>分代收集</li><li>空间整合：使用标记-整理算法，因此不会产生碎片</li><li>可预测停顿：这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ol><p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，<strong>它将整个Java堆划分为多个大小相等的独立区域（Region）</strong>，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p><p>G1收集器的可预测的停顿时间模型：G1有计划的避免整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收空间+所需时间），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>G1收集器对全堆扫描的解决：Region之间的对象引用是使用Remembered Set来避免全堆扫描的，G1中每个Region都有一个与之对应的Remembered Set。</p><ol><li>虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作</li><li>检查Reference引用的对象是否处于不同的Region之中</li><li>如果存在不同的Region，便通过CardTable将相关引用信息记录到被引用对象所属的Remembered Set之中</li><li>当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描</li></ol><p>G1的流程如下：</p><ol><li>初始标记<ul><li>标记GC Roots直接关联到的对象</li><li>修改<strong>TAMS(Next Top at Mark Start)</strong>的值，让下一阶段用户程序并发时，能在正确的可用的Region中创建新对象，该阶段需要停顿线程，但耗时很短。</li></ul></li><li>并发标记<ul><li>从GC Roots开始对堆中对象进行可达性分析，可与用户程序并发执行</li></ul></li><li>最终标记<ul><li>修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变换记录在线程Remembered Set Logs里，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，该阶段需要停顿线程，但可并行执行</li></ul></li><li>筛选回收<ul><li>首先对各个Region的回收价值和成本进行排序</li><li>根据用户期望的GC挺短时间指定回收计划</li></ul></li></ol><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>java的自动内存管理解决了两个问题：给对象分配内存以及回收分配给对象的内存。</p><p>而对于对象分配，有如下一些规则，</p><p><img src="%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt=""></p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><blockquote><p>新生代的Minor GC复制算法</p><p>新生代采取复制算法，在Minor GC之前，to survivor区域保持清空，对象保存在Eden和from survivor区，minor GC运行时，Eden中的幸存对象会被复制到to Survivor（同时对象年龄会增加1）。而from survivor区中的幸存对象会考虑对象年龄，如果年龄没达到阈值，对象依然复制到to survivor中。如果对象达到阈值那么将被移到老年代。复制阶段完成后，Eden和From幸存区中只保存死对象，可以视为清空。如果在复制过程中to幸存区被填满了，剩余的对象将被放到老年代。最后，From survivor和to survivor会调换一下名字，下次Minor GC时，To survivor变为From Survivor。</p></blockquote><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象是指，需要大量连续内存空间的Java对象，最典序的大对象就是很长的字符串以及数组。</p><p>使用<code>-XX:PretenureSizeThreshold</code>参数，使大于这个值的对象直接在老年代分配，这样子可以避免在Eden和两个Survicor区之间发生大量的内存复制</p><h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>虚拟机给每个对象定义一个对象年龄计数器。<strong>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被survivor容纳的话，将被移动到survivor空间中，并且对象年龄设为1。对于在survivor区中每经过一个Minor GC，年龄就增加1岁，它的年龄增加到一定程度（默认15岁），就可以进入到老年代</strong>。</p><p>晋升到老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果在survivor空间中<strong>相同年龄</strong>所有对象大小的总和大于survivor空间的一半，年龄<strong>大于或等于该年龄的对象</strong>可以直接进入老年代。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong></p><ul><li>如果条件成立，那么Minor GC可以确保是安全的。</li><li>如果不成立，则虚拟机会查看HandlerPromotionFailure设置是否允许担保失败。<ul><li>如果允许，那么会继续检查<strong>老年代最大可用的连续空间</strong>是否大于<strong>历次晋升到老年代对象的平均大小</strong>。如果大于，将尝试着进行一次Monitor GC，尽管这次GC是有风险的。如果小于，或者HandlerPromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC了。</li></ul></li></ul><p>新生代复制算法只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况是内存回收之后，新生代中所有的对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象存活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p><p>取平均值进行比较其实是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现HandlerPromotionFailure失败，那就只好在失败后重新发起一次FULL GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是将HandlerPromotionFailure开关打开，避免Full GC过于频繁。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库分库分表</title>
      <link href="/2019/01/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2019/01/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p><strong>垂直拆分是将一个包含了很多表的数据库,根据表的功能的不同,拆分为多个小的数据库,每个库中包含部分表。</strong></p><p>比如大型的电商项目平台是由不同的子项目模块构成的如订单系统，账户系统，商品管理系统等等，这些个独立的模块都可以拆分成独立的服务与独立的数据库。</p><p>优点</p><ul><li>拆分后业务清晰，拆分规则明确。</li></ul><ol start="2"><li>系统之间整合或扩展容易。</li><li>数据维护简单。</li></ol><p>缺点</p><ul><li>存在单表数据量过大的问题（需要水平切分）</li><li>部分业务表无法join，只能通过接口方式解决，提高了系统复杂度</li></ul><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。<strong>水平切分分为库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。</strong></p><p>比如存放大量用户购物信息的购物表，可以按照下单时间拆分成多个表，每一个表就可以只存放少量的数据，再将这些表存在不同的数据库中，即可解决单库读写，存储性能瓶颈问题。</p><p>优点</p><ul><li>单表大小可控</li><li>便于扩展，如果要对集群扩容，只需要添加节点，无需对其他节点进行数据迁移</li></ul><p>缺点</p><ul><li>热点数据成为性能瓶颈。例如订单系统，近一段的订单可能会被频繁读写，而很早的历史订单则会很少读取。</li></ul><p>水平拆分的三种情况，以students表，db数据库为例</p><ul><li><p>只分表，将一个表水平拆分存储在一个数据库中</p><p>例如，db中存放students1和students2两个表</p></li><li><p>只分库，在多个数据库中分别存放一个表</p><p>例如，db1存放了一个students表，db2也存放了一个students表</p></li><li><p>分库分表，在多个数据库中存放多个相同的表（<strong>可以解决数据库IO瓶颈，数据库连接压力，CPU，网络，内存等等的瓶颈问题。</strong>）</p><p>例如，db1存放了students1和students2两个表；db2也存放了students1和students2两个表</p></li></ul><h2 id="主从复制读写分离"><a href="#主从复制读写分离" class="headerlink" title="主从复制读写分离"></a>主从复制读写分离</h2><p><strong>在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，很多情况下是不能满足实际需求的，通过主从复制的方式来同步数据保证数据不丢失，再通过读写分离来提升数据库的并发负载能力减轻服务器的压力</strong></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt=""></p><p>过程</p><ol><li>在每个事务更新数据完成之前，master在二进制日志进行记录，记录之后，master通知存储引擎提交事务。</li><li>Slave将master的binary log复制到其中继日志</li><li>Slave的线程从中继日志读取事件日志，然后更新slave数据，使其与master中的数据一致</li></ol><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p><img src="%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png" alt=""></p><p>读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也减轻了主服务器的压力。</p><ul><li>主库，提供数据库写服务</li><li>从库，提供数据库读服务</li></ul><h2 id="分库分表比较"><a href="#分库分表比较" class="headerlink" title="分库分表比较"></a>分库分表比较</h2><p>读写分离主要解决数据库读性能瓶颈，水平拆分主要解决数据库数据量大的问题，垂直拆分是实现业务解耦</p><p>数据库拆分原则</p><ol><li><p>优先考虑缓存降低对数据库的读操作。</p></li><li><p>再考虑读写分离，降低数据库写操作。</p></li><li><p>最后开始数据拆分,切分模式： <strong>首先垂直（纵向）拆分、再次水平拆分</strong>。</p></li><li><p>首先考虑按照业务垂直拆分。</p></li><li><p>再考虑水平拆分：先分库(设置数据路由规则，把数据分配到不同的库中)</p></li><li><p>最后再考虑分表，单表拆分到数据1000万以内。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.qingtingip.com/h_186509.html" target="_blank" rel="noopener">https://www.qingtingip.com/h_186509.html</a></p><p><a href="https://blog.csdn.net/shiyong1949/article/details/59586773" target="_blank" rel="noopener">https://blog.csdn.net/shiyong1949/article/details/59586773</a></p><p><a href="https://blog.csdn.net/worn_xiao/article/details/83963932" target="_blank" rel="noopener">https://blog.csdn.net/worn_xiao/article/details/83963932</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2019/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。而如果没有索引，那么可能需要把所有单词看一遍才能找到，这个过程是非常耗费时间的。</p><h2 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h2><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>根本区别</p><ul><li>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</li></ul><p>区别与联系</p><ul><li>两个索引底层均是由B+树实现</li><li>聚集索引叶子即数据，非聚集索引叶子存放指向数据的指针</li></ul><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>数据行的物理顺序与列值的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p><ul><li>查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放</li><li>修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序</li></ul><p>类似于字典的拼音索引，拼音的顺序与字典中汉字实际的顺序一致，当查两个读音一致的词时，找到第一个词后直接向后寻找即可找到第二个词。</p><p>Mysql创建聚集索引</p><pre class=" language-mysql"><code class="language-mysql">create CLUSTERED INDEX 索引名称 ON 表名(字段名)</code></pre><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p><ul><li><p>不会造成数据的重排</p></li><li><p>相对聚集索引可能会慢一些（二次查询造成查询变慢：非聚集索引叶子存放指向数据的指针，当查询列中包含了该索引没有覆盖的列，那么就必须访问该叶子节点指向的数据块查询对应的数据行的数据。）</p><p>二次查询例子：</p><table><thead><tr><th>name</th><th>class</th><th align="left">socre</th></tr></thead><tbody><tr><td>张一</td><td>数学</td><td align="left">100</td></tr><tr><td>张二</td><td>语文</td><td align="left">99</td></tr><tr><td>张三</td><td>英语</td><td align="left">98</td></tr><tr><td>张四</td><td>物理</td><td align="left">97</td></tr></tbody></table><p>建立非聚集索引（name，class）</p><pre class=" language-mysql"><code class="language-mysql">//叶子节点中包好class信息，所以查询到叶子节点即可查到信息select name from table1 where class <> '数学';//叶子节点不包含name，socre信息，所以必须查询结点select name, socre from table1 where class = '数学'</code></pre></li></ul><p>类似于字典的笔画索引，笔画的顺序与字典中汉字实际顺序不一致，当查找两个笔画一样的词时，需要分别查询两个词的位置（两个词一般不会挨着）</p><p>Mysql创建非聚集索引</p><pre class=" language-mysql"><code class="language-mysql">create NONCLUSTERED INDEX 索引名称 ON 表名(字段名)</code></pre><h2 id="建立索引的原则"><a href="#建立索引的原则" class="headerlink" title="建立索引的原则"></a>建立索引的原则</h2><ol><li><p><strong>最左前缀匹配原则</strong>，mysql会一直向右匹配索引直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></li><li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p></li><li><p><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col) / count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p></li><li><p><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/m0_37683670/article/details/85858846" target="_blank" rel="noopener">https://blog.csdn.net/m0_37683670/article/details/85858846</a></p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库三范式</title>
      <link href="/2019/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
      <url>/2019/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><p><strong>数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性</strong></p><ul><li>第一范式的目标是确保每列的原子性</li><li>如果每一列的都是不可再分的最小数据单元，则满足第一范式</li></ul><p>例如：</p><pre><code>每一个人可能有一个公司座机，有一个家庭座机，携带的手机表一：(姓名，性别，电话)        //电话还可以再分，不满足第一范式表二：(姓名，性别，公司座机，家庭座机，手机)        //满足第一范式</code></pre><h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h3><p><strong>满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情</strong></p><ul><li>第二范式要求m每个表只描述一件事情</li><li>如果一个关系满足1NF，并且主键以外其他列，每个属性都依赖主键，则满足第二范式</li></ul><p>例如：</p><pre><code>一个选课系统，学生有学号，姓名和性别属性，课程有课程名和学分表一：(学号，姓名，性别，课程名，学分，成绩)    //主键为(学号，课程名)为主键，姓名依赖于学号，而不依赖于课程名，不满足第二范式表二：(学号，姓名，性别)+(课程名，学分)+(学号，课程名，成绩)    //满足第二范式</code></pre><h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h3><p><strong>必须先满足第二范式（2NF），要求表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）</strong></p><ul><li>每列都和主键直接相关，而不是间接相关</li><li>如果一个关系满足2NF，每一个属性只依赖于主键，而不依赖其他属性，则满足第三范式</li></ul><pre><code>一个学生信息名单，学生有学号，地区有邮编表一：(学号，姓名，地址，邮编)        //邮编依赖于地址，再依赖于学号，不满足第三范式表二：(学号，姓名，地址)+(地址，邮编)    //分成两个表，每一个表均满足第三范式</code></pre><h2 id="不满足三范式的危害"><a href="#不满足三范式的危害" class="headerlink" title="不满足三范式的危害"></a>不满足三范式的危害</h2><p>以第二个例子</p><ul><li><p>数据冗余</p><p>假设一共有学生1000个，共有10门课，每个学生要选5门课，则学分数据重复了（5*1000-10）次</p></li><li><p>更新异常</p><p>若本来高数学分为4，现在要调整为5，则所有的选高数的都要更新，否则学分数据不一致</p></li><li><p>插入异常</p><p>如果新开一门课，还没有学生选择，因为主键中必须包含学号，所以只有课程无法插入</p></li><li><p>删除异常</p><p>假设有一门很烂的课，只有一人选择，现在他要退选，则数据库中便没有了该课的信息</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/waj6511988/p/7027127.html" target="_blank" rel="noopener">https://www.cnblogs.com/waj6511988/p/7027127.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型</title>
      <link href="/2019/01/04/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/01/04/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><h3 id="基本数据类型与封装器类的关系"><a href="#基本数据类型与封装器类的关系" class="headerlink" title="基本数据类型与封装器类的关系"></a>基本数据类型与封装器类的关系</h3><table><thead><tr><th>数据类型</th><th>大小/位</th><th>封装类</th><th>默认值（封装类默认为null）</th><th>数据范围</th></tr></thead><tbody><tr><td>byte</td><td>8bit/1字节</td><td>Byte</td><td>0</td><td>$[-128,127]$</td></tr><tr><td>boolean</td><td>8bit/1字节</td><td>Boolean</td><td>false</td><td>true/false</td></tr><tr><td>short</td><td>16bit/2字节</td><td>Short</td><td>0</td><td>$[-32768,32767]$</td></tr><tr><td>char</td><td>16bit/2字节</td><td>Character</td><td>‘\u0000’（对应数字0，输出为空）</td><td>$[0,65535]$</td></tr><tr><td>int</td><td>32bit/4字节</td><td>Integer</td><td>0</td><td>$[-2^{31},2^{31}-1]$</td></tr><tr><td>float</td><td>32bit/4字节</td><td>Float</td><td>0.0F</td><td>$[1.4E-45,3.4E38]$</td></tr><tr><td>long</td><td>64bit/8字节</td><td>Long</td><td>0L</td><td>$[-2^{63},2^{63}-1]$</td></tr><tr><td>double</td><td>64bit/8字节</td><td>Double</td><td>0.0D</td><td>$[4.9E-324,1.8E308]$</td></tr></tbody></table><h3 id="基本数据类型与封装器类在内存中的差别"><a href="#基本数据类型与封装器类在内存中的差别" class="headerlink" title="基本数据类型与封装器类在内存中的差别"></a>基本数据类型与封装器类在内存中的差别</h3><p>基本数据类型存放在栈中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后在栈中查找有没有字面值为3的地址，没找到，就在栈开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在栈中创建完b这个引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。</p><p>封装器类创建的对象和普通对象一样，存放在堆中</p><pre class=" language-java"><code class="language-java">Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> a<span class="token punctuation">;</span></code></pre><p>执行Integer a = new Integer(3)，首先会在java堆中创建一个new Integer(3)的实例，然后再在栈中创建一个指向该实例的引用a；执行Integer b = new Integer(3)时，同样，首先会在java堆中创建一个new Integer(3)的实例（与第一句创建的实例不一样），然后再在栈中创建一个指向该实例的引用b；执行Integer c = a，则在栈中创建一个实例的引用c，和a指向同一实例</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="自动数据类型转换"><a href="#自动数据类型转换" class="headerlink" title="自动数据类型转换"></a>自动数据类型转换</h4><p>自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下：</p><pre><code>低---------------------------------------------&gt;高byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double注意：char在转为高级或者直接加减运算时，char类型会转换为对应ASCII码值</code></pre><h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><p>强制转换的格式是在需要转型的数据前加上“( )”，然后在括号内加入需要转化的数据类型。高级数据类型转为低级数据类型，数据精度丢失</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">10.66</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//10</span></code></pre><h4 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">double</span> num <span class="token operator">=</span> <span class="token number">0.123456789</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//利用BigDecimal做中间转换</span>BigDecimal bigDecimal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> num1 <span class="token operator">=</span> bigDecimal<span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.12</span><span class="token comment" spellcheck="true">//利用DecimalFormat，返回String类型</span>DecimalFormat decimalFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecimalFormat</span><span class="token punctuation">(</span><span class="token string">"#.000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String num2 <span class="token operator">=</span> decimalFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.123</span><span class="token comment" spellcheck="true">//直接使用String.format，返回String类型</span><span class="token keyword">double</span> num3 <span class="token operator">=</span> Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%.4f"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.1235</span></code></pre><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(), doubleValue()这类的方法将对象转换成原始类型值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token operator">-</span><span class="token number">128</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// high value may be configured by property</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Use Long.decode here to avoid invoking methods that</span>            <span class="token comment" spellcheck="true">// require Integer's autoboxing cache to be initialized</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> Long<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>            h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        high <span class="token operator">=</span> h<span class="token punctuation">;</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>对于-128至127这256个值，直接获取的IntegerCache中的值。 而IntegerCache是Integer中的一个静态内部类，里面将-128至127（即一个字节所能表示的所有带符号值 -2^7至2^7-1）的包装类存在了一个数组中。 对于-128到127之间的数，直接从数组中获取，其他的数则使用new生成。</p><p>因此，当对一个不在范围内的数进行拆箱装箱，最后两个Integer的对象不会相等，而对于在范围内的数进行拆箱装箱，最后两个Integer的对象会相等</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//范围外</span>Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">13452</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//false</span><span class="token comment" spellcheck="true">//范围内</span>Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p>赋值时</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//before autoboxing</span>Integer a <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//after java5</span>Integer a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//装箱 </span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//拆箱 </span></code></pre></li><li><p>方法调用时</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">test</span><span class="token punctuation">(</span>Integer a<span class="token punctuation">)</span><span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先装箱，再拆箱</span></code></pre></li><li><p>循环问题（不可使用）</p><pre class=" language-java"><code class="language-java">Integer sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   sum<span class="token operator">+=</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>+操作方不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象，实际如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> sum<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>Integer sum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样，中间会创建5000个Integer对象，造成空间资源和垃圾回收资源的浪费</p></li><li><p>重载与装箱</p><p>在引入装箱之前，value(int)和value(Integer)是完全不相同的方法，开发者不会因为传入是int还是Integer调用哪个方法困惑。现在由于自动装箱和拆箱的引入，两个方法应该是同相同的方法，但实际上，<strong>自动装箱拆箱对方法的重载并无影响。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Integer b<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b = "</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Reload reload <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reload<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打印a = 5</span>    reload<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//打印b = 10</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="float与double精度丢失问题"><a href="#float与double精度丢失问题" class="headerlink" title="float与double精度丢失问题"></a>float与double精度丢失问题</h2><h3 id="精度丢失的原因"><a href="#精度丢失的原因" class="headerlink" title="精度丢失的原因"></a>精度丢失的原因</h3><p>例子：</p><pre><code>举例：double result = 1.0 - 0.9;这个结果不用说了吧，都知道了，0.09999999999999998</code></pre><p>为什么会出现这个问题呢，就这是java和其它计算机语言都会出现的问题，下面我们分析一下为什么会出现这个问题：<br>float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。float和double类型尤其不适合用于货币运算，因为要让一个float或double精确的表示0.1或者10的任何其他负数次方值是不可能的（其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10）。</p><p>浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。往往产生误差不是因为数的大小，而是因为数的精度。因此，产生的结果接近但不等于想要的结果。尤其在使用 float 和 double 作精确运算的时候要特别小心。</p><p>现在我们就详细剖析一下浮点型运算为什么会造成精度丢失？</p><pre><code>首先我们要搞清楚下面两个问题：     (1) 十进制整数如何转化为二进制数           算法很简单。举个例子，11表示成二进制数：                     11/2=5 余   1                       5/2=2   余   1                       2/2=1   余   0                       1/2=0   余   1                          0结束         11二进制表示为(从下往上):1011          这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，整数永远可以用二进制精确表示 ，但小数就不一定了。      (2) 十进制小数如何转化为二进制数           算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数                     0.9*2=1.8   取整数部分 1                     0.8(1.8的小数部分)*2=1.6    取整数部分 1                     0.6*2=1.2   取整数部分 1                     0.2*2=0.4   取整数部分 0                     0.4*2=0.8   取整数部分 0                     0.8*2=1.6 取整数部分 1                     0.6*2=1.2   取整数部分 0                              .........                           0.9二进制表示为(从上往下): 11100100100100......           注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了&quot;减不尽&quot;的精度丢失问题。</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>利用java.math.BigDecimal，BigDecimal构造部分代码没怎么看懂，查资料查到直接将double转为BigDecimal仍然会出现误差，必须使用String类型转为BigDecimal才能无误差。</p><p>所以，应当先将double转为String，再将String转为BigDecimal才能进行无误差的运算。下面是网上编写的Arith工具类，完成的就是上诉功能。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>math<span class="token punctuation">.</span>BigDecimal<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*** 由于Java的简单类型不能够精确的对浮点数进行运算，这个工具类提供精* 确的浮点数运算，包括加减乘除和四舍五入。*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Arith</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//默认除法运算精度</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEF_DIV_SCALE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这个类不能实例化</span>    <span class="token keyword">private</span> <span class="token function">Arith</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的加法运算。     * @param v1 被加数     * @param v2 加数     * @return 两个参数的和     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的减法运算。     * @param v1 被减数     * @param v2 减数     * @return 两个参数的差     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的乘法运算。     * @param v1 被乘数     * @param v2 乘数     * @return 两个参数的积     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到     * 小数点以后10位，以后的数字四舍五入。     * @param v1 被除数     * @param v2 除数     * @return 两个参数的商     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">div</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span>v2<span class="token punctuation">,</span>DEF_DIV_SCALE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指     * 定精度，以后的数字四舍五入。     * @param v1 被除数     * @param v2 除数     * @param scale 表示表示需要精确到小数点以后几位。     * @return 两个参数的商     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">,</span><span class="token keyword">int</span> scale<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>scale<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                <span class="token string">"The scale must be a positive integer or zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span>scale<span class="token punctuation">,</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的小数位四舍五入处理。     * @param v 需要四舍五入的数字     * @param scale 小数点后保留几位     * @return 四舍五入后的结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">double</span> v<span class="token punctuation">,</span><span class="token keyword">int</span> scale<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>scale<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                <span class="token string">"The scale must be a positive integer or zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        BigDecimal b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>one<span class="token punctuation">,</span>scale<span class="token punctuation">,</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String，StringBuffer，StringBuilder的区别"><a href="#String，StringBuffer，StringBuilder的区别" class="headerlink" title="String，StringBuffer，StringBuilder的区别"></a>String，StringBuffer，StringBuilder的区别</h3><ul><li>String是字符串常量，任何对String的改变都会引发新的String对象的生成，对字符串进行大量修改时不要用String</li><li>StringBuffer，StringBuilder是可变类，任何对它所指代的字符串的改变都不会产生新的对象</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的，单线程下使用StringBuilder</li><li>StringBuffer几个常用的方法<ul><li>append():将新添加的内容连接到调用字符串的末尾</li><li>reverse():颠倒字符串</li><li>detele()：删除指定位置的字符串</li><li>insert(int index，String str)：将一个字符串插入到另一个字符串中指定位置。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/tomcat_2014/article/details/51453988" target="_blank" rel="noopener">https://blog.csdn.net/tomcat_2014/article/details/51453988</a></p><p><a href="https://blog.csdn.net/Evankaka/article/details/44651887" target="_blank" rel="noopener">https://blog.csdn.net/Evankaka/article/details/44651887</a></p><p><a href="https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="noopener">https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
