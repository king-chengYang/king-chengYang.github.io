<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hbase模式设计</title>
      <link href="/2020/02/08/Hbase%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/02/08/Hbase%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="模式设计"><a href="#模式设计" class="headerlink" title="模式设计"></a>模式设计</h2><p>行键在HBase中充当表的一级索引，而且HBase本身没有提供二级索引机制，因此对行键的设计优化对实时查询尤为重要。</p><p>HBase系统架构通过写内存，排序，顺序写磁盘提高写性能，但是以牺牲读性能为代价，因为内存中的数据最终会刷为StoreFile，有很多个StoreFile来存储数据，读取数据时可能需要读取多个StoreFile来查找所需要的数据。</p><h3 id="行键设计"><a href="#行键设计" class="headerlink" title="行键设计"></a>行键设计</h3><p>HBase数据按照行键字典序自然排序，这对扫描操作是一个优化。行键也是HBase最有效的索引，且不支持二级索引。HBase行键设计的原则：</p><ul><li><strong>唯一原则</strong>：行键对应关系型数据库的唯一键（主键），系统设计之处必须考虑有足够的唯一行键去支持业务的数据量</li><li><strong>长度原则</strong>：长度适中，建议使用定长，方便从行键提取所需数据，而无需查询出数据内容以节省网络开销</li><li><strong>散列原则</strong>：避免递增，否则读写负载均衡会集中在某个热点分区，降低性能，甚至引起分区服务器过载而宕机</li></ul><h3 id="规避热点区间"><a href="#规避热点区间" class="headerlink" title="规避热点区间"></a>规避热点区间</h3><p>生产环境下用户ID的生成规则通常是一个递增的数字（用户系统一般基于关系型数据库，用户ID一般MySql等数据库提供的自增主键）。因此会出现一些热点问题：</p><ul><li>新注册的用户一般比较活跃，而新注册的用户根据用户ID分区会分到一个分区上，当新用户产生比较多的日志数据时，分区服务器会承受较大的读写压力。</li></ul><p>再例如订单系统使用时间戳作为分区依据，则旧订单可能会很少访问，而新订单的访问会很多，则新订单服务器会有很大的读写压力。</p><p>下面是两种常见的避免热点区间的方法</p><ul><li><strong>加盐</strong>：在行键前面加上随机数字或者字母，使得数据随机分配到不同的分区。而这种方法的缺点就是，当插入数据再读取数据时，需要在插入时保存一个原始业务行键与添加的随机数的映射关系，或者使用某种散列函数计算原始业务行键的散列值，然后将该散列值的随机数作为行键的前缀。使用这种行键设计的应用通常只是用来做一些分析统计，因此一般实时在线系统不建议使用该行键设计方式</li><li><strong>反转补齐</strong>：将用户ID反转（如123装为321）可以将变化最多的部分放在行键前面，这样的数据的写入也能够顺序地流入各个分区而使得集群负载比较均衡。反转补齐是避免热点区间常用的方法。因为用户ID一般都使用关系型数据库的自增主键，长度一般为20个数字，所以为了使得行键保持定长以方便排序以及可以从行键反推出用户ID，通常会将用户ID反转后在末尾加0补齐20个数字。如果使用时间戳作为行键的一部分，则可以使用“Long.MAX_VALUE-时间戳”，这样最新时间戳的数据行键值较小，数据行能够排在数据存储前列。</li></ul><h3 id="高表与宽表"><a href="#高表与宽表" class="headerlink" title="高表与宽表"></a>高表与宽表</h3><table><thead><tr><th></th><th>高表</th><th>宽表</th></tr></thead><tbody><tr><td>定义</td><td>数据每行包含的列比较少而行比较多的表</td><td>数据每行包含的列比较多而行比较少的表</td></tr><tr><td>查询性能对比</td><td>√</td><td></td></tr><tr><td>负载均衡对比</td><td>√</td><td></td></tr><tr><td>元数据对比</td><td></td><td>√</td></tr><tr><td>事务支持对比</td><td></td><td>√</td></tr></tbody></table><ul><li>查询性能：由于行键是HBase最有效的索引，而高表行比较多，行键比较多，过滤效果更好，并且每行数据更少，因此读取每个数据块可以包含更多的行，并且块缓存或者堆外缓存也可以缓存更多的行</li><li>负载均衡：HBase分区由行键区间决定，更多行可以使得区间粒度更细，分区大小更合适，负载更均衡</li><li>元数据：高表分区更多会导致元数据更多，HBase元数据表更大，可能会给HBase集群主节点HMaster与HBase客户端带来更大压力</li><li>事务支持：HBase只支持行级事务，因此对宽表的一行数据变更操作能够提供事务保证，而高表对多行数据变更无事务支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2020/02/04/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/02/04/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型（JMM）是Java虚拟机定义的，试图屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能达到一致的内存访问效果。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这些变量包括<strong>实例字段，静态字段，构成数组对象得元素</strong>，即线程共享得变量。</p><p>java虚拟机规定</p><ul><li>所有的变量都存储在主内存中</li><li>每个线程又自己的工作内存</li><li>线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</li><li>线程之间无法相互访问，必须通过主内存完成</li></ul><p><img src="%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" alt=""></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节，java内存模型中定义8种操作完成</p><ul><li>lock（锁定）：<strong>作用于主内存变量</strong>，把一个变量标识为一条线程独占状态</li><li>unlock（解锁）：<strong>作用于主内存变量</strong>，把一个处于锁定状态的变量释放出来，释放后可被其他线程锁定</li><li>read（读取）：<strong>作用于主内存变量</strong>，将一个变量的值从主内存传输到线程的工作内存中</li><li>load（载入）：<strong>作用于工作内存变量</strong>，将read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use（使用）：<strong>作用于工作内存变量</strong>，当使用该变量时会执行该操作，将工作内存中变量的值传递给执行引擎</li><li>assign（赋值）：<strong>作用于工作内存变量</strong>，当给该变量复制时执行该操作，将从执行引擎收到的值赋值给变量</li><li>store（存储）：<strong>作用于工作内存变量</strong>，把工作内存中一个变量的值传送到主内存中</li><li>write（写入）：<strong>作用于主内存变量</strong>，将store操作从工作内存中得到的变量的值放入主内存变量中</li></ul><p>而执行上述的8种基本操作还需要满足以下规则</p><ol><li>read和load顺序执行，store和write顺序执行，且不允许这四个操作单独出现</li><li>变量在工作内存中改变之后必须把该变化同步回主内存</li><li>新的变量只能在主内存中诞生</li><li>如果对一个变量执行lock操作，那么会清空工作内存中此变量的值，在执行引擎使用该变量时，需要重新执行load或assign操作初始化该变量</li><li>对一个变量执行unlock操作之前，必须把此变量同步回主内存中</li></ol><h3 id="对long和double型变量特殊规则"><a href="#对long和double型变量特殊规则" class="headerlink" title="对long和double型变量特殊规则"></a>对long和double型变量特殊规则</h3><p>Java内存模型要求上诉8各操作都具有原子性，但对于64位的数据类型(long和double)有如下宽松规定</p><ul><li>允许虚拟机没有被volatile修饰的64位数据的读写分为两次32位的操作</li></ul><p>虽然java内存模型允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，因此未声明未volatile的long和double类型的变量，在多个线程读取修改时，不会出现并发导致的数据不一致问题。</p><h3 id="原子性，可见性与有序性"><a href="#原子性，可见性与有序性" class="headerlink" title="原子性，可见性与有序性"></a>原子性，可见性与有序性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性即要么不执行，要么执行中不可被中断直到执行完毕。java内存模型直接保证原子性变量操作有read，load，assign，use，store，write。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p><p>java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值，这种依赖主内存作为传递媒介的方式实现可见性。</p><ul><li>volatile关键字保证了新值立即同步到主内存，以及每次使用前立即从主内存刷新，volatile可以保证可见性</li><li>synchronized关键字需要使用lock和unlock操作，lock操作需要清空工作内存变量值，再从主内存同步，而unlock操作之前，必须把此变量同步回主内存，synchronized可以保证可见性</li><li>final关键字也可以保证可见性</li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java语言提供volatile和synchronized两个关键字保证线程之间操作的有序性</p><ul><li>volatile关键字禁止指令重排</li><li>synchronized保证一个变量在同一时刻只允许一条线程对其进行lock操作，因此持有同一个锁的两个同步块只能串行进入</li></ul><h3 id="先行先发生原则"><a href="#先行先发生原则" class="headerlink" title="先行先发生原则"></a>先行先发生原则</h3><p>先行发生是java内存模型中定义的两项操作之间的偏序关系, 如果操作A先行发生于操作B之前,是指操作A产生的影响能被操作B观察到,影响包括修改内存中共享变量的值,发送了消息,调用了方法.</p><p>下面是一些虚拟机保证的先行发生关系,虚拟机可以对他们随意进行重排序</p><ul><li><strong>程序次序规则:</strong>  在一个线程内,按照程序代码顺序执行,代码逻辑上的先后</li><li><strong>管程锁定规则:</strong>  一个unlock操作先行发生于后面对同一个锁的lock操作</li><li><strong>volatile变量规则:</strong>  对一个volatile变量的写操作先行发生于后面对这个变量的读操作,时间上的先后</li><li><strong>线程启动规则:</strong>  线程的start()方法先行发生于此线程的每一个动作</li><li><strong>线程终止规则:</strong>  线程的所有操作都先行发生于对此线程的终止检测</li><li><strong>线程中断规则:</strong>  对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li><strong>对象终结规则:</strong>  对一个线程初始化完成,先行发生于它的finalize()方法的开始</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字</title>
      <link href="/2020/02/04/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/02/04/java%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final可以修饰类，方法和变量（局部变量和成员变量）</p><ul><li>当用final修饰一个类时，表明这个类不能被继承。</li><li>当用final修饰一个方法时，子类无法覆盖该方法</li><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h2><p><strong>try+catch</strong></p><p>运行流程：运行到try块中，如果有异常抛出，则转到catch块去处理，如果没有异常，执行catch块后面的语句</p><p>*<em>try+catch+finally *</em></p><p>运行流程：运行到try块中，如果有异常抛出，则转到catch块,catch块执行完毕后，执行finally块的代码，再执行finally块后面的代码。如果没有异常抛出，执行完try块，再执行finally块的代码，然后执行finally块后面的语句 </p><p> *<em>try+finally *</em></p><p>运行流程：运行到try块中,如果有异常抛出的话，程序转向执行finally块的代码，然后方法就以抛出异常的方式退出。 </p><p><strong>try和finally中return问题</strong></p><p>try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回，因此当finally中有return语句时，会覆盖try中的return结果</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问</p><p>static可以修饰方法，变量，代码块</p><ul><li>修饰变量：所有类的对象共有，即类的变量，对于静态变量在内存中只有一个拷贝，JVM只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配</li><li>修饰方法：所有类对象共有，即类的方法，静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。</li><li>修饰代码块：static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized可以修饰代码块，方法，静态方法，类</p><ol><li><p>修饰一个代码块，作用的对象是调用这个代码块的对象</p><p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。</p></li><li><p>修饰一个方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p><p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized方法时，再同一时刻只有一个线程得到执行，另一个线程阻塞，必须等待当前线程执行完这个方法以后才能执行该方法。</p></li><li><p>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</p></li><li><p>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p></li></ol><p>synchronized可以保证原子性，可见性，有序性。</p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient关键字只能修饰变量，而不能修饰方法和类</p><ul><li>被transient修饰的变量，该变量无法序列化</li><li>transient修饰的变量如果是自定义变量，则该类需要实现Serializable接口</li><li>静态变量不论是否使用transient修饰，均不能序列化</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile修饰变量时有两个重要的特性</p><ul><li>保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对于其他下次你哼来说时可以立即得到的。普通变量的值再线程间传递均需要通过主内存完成。</li><li>禁止指令重排优化，普通变量仅仅会保证在该方法的执行过程所有依赖赋值结果的地方能获得正确的结果，而不能保证变量赋值操作的顺序与程序代码的执行顺序一致</li></ul><p>即valatile可以实现的可见性，有序性，不能实现原子性</p><h2 id="interface与abstract"><a href="#interface与abstract" class="headerlink" title="interface与abstract"></a>interface与abstract</h2><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>interface只能修饰类，有如下特点</p><ul><li>接口中方法，变量的默认为public abstract类型</li><li>不能实例化对象</li><li>无构造方法</li><li>所有的方法必须是抽象的</li><li>无静态代码和静态方法</li></ul><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>abstract可以修饰类和方法，具有如下特点</p><ol><li>abstract class不能创建实例对象</li><li>含有abstract方法的类必须定义为abstract class，但abstract class类中的可以包含非抽象类</li><li>abstract类中定义的抽象方法必须在具体子类中实现，所以不能有抽象的构造方法和抽象的静态方法</li><li>如果子类没有实现父类的abstract方法，那么子类也必须定义为abstract类型</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>（1）抽象类可以有构造方法，但接口不能有构造方法；</p><p>（2）抽象类可以有普通成员变量，但接口没有普通成员变量；</p><p>（3）抽象类中可以包含非抽象的普通方法，而接口中的方法必须都是抽象的、不能有非抽象的方法；</p><p>（4）抽象类中的抽象方法的访问类型可以是public、protected，但接口中的抽象方法只能是public类型且默认为public abstract类型；</p><p>（5）抽象类中可以包含静态方法，而接口中不能包含静态方法；</p><p>（6）抽象类和接口都可以包含静态成员变量，抽象类的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认为public static final类型；</p><p>（7）一个类可以实现多个接口，但只能继承一个抽象类；</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>子类拥有父类非 private 的属性、方法。默认的属性和方法无法访问</li><li>子类可以访问父类中protected的方法</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</li><li>子类可以以自己的方式实现父类的方法</li><li>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写</li><li>子类不能缩小父类方法的访问权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的锁机制</title>
      <link href="/2020/02/04/java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/02/04/java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 悲观锁"></a>乐观锁 悲观锁</h2><p><strong>悲观锁：</strong>认为自己使用数据时一定有别的线程修改数据，因此在获取数据前一定会加锁，确保数据不会被别的线程修改，例如synchronized关键字</p><p><strong>乐观锁：</strong>认为自己使用数据时不会有别的线程修改数据，在获取数据时不会加锁，而在更新数据时会判断之前有没有别的线程更新了这个数据。如果没有被更新，则修改数据；如果更新了，可根据不同情况执行不同操作，例如CAS算法</p><p><img src="%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81.png" alt=""></p><p>应用场景</p><ul><li>悲观锁适合写操作多的场景</li><li>乐观锁适合读操作多的场景</li></ul><h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>CAS算法涉及三个操作数</p><ul><li>内存中的数据A</li><li>需要更新的数据B</li><li>需要比较的数据C</li></ul><p>CAS算法步骤：读取内存中数据A，将A与需要比较的数C比较，如果A与C相等，更新内存数据为B，否则不更新</p><p>CAS算法涉及的问题</p><ul><li><strong>ABA问题：</strong>内存中的数先由A改为B，再由B改回A，实际上操作数已经被改变了，但只对比数据会更新数据。解决方法是可以加上版本号</li><li><strong>只能保证一个共享变量的原子操作</strong></li><li><strong>循环时间长开销大：</strong>CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li></ul><h2 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁 适应性自旋锁"></a>自旋锁 适应性自旋锁</h2><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程都需要转入内核态完成，这些操作给系统的并发性能带来很大压力。</p><p>为了让线程等待，我们可以让线程执行一个忙循环（自旋），即线程不满足条件时在while循环中等待，满足条件了再执行自己的代码。自旋等待避免了线程切换的开销，但它会占用处理器的时间。因此，如果锁被占用的时间很短，则会提高性能，如果锁占用时间很长，则自旋会白白浪费处理器资源。</p><p>自适应的自旋锁，其自旋的时间不再固定，而是由前一次再同一个锁上的自旋时间及锁的拥有者的状态决定。</p><h2 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 偏向锁 轻量级锁 重量级锁"></a>无锁 偏向锁 轻量级锁 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。</p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。CAS就是无锁的实现。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><p><img src="%E9%94%81%E7%8A%B6%E6%80%81.png" alt=""></p><ul><li>无锁可以利用CAS操作实现加锁</li><li>偏向锁是记录线程id判断是否是一个线程访问解决加锁问题</li><li>轻量级锁通过CAS和自旋解决加锁问题</li><li>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</li></ul><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 非公平锁"></a>公平锁 非公平锁</h2><p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，即先来先获得锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p><strong>非公平锁</strong>是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 不可重入锁"></a>可重入锁 不可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁。</p><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁 共享锁"></a>独享锁 共享锁</h2><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。例如ReentrantReadWriteLock中的写锁</p><p>共享锁是指该锁可被多个线程所持有。例如ReentrantReadWriteLock中的读锁</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 同步问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2019/12/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/12/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="一-操作系统概述"><a href="#一-操作系统概述" class="headerlink" title="一.操作系统概述"></a>一.操作系统概述</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统目前有五大类型：<strong>批操作系统，分时系统，实时系统，网络操作系统，分布式系统</strong></p><p>操作系统的特征：</p><ul><li>并发<ul><li>并发：多个程序在同一时间段发生</li><li>并行：多个程序在同一时刻发生。单处理器进程交替进行；多处理器进程可重叠执行</li></ul></li><li>共享</li><li>虚拟</li><li>异步</li></ul><p><strong>设备独立性：</strong>用户程序使用的设备与实际使用哪台设备无关的一种特性</p><p>操作系统的主要功能：</p><ul><li>资源管理：处理器管理，存储器管理，设备管理，文件管理</li><li>提供用户接口：命令接口，图形用户接口，系统调用</li><li>以进程的方式组织用户使用计算机</li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统提供给用户的接口有<strong>命令接口</strong>，<strong>系统调用</strong>，<strong>图形接口</strong></p><p><strong>系统调用（程序接口API）：</strong>用户可以利用系统提供的一组系统调命令，来调用OS内核中的一个或一组过程以完成自己需要的功能。可以被看做一个内核与用户空间交互的接口。</p><h2 id="二-进程管理"><a href="#二-进程管理" class="headerlink" title="二.进程管理"></a>二.进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：是资源分配的独立单位，是调度的基本单位，<strong>资源分配的最小单位</strong></p><p>线程：是CPU调度和执行的最小单位，<strong>CPU调度的最小单位</strong></p><p>引入进程与线程的原因</p><ul><li>引入进程是为了使多个程序能够并发的运行，提高资源利用率和系统吞吐量，增加并发程度</li><li>引入线程是为了减少进程切换和创建，撤销进程的开销，提高执行效率，并发性能和节省资源</li></ul><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程主要由<strong>程序段，数据，进程控制块PCB</strong>三部分组成，其中PCB进程控制块是进程存在的唯一标志，数据部分可以与其它进程共享</p><p>进程的创建：申请空白PCB，分配资源，初始化PCB，将进程插入到就绪队列</p><p>进程的终止：设置进程状态为终止，终止其子进程，回收进程占用的资源，删掉它的PCB</p><p>进程与程序的根本区别是：静态与动态的特点</p><p>进程的状态：</p><ul><li>运行态：进程正在使用计算机</li><li>就绪态：进程具备运行条件，但尚未被调度</li><li>阻塞态（等待态）：进程由于等待某一事件或者等待I/O操作不能运行时而进入阻塞态</li></ul><p>进程通信：</p><ul><li><p>共享存储器系统</p><p>在共享存储器系统中，相互通信的进程共享某些存储区，进程之间能够通过这些空间进行通信</p><ul><li>基于共享数据结构方式</li><li>基于共享存储区方式</li></ul></li><li><p>管道通信</p><p>管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件</p></li><li><p>消息传递系统</p><p>进程间的数据交换，以格式化的消息为单位</p><ul><li>直接通信方式</li><li>间接通信方式</li></ul></li></ul><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>原语：是由若干指令组成的，用于完成一定特定功能的一个过程，原语执行是连续的不被中断的。</p><p>进程同步的目的：协调不同进程的运行次序，使得进程能够有效的共享资源并且相互合作</p><p><strong>并发进程的两种关系：</strong>（间接制约）互斥与（直接制约）同步</p><p><strong>临界资源：</strong>需要进程互斥的访问的计算机资源，进程通过互斥的方式对资源进行共享，例如打印机</p><p><strong>临界区：</strong>每个进程访问临界资源的那段代码</p><p>同步机制遵循的规则：<strong>空闲让等，忙则等待，有限等待，让权等待</strong></p><h3 id="同步经典例子"><a href="#同步经典例子" class="headerlink" title="同步经典例子"></a>同步经典例子</h3><pre><code>P:wait(S){    S = S-1;    if(S&lt;0)        挂起}V:signal(S){    S = S+1;    if(S&lt;=0)        唤醒}</code></pre><p>PV操作中互斥量设置为1，同步信号量若期望的消息尚未产生，则对应的初值应为0，若期望的消息已经存在，则信号量初值设置为存在的数目。</p><p>生产者消费者问题</p><pre><code>参数：    empty表示缓冲区是否为空，初值为n；    full表示缓冲区是否为满，初值为0;    互斥信号量mutex=1生产者：producer(){    while(1){        生产一个产品；        P(empty);        P(mutex);        将产品放入缓冲区        V(mutex);        V(full);    }}消费者：consumer(){    while(1){        P(full);        P(mutex);        将产品从缓冲区读出        V(mutex);        V(empty);        消费产品    }}</code></pre><p>读者-写者问题（当写者发起请求时，后续读者都只能在队列中等待，直到写者完成）</p><pre><code>参数：    readcount记录读者数量，初始为0；    mutex为互斥信号量，用于保护更新readcount变量时的互斥；    rw为读写互斥信号量；    canoperate为可进入文件进行操作的互斥信号量；读者：begin    P(canoperate);    P(mutex);    readcount++;    if(readcount == 1)        P(rw);    V(mutex);    P(canoperate);    读文件    P(mutex)    readcount--;    if(readcount == 0)        V(rw);    V(mutex);end;写者：begin    P(canoperate);    P(rw);    V(canoperate);    写文件    V(rw);</code></pre><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><h4 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h4><ul><li>高级调度：作业调度或者长程调度，以作业为单位从外存调入内存</li><li>中级调度：内存与外存对换区交换内容，从存储器资源的角度，将进程的部分或全部内容换出到外存上，将当前进程所需部分内容换入到内存</li><li>低级调度：从就绪队列中选择一个等待CPU的进程并分配CPU给它</li></ul><h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><ol><li>CPU利用率：CPU的负荷</li><li>吞吐量：一个时间单元内完成的进程的数量</li><li>周转时间：从进程提交到进程完成的时间</li><li>等待时间：在就绪队列中等待的时间</li><li>响应时间：从提交申请到产生第一响应的时间</li></ol><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ul><li><p>先来先服务调度算法（FCFS）</p></li><li><p>短作业优先调度算法（SJF）</p><p>平均等待时间，平均周转时间最短</p></li><li><p>优先级调度算法</p><p>老化技术：使作业的优先级随着等待时间的增加而提高</p></li><li><p>时间片轮转调度算法：进程循环获得时间片</p></li><li><p>多级队列调度：将就绪队列分成多个独立队列，每个队列根据情况使用不同的调度算法</p></li><li><p>多级反馈队列调度：</p><p>有三个队列0，1，2。调度程序会先执行队列0中的进程，未执行完的进程进入队列1，只有当0中没有进程时，才能执行队列1中的进程。同样，在队列1中没有执行完的进程进入队列2，只有0，1都没有进程时，才执行队列2中的进程。</p><p>到达0中的进程可以抢占队列1中的进程。而队列1中的进程没执行完或者被队列0中的进程抢占，都让该进程进入到队列中</p></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>进程-资源图表达的系统状态S为死锁状态的充分必要条件是<strong>当且仅当S状态的资源分配图不可完全简化</strong></p><p>产生死锁的原因：</p><ul><li>系统资源不足</li><li>进程推进顺序不当</li></ul><p>产生死锁的必要条件</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不可剥夺条件</li><li>循环等待</li></ul><p>处理死锁的方法</p><ul><li><p>预防死锁：破坏四个必要条件</p><ul><li>破坏互斥条件：资源共享</li><li>破坏”请求和保持条件“：<strong>静态资源分配法</strong>，申请资源之前，一次性申请全部资源</li><li>破坏”不可剥夺“条件：当新的资源请求得不到满足，则释放已有资源</li><li>破坏”循环等待“条件：<strong>有序资源分配法</strong>，将系统资源按类型编号，所有进程必须按照资源序号递增的次序申请资源，同类资源一次申请完。</li></ul></li><li><p>死锁避免：银行家算法</p></li><li><p>检测和解除死锁：</p><p>允许死锁发生，系统不断检测</p><p>发生死锁后，解除死锁：资源剥夺法，撤销进程法</p></li></ul><h2 id="三-内存管理"><a href="#三-内存管理" class="headerlink" title="三.内存管理"></a>三.内存管理</h2><h3 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h3><h4 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h4><p>程序装入的过程</p><ul><li>编译</li><li>链接：由链接程序将编译后形成的一组目标模块，和所需库函数链接在一起，形成一个完整的装入模块</li><li>装入：由装入程序将程序装入模块</li></ul><p>程序装入的方式</p><ul><li><p>绝对装入</p><p>在编译时就知道程序在内存中的地址，编译程序产生绝对地址的目标代码。程序中的逻辑地址与实际地址完全相同</p></li><li><p>静态重定位装入</p><p>装入时将目标代码中的指令地址和数据地址转换成绝对地址。地址变换在装入时一次完成</p></li><li><p>动态重定位装入</p><p>装入时程序的地址为相对地址，只有程序在运行时，会将相对地址转换位绝对地址，需要重定位寄存器支持。</p></li></ul><h4 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h4><ul><li><p>静态链接</p><p>程序装入之前，将各模块与所需的库函数链接</p></li><li><p>装入时动态链接</p><p>装入内存时，采用边装入边链接的方式</p></li><li><p>运行时动态链接</p><p>程序执行时需要该模块时，才对它进行链接</p></li></ul><h4 id="逻辑地址-物理地址"><a href="#逻辑地址-物理地址" class="headerlink" title="逻辑地址 物理地址"></a>逻辑地址 物理地址</h4><p>编译之后，每个目标模块都是从0号开始编址，称为该模块的相对地址</p><p>逻辑地址：用户的程序经过汇编或编译后形成目标模块，模块的相对地址即为逻辑地址</p><p>物理地址：内存中存储单元的地址，物理地址可以直接寻址</p><p>地址映射（重定位）：将用户程序的逻辑地址转换为运行时由机器直接寻址的物理地址的过程</p><p>静态重定位和动态重定位属于操作系统重定位</p><ul><li>静态重定位（静态重定位装入）：装入一个作业时，将作业中指令地址和数据地址全部转换为绝对地址<ul><li>无需硬件支持</li><li>程序在内存中只能连续存储</li><li>程序经地址重定位后不能移动，也不能再申请内存空间</li></ul></li><li>动态重定位（动态重定位装入）：装入一个作业时，不进行地址转换。当程序执行时，每执行一条指令就将相对地址由<strong>重定位寄存器</strong>转换为绝对地址<ul><li>程序在执行过程中可以移动</li><li>程序不必在内存中连续存储</li><li>程序运行前可以只装入部分代码，然后在运行期间再动态申请内存</li><li>若干个用户可以共享同一程序段或数据段</li></ul></li><li>编译重定位：编译器在内存中分配函数，变量等的虚地址，当程序访问到这些地址时，使用的是预分配的虚地址，根据相对程序头部将PC指针偏移找到目标代码。</li></ul><p>内存保护</p><ul><li>重定位寄存器：包含最小的物理地址</li><li>界地址寄存器：最大的逻辑地址值，每个逻辑地址必须小于界地址寄存器</li></ul><h3 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h3><p>进程可以使用的最大地址空间受限于<strong>地址位数</strong></p><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><ul><li>时间局部性：如果程序中某一条指令一旦执行成功，不久之后该指令可能再次执行。原因是循环操作</li><li>空间局部性：一旦程序访问某一个存储单元，不久之后，其附近的存储单元也将被访问。原因是指令通常是顺序存放顺序执行。</li></ul><p>例子</p><ul><li>虚拟内存</li><li>Cache</li><li>页面置换算法（LRU，CLOCK）</li><li>预调页策略</li></ul><h4 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h4><p><strong>内存连续分配</strong></p><ol><li><p>固定分区：</p><p>将内存中用户区划分为若干个连续的分区，其尺寸固定不可变。可以使用&lt;分区号，起始地址，大小，状态&gt;表结构表示分区。出现内部碎片</p></li><li><p>动态分区：</p><p>每个分区大小可以变化。可以使用空闲分区表，空闲分区链表示分区。出现外部碎片，使用<strong>紧凑（紧缩）</strong>方法合并分区，即操作系统不时对进程进行移动和整理</p><p>动态分区的分配策略</p><ul><li>首次适应：空闲分区地址递增方式连接，找到第一个可用分区</li><li>临近适应：在首次适应的基础上循环适应</li><li>最佳适应：空闲分区按容量递增方式连接，找到第一个可用分区</li><li>最坏适应：空闲分区按容量递减方式连接，找到第一个可用分区（最大分区）</li></ul></li></ol><p>交换技术</p><p>把处于等待状态的程序从内存中移到外存，称为换出；把准备好竞争CPU运行的程序从外存移到内存，称为换入</p><h4 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h4><p><strong>内存离散分配，分页内存管理允许进程的物理地址空间可以是非连续的。作业地址空间一维（只需要指定地址，该地址会通过硬件分为页号和偏移）</strong></p><p>页表：每个进程对应一张页表，记录页面在内存中对应的物理块号。页表放在内存中实现页号到物理块号的地址映射。表结构：页号：&lt;物理块号&gt;</p><p>页表中并不包括页号这一项，因为每个页表中每个页号都对应一个物理块号，并且页号按照顺序排列，直接可以定位。</p><p>页内偏移量 = 一个页的大小</p><p>页表寄存器：存放页表起始地址和页表长度，类似重定位寄存器</p><p>快表：TLB，类似Cache</p><p>优点：</p><ul><li>存在页内碎片，但相对较小，内存利用率较高</li><li>实现了离散分配</li><li>便于存储访问控制，有利于代码共享</li><li>无外部碎片</li></ul><p>缺点：</p><ul><li>用户视角的内存和实际物理内存分离</li><li>需要专门的硬件支持</li><li>不支持动态链接</li><li>有内部碎片</li></ul><p>多级页表</p><p>|顶级页表|二级页表|页内偏移量|</p><p>相当于：二级页表是顶级页表的页内偏移量。顶级页表项和二级页表项占的位数相同</p><p>例如：</p><p>  一个页面大小为$2^{12}$，则页内偏移量占12位，页内偏移量代表一个页的大小。顶级页表长度为9位，则一共$2^9$个页表项，一个页表项的长度为8。二级页表项与顶级页表项占的位数相同，为9位，二级页表项即可表示顶级页表项的偏移量，并且是对页表项的偏移量，而非页面大小的偏移量。         </p><h4 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h4><p><strong>类似分页管理，只是每一段长度不一定相同。作业地址空间二维（需要指定段号和偏移）</strong></p><p>理解为：将一个程序分为很多段，每个段就是一个逻辑处理，这些段可以在内存中随意存放。</p><p>段之所以更好满足用于需要就是其将属于一个逻辑的代码放在一起。</p><p>段表：段号: &lt;段长，基址&gt;表结构</p><p>段表寄存器：&lt;段表起始地址，段表长度&gt;，类似重定位寄存器</p><p>优点：</p><ul><li>便于动态链接</li><li>便于共享分段</li><li>便于程序模块化处理，符合用户视角</li><li>无内部碎片(长度可变)</li></ul><p>缺点：</p><ul><li>需要硬件转换</li><li>为了满足分段动态增长，减少外部碎片，采用拼接技术</li><li>有外部碎片</li></ul><h4 id="段页管理"><a href="#段页管理" class="headerlink" title="段页管理"></a>段页管理</h4><p>一个进程对应若干段，一个段对应若干页</p><ul><li>作业的地址空间被分成若干个逻辑段，每个段都有自己的段号</li><li>将每一个段分成若干个大小固定的页</li></ul><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>分段，分页需要将整个进程放入内存中，虚拟内存技术允许执行进程不必完全在内存中</p><p>缺页中断：在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存</p><ul><li>与一般中断的区别：<ul><li>在指令执行期间响应，而非一条指令执行完之后</li><li>缺页中断处理完成后仍回到原指令重新执行，而一般中断则返回到下一条指令执行</li><li>一条指令在执行期间，可能产生多次缺页中断</li></ul></li></ul><p>页面置换算法</p><ul><li><p>最佳置换算法（OPT）</p><p>淘汰页面最长时间不再使用的页面，需要预测未来</p></li><li><p>先进先出置换算法（FIFO）</p><p>会产生Belady异常，即当所分配的物理块数增大而缺页故障不减反增的异常现象。</p></li><li><p>最近最少使用置换算法（LRU）</p><p>淘汰最近最长没有使用的页面</p></li><li><p>时钟置换法</p><ul><li><p>二次机会法（NRU，最近未使用算法）</p><p>给每一块设置一个访问位，并将所有的块链接成循环链表，0表示未访问可替换，1表示已访问</p></li><li><p>改进后的时钟置换算法</p><p>一个访问位A，一个修改位M</p><p>被替换的优先级</p><ul><li>A=0,M=0</li><li>A=0,M=1</li><li>A=1,M=0</li><li>A=1,M=1</li></ul><p>执行过程</p><ul><li>先找第一优先级的</li><li>再找第二优先级的，遍历过程中将所有的访问位置位0</li></ul></li></ul></li></ul><p>局部模型-工作集</p><p>工作集是一个经常使用的页的集合</p><p><strong>颠簸（抖动）：</strong>在页面置换时，刚刚换出的页面又换入主存，这种频繁的页面调度称为<strong>颠簸</strong></p><p>原因：操作系统监视CPU的使用率，当使用率较低时，会引入新进程，以增加多道程序的程度。当多道程序增加到一定程度会出现颠簸。</p><h2 id="三-设备管理"><a href="#三-设备管理" class="headerlink" title="三.设备管理"></a>三.设备管理</h2><p>I/O设备分类：</p><ul><li>设备使用特性<ul><li>存储设备</li><li>输入输出设别</li></ul></li><li>传输速率<ul><li>低速设备</li><li>高速设别</li><li>中速设备</li></ul></li><li>信息交换单位<ul><li>块设备</li><li>字符设别</li></ul></li><li>设备共享性<ul><li>独占设备</li><li>共享设备</li><li>虚拟设备</li></ul></li></ul><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><h4 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h4><ul><li>DMA数据传输的基本单位是数据块，把对一个数据块的读写变为对一组数据块的读写</li><li>实现CPU，通道，和I/O设备三者并行操作</li></ul><h3 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h3><ul><li>缓和CPU和I/O设备之间速度不匹配的矛盾</li><li>减少对CPU中断的频率，放宽对CPU中断的响应时间的限制</li><li>提高CPU和I/O设备之间的并行性</li></ul><p>方式：</p><p>C为处理时间，M为传输到用户的时间，T为传输到缓冲区的时间</p><ul><li>单缓冲：时间Max（C，T）+M</li><li>双缓冲：时间Max（C+M，T），拿数据和处理数据是一个过程</li><li>循环缓冲</li><li>缓冲池</li></ul><h3 id="假脱机技术（SPOOLing）"><a href="#假脱机技术（SPOOLing）" class="headerlink" title="假脱机技术（SPOOLing）"></a>假脱机技术（SPOOLing）</h3><p>脱机输入脱机输出：利用专门外围控制机，完成低速I/O设备和高速磁盘数据传输</p><p>特点：</p><ul><li>提高I/O的速度。利用输入输出井模拟脱机输入输出，缓和了CPU和I/O设备速度不匹配的矛盾</li><li>将独占设备改造为共享设备。并没有为进程分配设备，而是为进程分配一存储区和建立一张I/O请求表</li><li>实现虚拟设备功能。多个进程同时使用同一台独占设备</li><li>利用空间换时间</li></ul><p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_SPOOLing.PNG" alt=""></p><p>共享打印机</p><p>当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程</p><ul><li>由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据传入其中</li><li>输出进程再为用户进程申请一张空白的用户请求打印表，将用户要打印的内容填入其中，再将该表挂到请求打印队列上。</li></ul><h2 id="四-文件系统"><a href="#四-文件系统" class="headerlink" title="四.文件系统"></a>四.文件系统</h2><p>系统运行时，计算机以进程为基本单位进行资源的调度和分配，而在用户进行的输入，输出中，则以文件为基本单位</p><h3 id="文件的组织方式"><a href="#文件的组织方式" class="headerlink" title="文件的组织方式"></a>文件的组织方式</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>文件的逻辑结构就是从用户的观点出发看到的文件的组织方式。</p><ul><li><p>无结构文件</p><p>数据按照顺序组织成记录并积累保存，是有序相关信息项的集合，以字节为单位。通过穷举法搜索</p></li><li><p>有结构文件</p><ul><li>顺序文件（顺序搜索）<ul><li>串结构（时间顺序）</li><li>顺序结构（关键字顺序）</li></ul></li><li>索引文件：索引表</li><li>索引顺序文件：先索引再顺序</li><li>直接文件和哈希文件</li></ul></li></ul><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>文件的物理结构直接与外存的分配方式有关，采用不同的分配方式时，将形成不同的文件物理结构</p><table><thead><tr><th></th><th>访问第n个记录</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>顺序分配</td><td>访问磁盘一次（不存在一个记录存在两个磁盘块的情况）</td><td>存取速度快，根据相对地址快速定位</td><td>需要连续的存储空间，不利于扩充，且会有碎片</td></tr><tr><td>链接分配</td><td>访问磁盘n次</td><td>解决碎片问题，便于动态扩充</td><td>按文件的指针顺序访问，效率较低，指针存储浪费空间</td></tr><tr><td>索引分配</td><td>m级访问磁盘m+1次</td><td>可以随机访问，易于文件的扩充</td><td>索引表的查找策略对文件系统影响较大</td></tr></tbody></table><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件控制块：FCB，用于描述和控制文件的数据结构。文件与文件控制块一一对应。</p><p>目录表</p><p>存储空间管理</p><ul><li>空闲表法&lt;序号，第一个空闲盘块号，空闲盘块数&gt;</li><li>空闲链表法</li><li>位视图法</li><li>成组链接法</li></ul><h2 id="五-磁盘"><a href="#五-磁盘" class="headerlink" title="五.磁盘"></a>五.磁盘</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>磁道划分为扇区。</p><p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.PNG" alt=""></p><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>先寻道，再定位到对应扇区，最后传输数据</p><ul><li><p>寻道时间 = 启动振臂时间$S$+经过的磁道数$N$*经过一个磁道的时间$M$</p></li><li><p>延迟时间 ，定位到对应的扇区，与磁盘的旋转速度$r$有关</p></li><li><p>传输时间 = （经过的磁盘数=传输的字节数$b$ / 一个磁道的字节数$N$）*(转一圈需要的时间=1 / 磁盘每秒的转数)</p><p>rpm代表一分钟的转数vv</p></li></ul><p>磁盘调度算法</p><ul><li>先来先服务(FCFS）</li><li>最短寻道时间优先(SSTF)</li><li>扫描（SCAN）算法（电梯算法）（改进版），双向扫描</li><li>循环扫描（C-SCAN）（改进版）：单向扫描</li></ul><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>低级格式化：将一个磁盘分成扇区</p><p>为了使磁盘可以存储文件，需要两部</p><ul><li><p>磁盘分区</p></li><li><p>逻辑格式化（创建文件系统）</p><p>操作系统将初始的文件系统数据结构存储到磁盘上，包括空闲，已分配的空间和一个初始位空的目录。</p></li></ul><h3 id="RAID（磁盘冗余阵列）"><a href="#RAID（磁盘冗余阵列）" class="headerlink" title="RAID（磁盘冗余阵列）"></a>RAID（磁盘冗余阵列）</h3><p>RAID级别：</p><ul><li><p>RAID0：无冗余的磁盘阵列</p><p>将多个磁盘合并位一个大磁盘，不具备冗余能力，并行I/O。</p><p>一个磁盘块损坏，所有数据无法使用</p></li><li><p>RAID1：镜像文件</p><p>将磁盘阵列中硬盘分为两组，互为镜像，并行传输方式。</p><p>提高读写速度，增加系统可靠性</p></li><li><p>RAID2：内存方式的差错纠正结构</p><p>差错由内存系统检测</p></li><li><p>RAID3：位交织奇偶结构</p><p>一个硬盘存放数据的奇偶校验位，其余硬盘存放数据。</p><p>检验盘损坏，则全部数据无法使用</p></li><li><p>RAID4：块交织奇偶结构</p></li><li><p>RAID5：分布交织奇偶结构</p><p>将数据的奇偶校验位交互存放于各个硬盘上</p></li><li><p>RAID6：P+Q冗余方案</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列BlockingQueue</title>
      <link href="/2019/12/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/"/>
      <url>/2019/12/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列相对于非阻塞队列最大的区别在于</p><ul><li>当队列是空的时，从队列中获取元素的操作将会被阻塞，直到其他的线程往空的队列插入新的元素</li><li>当队列是满时，往队列里添加元素的操作会被阻塞，直到队列中移除一个或者多个元素，或者完全清空队列</li></ul><h2 id="BlockingQueue简介"><a href="#BlockingQueue简介" class="headerlink" title="BlockingQueue简介"></a>BlockingQueue简介</h2><p>BlockingQueue是一个阻塞队列，满足上面阻塞队列的性质，其插入，删除，读取操作方法如下：</p><table><thead><tr><th align="center"></th><th align="center">抛异常</th><th align="center">返回特殊值</th><th align="center">阻塞</th><th>超时</th></tr></thead><tbody><tr><td align="center"><strong>插入</strong></td><td align="center">add(o)</td><td align="center">offer(o)</td><td align="center">put(o)</td><td>offer(o, timeout, timeunit)</td></tr><tr><td align="center"><strong>移除</strong></td><td align="center">remove(o)</td><td align="center">poll(o)</td><td align="center">take(o)</td><td>poll(timeout, timeunit)</td></tr><tr><td align="center"><strong>检查</strong></td><td align="center">element(o)</td><td align="center">peek(o)</td><td align="center"></td><td></td></tr></tbody></table><ul><li>抛异常：操作无法立即执行，抛出异常</li><li>返回特殊值：操作无法立即执行，返回false或null</li><li>阻塞：操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li>超时：操作无法立即执行，该方法调用将在给定的时间内发生阻塞，直到能够执行，操作成功返回true；若在给定时间内无法完成操作，返回false</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 插入队列，通常会使用offer实现     *     * @param e 需要添加的元素     * @return 添加成功返回true     * @throws IllegalStateException 如果元素无法被插入到队列中     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入队列，插入成功返回true，失败返回false     *     * @param e 需要添加的元素     * @return 插入成功返回true，失败返回false     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入元素e至队尾, 如果队列已满, 则阻塞调用线程直到队列有空闲空间.     *     * @param e 需要添加的元素     * @throws InterruptedException 如果等待时被中断     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入元素e至队列, 如果队列已满, 则限时阻塞调用线程，直到队列有空闲空间或超时.     *     * @param e 需要添加的元素     * @param timeout 在放弃插入之前需要等待的时间     * @param unit a timeout的时间单位     * @return 插入成功返回true，失败返回false     * @throws InterruptedException 如果等待时被中断     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 从队首删除元素，如果队列为空, 则阻塞调用线程直到队列中有元素.     *     * @return 队列头部的元素     * @throws InterruptedException 如果等待时被中断     */</span>    E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 从队首删除元素，如果队列为空, 则限时阻塞调用线程，直到队列中有元素或超时.     *     * @param timeout 在放弃插入之前需要等待的时间     * @param unit a timeout的时间单位     * @return 返回头部的元素，或者时间超时返回null     * @throws InterruptedException 如果等待时被中断     */</span>    E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre><p>谨记：BlockingQueue无法插入null</p><h2 id="消费者生产者问题"><a href="#消费者生产者问题" class="headerlink" title="消费者生产者问题"></a>消费者生产者问题</h2><p>操作系统中，生产者消费者问题，一般定义两个同步信号量和一个互斥信号量</p><ul><li>mutex 互斥信号量，表示只有一个线程可以操作队列</li><li>empty 同步信号量，表示剩余空间的个数</li><li>full 同步信号量，表示已经装满的个数</li></ul><p>消费者生产者问题可以自己定义P操作，V操作，然后再利用这三个信号量完成。</p><p>下面是一个利用LinkedBlockingQueue，并且空间大小为5的阻塞队列实现的消费者生产者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 生产者线程 */</span><span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token function">Producer</span><span class="token punctuation">(</span>LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> linkedBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> linkedBlockingQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">Produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Apple apple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产:"</span><span class="token operator">+</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 消费者线程 */</span><span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token function">Consumer</span><span class="token punctuation">(</span>LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> linkedBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> linkedBlockingQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">comsume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">comsume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Apple apple <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费Apple="</span><span class="token operator">+</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue是一种<strong>有界阻塞队列</strong>，在初始构造的时候需要指定队列的容量。具有如下特点：</p><ol><li>队列的容量一旦在构造时指定，后续不能改变；</li><li>插入元素时，在队尾进行；删除元素时，在队首进行；</li><li>队列满时，调用特定方法插入元素会阻塞线程；队列空时，删除元素也会阻塞线程；</li><li>支持公平/非公平策略，默认为非公平策略。</li><li>ArraBlockingQueue是使用环形数组实现<ul><li>当元素个数等于队列长度时表示队列已满</li><li>当元素个数等于0表示队列为空</li></ul></li><li>所有线程共用一把锁</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>所有线程共同使用同一个重入锁</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 存储数据的数组 */</span><span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**获取数据的索引，头索引，主要用于take，poll，peek，remove方法 */</span><span class="token keyword">int</span> takeIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**添加数据的索引，尾索引，主要用于 put, offer, or add 方法*/</span><span class="token keyword">int</span> putIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 队列元素的个数 */</span><span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 控制并非访问的锁，相当于mutex */</span><span class="token keyword">final</span> ReentrantLock lock<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作，相当于full */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**notFull条件对象，用于通知put方法队列未满，可执行添加操作，相当于empty */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 迭代器 */</span><span class="token keyword">transient</span> Itrs itrs <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ArrayBlockingQueue有三个构造函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * 指定队列初始容量的构造器. */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span>int capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用ArrayBlockingQueue(int capacity, boolean fair) </span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定队列初始容量和公平/非公平策略的构造器. */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化队列</span>    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 利用独占锁的策略</span>    notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 根据已有集合构造队列 */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//先构造队列，再插入元素</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> fair<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保证items数组的可见性，即保证插入，删除，读取操作不会操作数据不完整的队列</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不能有null元素</span>                items<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArrayIndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count <span class="token operator">=</span> i<span class="token punctuation">;</span>        putIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> i<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 如果队列已满，则重置puIndex索引为0</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>核心构造方法 ArrayBlockingQueue(int capacity, boolean fair) 默认的是非公平锁</p><ul><li><p><strong>公平策略：</strong>按照“先来后到”的原则，对于每一个等待线程都是公平的。</p></li><li><p><strong>非公平策略：</strong>在多个线程争用锁的情况下，能够最终获得锁的线程是随机的（由底层OS调度）。</p></li></ul><p><em>注意：一般情况下，使用公平策略的程序在多线程访问时，总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时一定需要暂停线程并启动线程。</em></p><p>构造完之后，ArrayBlockingQueue的初始化结构如下</p><p><img src="ArrayBlockingQueue%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84.png" alt=""></p><p>插入元素之后，ArrayBlockingQueue的结构如下</p><p><img src="ArrayBlockingQueue%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E7%BB%93%E6%9E%84.png" alt=""></p><h3 id="尾部插入"><a href="#尾部插入" class="headerlink" title="尾部插入"></a>尾部插入</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ArrayBlockingQueue中的add方法调用其父类AbstractQueue中的add方法，如下</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//调用offer方法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入失败抛出异常</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//检测是否为空</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果队列已满，插入失败，返回false</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入到队列中，返回true</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//检测是否为空</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该方法可中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这里必须用while，防止虚假唤醒，若是虚假唤醒，则再检查一遍确认是否能插入</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//队列已满。</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在notfull队列上等待</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列已满，在notfull队列上等待nanos时间</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span>    <span class="token comment" spellcheck="true">// assert items[putIndex] == null;</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//环形数组，如果尾指针已经到数组尾部，则将尾指针移到数组头部，即重置索引为0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//已经有数据插入，可以唤醒删除线程</span><span class="token punctuation">}</span></code></pre><h3 id="头部删除"><a href="#头部删除" class="headerlink" title="头部删除"></a>头部删除</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果队列为空，返回null，否则删除头部元素</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中孤单</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果队列为空，加入到notEmpty队列中</span>        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列为空，加入到notEmpty队列等待nanos</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span>    <span class="token comment" spellcheck="true">// assert items[takeIndex] != null;</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    E x <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取出元素</span>    items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置取出后的位置为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果头指针已经到尾部，则将头针移到数组头部，即重置头部索引为1</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>        itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//队列中已经空余出位置，唤醒插入线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一种<strong>近似有界阻塞队列</strong>，因为LinkedBlockingQueue既可以在初始构造时就指定队列的容量，也可以不指定，如果不指定，那么它的容量大小默认为<code>Integer.MAX_VALUE</code>。</p><ol><li>插入元素时，在队尾进行；删除元素时，在队首进行；</li><li>队列满时，调用特定方法插入元素会阻塞线程；队列空时，删除元素也会阻塞线程；</li><li>底层数据结构为链表</li><li>维护两把锁<code>takeLock</code>和<code>putLock</code>，可以使删除和插入操作互不干扰<ul><li>takeLock用于控制出队的并发，只能有一个线程进行删除操作</li><li>putLock用于入队的并发，只能有一个线程进行插入操作</li></ul></li><li>所有的元素都被封装成Node类型的节点插入到队列中</li></ol><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 节点类，用于存储数据 */</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span> item <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 当前阻塞队列中的元素个数 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**阻塞队列的头结点,不存数据*/</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**阻塞队列的尾节点，存数据*/</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 获取并移除元素时使用的锁，如take, poll, etc */</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty <span class="token operator">=</span> takeLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 添加元素时使用的锁如 put, offer, etc */</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull <span class="token operator">=</span> putLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 默认构造器. * 队列容量为Integer.MAX_VALUE. */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用LinkedBlockingQueue(int capacity)</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 显示指定队列容量的构造器 */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化为头指针，尾指针为null的队列</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 从已有集合构造队列. * 队列容量为Integer.MAX_VALUE */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保证items数组的可见性，即保证插入，删除，读取操作不会操作数据不完整的队列</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 队列不能包含null元素</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> capacity<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 队列已满</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队尾插入元素</span>            <span class="token operator">++</span>n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 设置元素个数</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>构造完之后，LinkedBlockingQueue的初始化结构如下</p><p><img src="LinkedBlockingQueue%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84.png" alt=""></p><p>插入元素之后，LinkedBlockingQueue的结构如下</p><p><img src="LinkedBlockingQueue%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E7%BB%93%E6%9E%84.png" alt=""></p><h3 id="尾部插入-1"><a href="#尾部插入-1" class="headerlink" title="尾部插入"></a>尾部插入</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不能插入null元素</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//队列已满，返回false</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//加上插入锁</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//队列未满插入数据</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入前队列的长度</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果插入后队列不满，唤醒等待的插入线程</span>                notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> c <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不可插入null数据</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入之前的队列长度</span>    putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果已经满了，则加入notFull队列等待</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//被唤醒后，插入数据</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取后再增加</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果插入后队列未满，则可以唤醒下一个插入线程</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//插入之前的队列长度</span>    putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列已满，在notfull队列上等待nanos时间</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒，插入数据</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果插入后队列未满，则可以唤醒下一个插入线程</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert putLock.isHeldByCurrentThread();</span>    <span class="token comment" spellcheck="true">// assert last.next == null;</span>    last <span class="token operator">=</span> last<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在尾节点插入数据</span><span class="token punctuation">}</span></code></pre><h3 id="头部删除-1"><a href="#头部删除-1" class="headerlink" title="头部删除"></a>头部删除</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果队列为空，返回null</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    E x <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果队列不为空，删除头部元素</span>            x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//删除之前，队列长度大于1，则可以唤醒下一个删除线程</span>                notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    E x<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//可中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//队列长度为0，加入到notEmpty等待队列中</span>            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒后，删除元素</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果删除之前长度大于1，则可以唤醒下一个删除进程</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    E x <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//队列长度为0，加入到notEmpty等待队列等待nanos时间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒后，删除元素</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果删除之前长度大于1，则可以唤醒下一个删除进程</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// assert takeLock.isHeldByCurrentThread();</span>     <span class="token comment" spellcheck="true">// assert head.item == null;</span>     Node<span class="token operator">&lt;</span>E<span class="token operator">></span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head头部没有数据</span>     Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>     h<span class="token punctuation">.</span>next <span class="token operator">=</span> h<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC    ，自己指向自己</span>     head <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head指针后移</span>     E x <span class="token operator">=</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>     first<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h2 id="ArrayBlockingQueue与LinkedBlockingQueue对比"><a href="#ArrayBlockingQueue与LinkedBlockingQueue对比" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue对比"></a>ArrayBlockingQueue与LinkedBlockingQueue对比</h2><table><thead><tr><th></th><th>ArrayBlockingQueue</th><th>LinkedBlockingQueue</th></tr></thead><tbody><tr><td>底部数据结构</td><td>环形数组，存储元素</td><td>链表，封装成Node插入</td></tr><tr><td>锁</td><td>只有一个lock，插入删除只能一个进行</td><td>takeLock和putLock两个锁，插入删除可同时进行，效率会更高一些</td></tr><tr><td>队列大小</td><td>必须指定大小</td><td>可不指定大小默认为Integer.MAX_VALUE，可指定大小</td></tr><tr><td>插入唤醒</td><td>插入数据后直接唤醒删除线程</td><td>插入数据后如果还有空间唤醒后续插入线程；插入之前为空队列再唤醒删除线程</td></tr><tr><td>删除唤醒</td><td>删除数据后直接唤醒插入线程</td><td>删除数据后如果还有数据唤醒后续删除线程；删除之前为满队列再唤醒插入线程</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/77410889</a></p><p><a href="https://segmentfault.com/a/1190000016296278" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016296278</a></p><p><a href="https://blog.yeskery.com/articles/338891277" target="_blank" rel="noopener">https://blog.yeskery.com/articles/338891277</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2019/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2019/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一-计算机系统概述"><a href="#一-计算机系统概述" class="headerlink" title="一. 计算机系统概述"></a>一. 计算机系统概述</h2><h3 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h3><p>硬件性能参数</p><ul><li>计算机字长：CPU字长，指CPU一次能处理数据的二进制位数</li><li>机器主频：时钟脉冲的频率</li><li>主存容量：计算机能够存放的最大的二进制位数bit，B，KB，MB</li></ul><p>计算机性能指标</p><ul><li><p>响应时间：计算机完成某任务从任务输入到结果输出的全部时间</p></li><li><p>吞吐量：单位时间内计算机完成的工作量</p><p>CPI：执行一条指令平均使用的CPU时钟个数</p><p>MIPS：每秒完成百万条（10的六次方）指令数</p></li></ul><h2 id="二-数据的表示和运算"><a href="#二-数据的表示和运算" class="headerlink" title="二. 数据的表示和运算"></a>二. 数据的表示和运算</h2><h3 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h3><p>$X =x_0x_1x_2…x_n$ </p><p>定点小数：$x_0$为符号位，$x_1x_2…x_n$为尾数（小数部分的内容）$[-(1-2^n),1-2^{n}]$</p><p>定点整数：$x_0$为符号位，$x_1x_2…x_n$为尾数（整数部分的内容）$[-(2^n-1),2^n-1]$</p><table><thead><tr><th>真值</th><th>$-2^n$</th><th>$-(2^n-1)$</th><th>-1</th><th>0</th><th>+1</th><th>$2^n-1$</th></tr></thead><tbody><tr><td>原码</td><td>无</td><td>11…11</td><td>10…01</td><td>10…00/00…00</td><td>00…01</td><td>01…11</td></tr><tr><td>反码</td><td>无</td><td>10…00</td><td>11…10</td><td>11…11/00…00</td><td>00…01</td><td>01…11</td></tr><tr><td>补码</td><td>10…00</td><td>10…01</td><td>11…11</td><td>00…00</td><td>00…01</td><td>01…11</td></tr></tbody></table><h3 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h3><p>步骤</p><ul><li>对阶</li><li>尾数加减运算</li><li>尾数结果规格化</li><li>舍入</li><li>溢出判断</li></ul><p>算术逻辑单元ALU</p><ul><li><p>一位全加器</p><p>加数A，加数B，进位C</p></li><li><p>并行加法器</p><p>由多个一位全加器组成</p><ul><li><p>串行进位</p><p>高位依赖低位的进位信息</p></li><li><p>并行进位</p><p>高位低位同时进行运算</p></li></ul></li></ul><h2 id="三-存储器层次结构"><a href="#三-存储器层次结构" class="headerlink" title="三. 存储器层次结构"></a>三. 存储器层次结构</h2><h3 id="半导体存储器RAM"><a href="#半导体存储器RAM" class="headerlink" title="半导体存储器RAM"></a>半导体存储器RAM</h3><p>RAM（随机存取存储器）随机存取存储器，每次访问时间是固定的，与其所在的物理位置无关。</p><p>RAM可以分为静态RAM与动态RAM。</p><ul><li>SRAM：利用触发器电路状态存储信息</li><li>DRAM：利用MOS电容是否带电荷存储信息</li></ul><p>RAM与ROM</p><ul><li>ROM只能读不能写，常用于存放系统程序或不需要修改的数据，非易失</li><li>RAM既可以读也可以写，常用来存放用户程序，数据或作为系统程序的工作区，易失</li></ul><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>多用于cache</p><p>由存储阵列，地址译码器，I/O电路，片选线，读写控制电路组成</p><ul><li><p>存储阵列：是主存储器的核心，程序与数据存放在存储阵列中</p></li><li><p>地址译码器：包含译码器与驱动器，可分为一维译码器（字选择线），二维译码器（字选择线+位选择线）</p><ul><li><p>二维译码器</p><p>将一维线性排列的存储单元进行重新排列，变成二维排列。行选择线选择某一行，位选择线选择该行第几个存储器。</p></li></ul></li><li><p>片选器：实现选择某一个芯片</p></li><li><p>I/O电路与读写控制电路：完成选中存储单元中各位的读出与写入操作</p></li></ul><p>参数：</p><ul><li>数据引脚数量=存储字长=存储单元所包含存储元个数</li><li>存储阵列容量=存储数量（存储单元的个数，与地址线数量有关）*存储字长</li><li>地址引脚数量：与存储单元的个数有关</li></ul><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>多用于主存</p><ul><li><p>刷新：对DRAM定期进行全部重写过程。刷新操作主要解决存储单元中电容缓慢泄露电荷导致的信息丢失问题。</p></li><li><p>DRAM刷新地址计数器：指刷新存储器的行地址。其位数就是行地址的位数</p></li><li><p>刷新的方式</p><ul><li><p>集中式刷新</p><p>是指将各行的行刷新集中一段时间统一进行</p></li><li><p>分散式刷新</p><p>将存储周期扩大一倍，前半段用于正常的读写，后半段用于行刷新。不存在“死区”</p></li><li><p>异步式刷新</p><p>将各行的行刷新均匀分散在整个刷新周期中进行，对集中式刷新和分散式刷新的折中</p></li></ul></li></ul><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>数据存放的方式：</p><ul><li>小端照齐：数据的最低位存放在地址低位</li><li>大端照齐：数据的最高位存放在地址低位</li></ul><h4 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h4><ul><li>位扩展：横向扩展</li><li>字扩展：纵向扩展</li><li>字与位同时扩展：纵向横向同时扩展</li></ul><h4 id="片选"><a href="#片选" class="headerlink" title="片选"></a>片选</h4><p>CPU对存储单元的访问：</p><ol><li>选择存储芯片，即进行片选</li><li>从选中的芯片中依地址码选择对应的存储单元，即进行字选</li></ol><p>片选的方法：</p><ul><li>线选法：有多少个芯片就有多少个选择线，一个选择线对应一个芯片</li><li>全译码法：对芯片进行编码，n个芯片，需要$log_2n$个选择线</li><li>部分译码：相比全译码方法，会多出几位无用</li></ul><h3 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>读</p><ul><li>Cache和主存均被分为若干个大小相等的块，每个块由若干字节组成</li><li>CPU发出主存地址后<ul><li>首先判断该存储字是否在Cache中，若命中，直接访问Cache</li><li>若不命中，则访问主存并将该字所在的主存块装入Cache</li></ul></li></ul><p>写，可能出现数据不一致问题</p><ul><li>如果命中Cache<ul><li>写直达法：将信息同时写入Cache和主存中</li><li>写回法：将信息写入Cache，在Cache被替换时再写入主存</li><li>写一次法：与写回法一样，但再第一次写入时也将信息写入到主存</li></ul></li><li>如果不命中Cache<ul><li>不按写分配法：只将需要写的信息写入主存</li><li>按写分配法：将需要写的信息写入主存后，再将该块从主存中读入Cache</li></ul></li></ul><h4 id="Cache与主存之间的映射关系"><a href="#Cache与主存之间的映射关系" class="headerlink" title="Cache与主存之间的映射关系"></a>Cache与主存之间的映射关系</h4><p>主存的块标记有m位，即主存有$2^m$个块，块大小$2^b$个字，Cache一个$2^c$个块，块大小$2^b$个字</p><ol><li><p>全相联映射</p><p>主存中某个块可以被放到Cache中任意一个位置</p><p>主存：| 块号m位 | 块内地址b位 |</p><p>Cache：| 块号c位 | 块内地址b位 |</p><p>目录表： 块标记位数m位</p></li><li><p>直接映射</p><p>将主存划分为若干个区，每个区的块数与Cache的块数相同，区内第$j$个块只能放在Cache第$j$个块</p><p>主存快标记m=k+c，$2^c$为Cache的块数，k为区标记，一共$2^k$个区</p><p>主存：| 区号k位 | 区内块号c位 | 块内地址b位 |</p><p>Cache：| 块号c位 | 块内地址b位 |</p><p>目录表：块标记位数k位</p></li><li><p>组相联映射</p><p>Cache分成若干个组，每个组包含多个块，将主存划分为若干个区，每个区的主存块数与Cache的组数相同，区内第j块可以放置在Cache的第j组的任意位置</p><p>Cache中c=(c-g)+g，一个$2^{c-g}$个组，一个组内有$2^g$个块</p><p>主存快标记m=(m-c+g) + (c-g) ，一共$2^{m-c+g}$个区，一个区内有$2^{c-g}$个块数</p><p>n路组相联表示一组中有n个数据块</p><p>主存：| 区号k位 | 区内块号g位 | 块内地址b位 |</p><p>Cache：| 组号g位 | 块号c位 | 块内地址b位 |</p><p>目录表：块标记位数k位</p></li></ol><h2 id="四-MIPS-指令系统"><a href="#四-MIPS-指令系统" class="headerlink" title="四. MIPS 指令系统"></a>四. MIPS 指令系统</h2><p>MIPS按字节寻址，一条指令长度为32位，一个字长，所以执行一条指令，PC＋４</p><p>程序控制局部性原理：<strong>时间局部性</strong>和<strong>空间局部性</strong></p><h3 id="MIPS指令格式"><a href="#MIPS指令格式" class="headerlink" title="MIPS指令格式"></a>MIPS指令格式</h3><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_MIPS%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.PNG" alt=""></p><h3 id="MIPS寻址方式"><a href="#MIPS寻址方式" class="headerlink" title="MIPS寻址方式"></a>MIPS寻址方式</h3><p>寄存器取数使用()，例如(R)</p><p>主存按地址取数使用[]，例如[(R)]</p><h4 id="MISP"><a href="#MISP" class="headerlink" title="MISP"></a>MISP</h4><ul><li><p>寄存器寻址：操作数在寄存器组中，指令中有寄存器编号</p></li><li><p>立即数寻址：操作数在指令中</p></li><li><p>基址寻址：操作数地址=基址+偏移地址，基址寄存器编号和偏移地址均在指令中</p></li><li><p>PC相对寻址：操作数地址=PC+偏移地址，偏移地址在指令中</p></li><li><p>伪直接寻址：操作数在主存中，操作数地址在指令中</p><p>单地址指令：操作码+A</p><p>双地址指令：操作码+A+A</p><p>操作码采用定长编码：所有指令格式的操作码长度相同</p><p>操作码采用变长编码：指令格式操作码长度不一样</p></li></ul><p>有效地址为EA，获取操作数需要访问内存的次数</p><table><thead><tr><th>寻址方式</th><th>有效地址</th><th>访存次数</th></tr></thead><tbody><tr><td>立即数寻址</td><td>A即为操作数</td><td>0</td></tr><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>寄存器寻址</td><td>EA=$R_i$</td><td>0</td></tr><tr><td>基址寻址</td><td>EA=(BR)+A</td><td>1</td></tr><tr><td>PC相对寻址</td><td>EA=(PC)+A</td><td>1</td></tr></tbody></table><h4 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h4><ul><li>立即寻址：√</li><li>寄存器寻址：√</li><li>直接寻址：√</li><li>间接寻址：两次寻址</li><li>寄存器间接寻址：两次寻址</li><li>基址寻址：基址固定不变</li><li>变址寻址 = MISP的基址寻址（基址寄存器）</li><li>相对寻址：√</li></ul><h2 id="五-MIPS处理器"><a href="#五-MIPS处理器" class="headerlink" title="五.MIPS处理器"></a>五.MIPS处理器</h2><h3 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h3><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_CPU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.PNG" alt="CPU内部结构"></p><p>CPU的基本功能就是对指令流和数据流在时间和空间上实施正确的控制</p><ul><li>指令流：CPU执行的指令序列</li><li>数据流：根据指令操作要求依次存取数据的序列</li></ul><p>指令的四种基本操作：</p><ul><li>取数：读取某个主存单元的数据，并传输到某个寄存器中</li><li>存数：将某个寄存器的数据存入到主存某个单元之中</li><li>传送：将某个寄存器的数据传输到ALU或者另一个寄存器中</li><li>运算：进行某种逻辑运算，并将结果保存到某一个寄存器中</li></ul><p>CPU组成：</p><ul><li>程序计数器PC</li><li>指令寄存器IR：存放从存储器中取出的指令</li><li>存储器数据寄存器MDR：暂存由主存读出的一条指令或一个数据字</li><li>存储器地址寄存器MAR：保存当前CPU所访问的主存单元地址</li></ul><p>CPU执行流程：</p><pre><code>以ADD R1,(R2)为例：R1 &lt;- (R1)+((R2))最后再将R1中数据放回内存取指：    T1:PC -&gt; MAR            //读取地址    T2:1 -&gt; READ            //发出读命令       M(MAR) -&gt; MDR        //读取数据    T3:MDR -&gt; IR            //读出的数据放在    T4:PC+1 -&gt; PC             //PC+1取数：    T1:R2 -&gt; MAR    T2:1 -&gt; READ       M(MAR) -&gt; MDR    T3:MDR -&gt; B    T4:R1 -&gt; A运算：    A+B -&gt; AC    AC -&gt; R1写回：    T1: R1 -&gt; MDR    T2: PC -&gt; MAR    T3: 1 -&gt; WRITE        MDR-&gt;M(MAR)    T4: PC+1 -&gt; PC</code></pre><h3 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h3><p>所有指令执行周期为固定为单一时钟周期，即CPI=1.采用<strong>哈弗体系结构</strong>（指令和数据采用不同存储器）。</p><h4 id="单周期数据通路设计"><a href="#单周期数据通路设计" class="headerlink" title="单周期数据通路设计"></a>单周期数据通路设计</h4><ol><li><p>取指和PC自增数据通路</p><p>功能描述：</p><ul><li>取指：IM Address ⬅PC，instruction=IM[PC]</li><li>PC自增：PC⬅PC+4</li></ul><p>所需部件：PC，Adder，指令寄存器IM</p></li><li><p>R型指令数据通路</p><p>add rd，rs，rt</p><ul><li>rd第三个寄存器</li><li>rs第一个寄存器</li><li>rt第二个寄存器</li></ul><p>功能描述：R[rd]⬅R[rs]+R[rt]</p><p>所需部件：寄存器堆，ALU</p></li><li><p>加载数据指令</p><p>lw rt，rs，imm16</p><p>功能描述：R[rt] = DM[ R[rs]+Signext(imm16) ]</p><p>通路部件：寄存器堆，ALU，符号扩展单元Signext，数据存储器DM</p></li><li><p>存数指令</p><p>sw rt，rs，imm16</p><p>功能描述：DM[R[rs]+Signext(imm16)] ⬅R[rt]</p><p>通路部件：寄存器堆，ALU，符号扩展单元Signext，数据存储器DM</p></li><li><p>分支指令数据通路</p><p>beq rs，rt，imm16</p><p>功能描述：If ( R[rs] – R[rt] =0) then PC  ⬅ (PC + 4) + Signext(imm16)&lt;&lt;2</p><pre><code>                                                 else PC  ⬅  PC + 4</code></pre><p>通路部件：寄存器堆，ALU，增加一个加法器，符号扩展器，移位器</p></li></ol><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.PNG" alt=""></p><h4 id="指令执行时间计算"><a href="#指令执行时间计算" class="headerlink" title="指令执行时间计算"></a>指令执行时间计算</h4><ul><li>采用单周期，即所有指令周期固定为单一时钟周期，<ul><li>时钟周期由最长的指令决定(LW指令)，为600ps</li></ul></li><li>不同类型采用不同的指令周期（可变时钟周期）</li></ul><p>改进方法：改变m每种指令类型所用的时钟数，采用多周期实现</p><h3 id="多周期处理器"><a href="#多周期处理器" class="headerlink" title="多周期处理器"></a>多周期处理器</h3><p>为什么不使用单周期实现方式</p><pre><code>单周期设计中，时钟周期对所有指令等长，而时钟周期由计算机中可能的最长执行时间的指令决定，一般为取数指令。因此一些较短执行时间的指令会浪费一段时间</code></pre><p>多周期方案（采用普林斯顿结构，指令和数据采用一个存储器）</p><ul><li>将指令分为多个步骤执行，每一个步骤一个时钟周期，则指令执行周期为多个周期，不同指令的指令周期包含时钟周期不一样。</li><li>优点：<ul><li>提高性能</li><li>降低成本：一个功能单元可以在一条指令执行过程中使用多次，只要是在不同的周期内（有点像流水线）</li></ul></li></ul><h4 id="MIPS多周期数据通路设计"><a href="#MIPS多周期数据通路设计" class="headerlink" title="MIPS多周期数据通路设计"></a>MIPS多周期数据通路设计</h4><p>一个ALU，指令算术逻辑运算，取指后PC+4，beq转移指令，都在ALU中完成，扩展数据为补码形式。</p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%A4%9A%E5%91%A8%E6%9C%9F%E6%8C%87%E4%BB%A4.PNG" alt=""></p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%A4%9A%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.PNG" alt=""></p><h3 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h3><ul><li>流水线不改善单个任务处理延迟，但改善了整个工作负载得吞吐率</li><li>流水线速率受限于最慢的流水段</li><li>多个任务同时工作，但占用不同的资源</li><li>潜在加速比=流水线级数</li></ul><h4 id="流水线的五个阶段"><a href="#流水线的五个阶段" class="headerlink" title="流水线的五个阶段"></a>流水线的五个阶段</h4><ol><li>IF：取指令，PC值变化，利用PC中地址从内存中读取指令，放入ID/IF中</li><li>ID：指令译码，读寄存器，从寄存器堆中读取数据放入到ID/EXE中</li><li>EX：执行运算，ALU操作，将结果放在EX/MEM中<ul><li>Load/Store：计算地址</li></ul></li><li>EME：访存。为每一条指令分配该阶段是为了保证同一时刻不会有两条指令都访问数据缓存<ul><li>Load：从Memory读取数据</li><li>Store：将数据写入Memory</li></ul></li><li>WB：数据写回寄存器，将计算结果从ALU输出寄存器写回RF中</li></ol><p>不同阶段之间增加寄存器，保存前一个周期产生的信息。</p><ul><li>命名法则：前级/后继</li><li>功能：时钟上升沿到来，保存前级结果，之后输出至下级组合逻辑</li></ul><p>RF：Register File寄存器堆有两次使用：第二级读，第五级写。并且其第二个寄存器的值可以直接传递到EX/MEM</p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG" alt=""></p><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><p>流水线处理中，由于各个阶段的依赖关系，硬件资源的竞争等原因，会出现操作无法执行的情况。</p><p>在下一个时钟周期妨碍下一条指令执行的执行的情况称为<strong>数据冒险</strong></p><h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p> 结构冒险是指由于硬件资源的竞争，操作无法同时执行的情况，即资源使用冲突</p><ol><li><p>内存访问造成构造冒险</p><p>IF阶段和MEM阶段都涉及内存访问，访问内存使用的总线是共享资源，无法同时进行。（若依曼架构）</p><p>第一条指令为load或者save指令的第四个周期，会与第四条指令的第一个周期发生冲突。</p><p>解决方法：使用哈弗架构</p><pre><code>将指令用的内存和数据用的内存分别设置，即可解决构造冒险。CPU直接访问的缓存基本上都分为指令用和数据用两种，称为指令缓存和数据缓存</code></pre></li><li><p>寄存器访问造成构造冒险</p><p>WB阶段写回寄存器和ID阶段读取寄存器，寄存器无法读写同时进行</p><p>第一条指令为load或者R型指令第五个周期，会与第四条指令第二个周期发生冲突。</p><p>解决办法：分割寄存器堆的访问周期</p><pre><code>时钟周期前半段写，后半段读</code></pre></li></ol><h4 id="数据冒险-1"><a href="#数据冒险-1" class="headerlink" title="数据冒险"></a>数据冒险</h4><p>数据冒险指，由于指令所需要的数据还未准备好所引起的冒险情况。当即将执行的指令依赖于还未完成的数据时，会导致指令无法立刻开始执行，引起数据冒险。</p><ol><li><p>第一条指令在第五个周期将数据写回寄存器，若第二条指令第二个周期要用到第一条指令的数据，则会出现数据冒险</p><p>写回的数据，后续指令需要用到。第一条指令为R型指令，在第五个周期将数据写回寄存器，而第二条指令在第二个周期取指时需要用到该寄存器的值，发生数据冒险。</p></li></ol><p>解决方法：使用<strong>直通的方法</strong>，或者两个nop</p><pre><code>R型指令原本回写运算结果是在WB阶段，而实际上决定运算结果的是在EX阶段。直通方法就是指，在运算结果确定的EX阶段，将数据直接传递给下一个指令的ALU阶段EX/MEM.RegisterRd = ID/EX.RegisterRs = r1在EX/MEM与ID/EX中间加一个转发单元</code></pre><ol start="2"><li><p>数据冒险与阻塞</p><p>当一条指令读取一个寄存器而其前一条指令是load指令（需要将内存中的数据写回寄存器），并且该load指令写入的是同一个寄存器，则直通方法无法解决。原因：load指令写回的数据在MEM阶段完成后产生</p><p>解决方法：阻塞流水线</p><pre><code>当load指令后紧跟着一个需要其结果的指令时，必须采用相应的机制阻塞流水线。除了转发单元，还要将第二条指令阻塞一个周期，使用nop指令（没有任何效果），如果没有转发单元，需要两个nop指令</code></pre></li></ol><p>还可以调整指令的执行顺序。</p><h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p>控制冒险指，无法确定下一条指令而引发的冒险情况。</p><p>在执行可能会改变下一条指令的分支指令时，在这一条指令执行结果确定前（MEM之后）下一条指令无法进行</p><p>解决方法：</p><ul><li><p>假定分支不发生</p><p>即不管分支结果是否产生，继续向下执行，如果分支产生，则丢弃已经预取并译码的指令</p></li><li><p>缩短分支延迟</p><p>一般到MEM阶段才能确定分支结构要执行的下一条指令的PC。</p><p>题前计算分支的目的地址可以将分支加法器从EX段移动到ID段，将PC值和IF/ID流水线寄存器中的指令立即数相加，计算分支结果。</p><p>当分支指令的判断条件的数据寄存器依赖前一条指令的结果时</p><ul><li>如果依赖前一条指令的ALU计算结果时，通过转发单元完成</li><li>如果依赖前一条指令的回写阶段，通过nop指令实现</li></ul></li></ul><h2 id="六-总线与输入输出系统"><a href="#六-总线与输入输出系统" class="headerlink" title="六. 总线与输入输出系统"></a>六. 总线与输入输出系统</h2><h3 id="总线的仲裁方式"><a href="#总线的仲裁方式" class="headerlink" title="总线的仲裁方式"></a>总线的仲裁方式</h3><p>仲裁的方式有集中式和分布式两种。</p><h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><p>总线上主设备最少有两根信号线连接到总线仲裁机构，一根是总线请求信号线BR，一根是总线允许信号线BG</p><ol><li><p>链式查询方式</p><p>总线仲裁机构在有总线请求时，发出总线允许信号BG，由各主设备自行仲裁。需要三根信号线</p><p>特点：</p><ul><li>仲裁采用优先级策略，且各主设备的优先级固定，即离CPU越近主设备优先级越高</li><li>需要的仲裁信号线较少</li><li>可扩展性比较高，但对电路故障敏感，容易产生断链现象</li><li>三条线：BS（总线忙），BR（总线请求），BG（总线允许）</li></ul></li><li><p>计数器定时查询方式</p><p>使用设备地址信号线代替BG，内部使用计数器的计数信号表示设备。可以实现循环优先级和固定优先级两种方式。</p><p>特点：</p><p>　* 对电路不敏感，但信号线数量增多<br>　* 需要2+$log_2 n$条信号线，总线允许线改为设备地址线</p></li><li><p>独立请求方式</p><p>每个设备需要一对总线请求和总线允许信号线</p><p>特点</p><ul><li>速度快</li><li>优先次序控制灵活</li><li>线路多，电路复杂</li><li>n条BR，n条BG</li></ul></li></ol><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>不需要中央总裁器，每个设备都有自己的仲裁号和仲裁器，当某主设别由总线请求时，由自身决定仲裁结果。</p><h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h3><h4 id="I-O接口的功能"><a href="#I-O接口的功能" class="headerlink" title="I/O接口的功能"></a>I/O接口的功能</h4><ul><li><p>实现对主机和外设的通信联络控制</p></li><li><p>进行地址译码和设备选择</p><p>接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息</p></li><li><p>实现数据缓冲</p></li><li><p>数据格式的变换</p><p>并-串转换，串-并转换，模-数转换，数-模转换</p></li><li><p>传输控制命令和状态信息</p></li></ul><h4 id="I-O接口的结构"><a href="#I-O接口的结构" class="headerlink" title="I/O接口的结构"></a>I/O接口的结构</h4><p>接口要分别传送数据信息，控制信息，状态信息，这些数据都是由数据总线来传输</p><p>接口类型</p><ul><li>数据传输方式分类：串行接口，并行接口</li><li>主机访问I/O设备的控制方式分类：程序查询式接口，程序中断接口，DMA接口，通道</li><li>功能选择分灵活性分：可编程接口，不可编程接口</li><li>通用性分类：通用接口，专用接口</li><li>输入输出的信号分类：数字接口，模拟接口</li></ul><p>I/O端口：接口电路中可以被CPU直接访问的寄存器，若干个端口+相应的控制逻辑电路=接口</p><ul><li>数据端口：存放数据信息</li><li>命令端口：存放控制命令，CPU只可写</li><li>状态端口：存放状态信息，CPU只可读</li></ul><p>I/O端口编址方式：</p><ul><li>独立编址方式</li><li>统一编址方式</li></ul><h3 id="基本I-O方式"><a href="#基本I-O方式" class="headerlink" title="基本I/O方式"></a>基本I/O方式</h3><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>为了保证数据传输的正确进行，要求CPU在程序中查询外设的工作状态。如果外设没有准备好，CPU就循环等待，如果已经准备好，CPU才能执行I/O指令进行数据传送</p><p>流程：</p><ol><li>预置传送参数</li><li>向外设接口发出命令字</li><li>从外设接口取回状态字</li><li>查询外设标志</li><li>传送数据</li><li>修改传送参数：每进行一次数据传送之后必须修改传送参数：主存缓冲区地址+1，传送个数计数器-1</li><li>判断传送是否结束</li></ol><p>接口：</p><ul><li>数据缓冲寄存器：数据端口，用来存放CPU进行传送的数据信息</li><li>设备状态寄存器：供CPU查询的设备状态寄存器，即状态端口</li></ul><p>缺点：</p><ul><li>CPU等待外部设备</li><li>CPU只能和一台外设交换信息</li><li>不能发现和处理预先无法估计的错误和异常</li></ul><h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>计算机执行程序的过程中，出现某些急需处理的异常情况和特殊请求，CPU暂时中止现行程序，转去对出现的异常情况和特殊请求处理，在处理完毕之后，CPU将自动返回原来的程序继续执行</p><p>中断条件：</p><ul><li>CPU接收到中断请求信号</li><li>CPU允许中断，CPU内部有一个中断允许触发器（EINT）</li><li>一条指令执行完毕（缺页中断除外）</li></ul><p>中断隐指令：CPU响应中断之后，经过某些操作，需执行中断程序，这些操作由硬件实现，称为中断隐指令，包括保存断点，暂不允许中断，引出中断服务程序</p><p>中断过程：</p><ul><li>中断请求</li><li>中断判优（判断中断的优先级）</li><li>中断响应</li><li>中断处理<ul><li>准备部分：关中断，保护现场，判断中断源，开中断指令（允许更高级中断）</li><li>处理部分：执行中断服务程序</li><li>结尾部分：关中断，恢复现场，开中断指令</li></ul></li><li>中断返回</li></ul><p>中断屏蔽：有些中断发生后，可以选择性封锁部分中断，即中断屏蔽。中断屏蔽触发器（MASK），可以改变中断优先级（将原来较低的中断源编程较高的级别，称为中断升级）</p><p>中断分类：</p><p>分类一</p><ul><li>强迫性中断</li><li>自愿性中断</li></ul><p>分类二</p><ul><li>外中断</li><li>内中断</li></ul><p>分类三</p><ul><li>硬中断</li><li>软中断</li></ul><p>分类四</p><ul><li><p>向量中断：用硬件方法识别中断源和获得中断服务程序入口地址</p><p>中断向量：中断服务程序的入口地址</p></li><li><p>非向量中断：用软件查询的方式识别中断源和获得中断程序程序入口地址</p></li></ul><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>周期挪用（周期窃取）：每传输一个字需要占用一个存储周期的时间</p><p>直接存储器访问（DMA）在<strong>外设</strong>和<strong>主存</strong>之间开辟一条”直接数据通道”，在不需要CPU干预不需要软件介入的情况下在两者之间进行高速数据传送。</p><p>通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出<strong>系统总线</strong>，由DMA控制器接管总线进行数据传送</p><p>DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p><p>DMA与中断的区别：</p><ul><li>中断方式是程序切换，需要现场保护和现场恢复；DMA方式除了开始与结尾，不占用任何CPU资源</li><li>中断请求一般发生在每条指令执行完毕；DMA请求的响应时间可以发生在每个机器周期结束</li><li>中断传送需要CPU参与，DMA方式传输数据时无需CPU干预</li><li>DMA请求优先级高于中断请求</li><li>中断方式可以处理异常事件，DMA局限于传输数据块</li></ul><p>DMA控制器</p><ul><li>主存地址计数器：存放待交换数据的主存地址</li><li>传送长度计数器：记录长度计数器</li><li>数据缓冲寄存器：暂存每次传输的数据</li><li>DMA请求触发器：每当外设准备好数据后给出一个控制信号，使DMA请求触发器置位</li><li>控制/状态逻辑</li><li>中断机构：当一个数据块传输完毕之后触发中断机构，向CPU提出中断请求，CPU进行结尾处理</li></ul><p>传输过程</p><ul><li>DMA预处理：DMA传输之前进行初始化，由CPU完成</li><li>数据传送：以数据块为基本单位进行传输</li><li>DMA后处理：DMA向CPU发中断请求，CPU停止原来的程序执行，转去执行DMA结束处理工作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce工作机制</title>
      <link href="/2019/02/12/MapReduce%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/12/MapReduce%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="MapReduce作业运行机制"><a href="#MapReduce作业运行机制" class="headerlink" title="MapReduce作业运行机制"></a>MapReduce作业运行机制</h3><p>作业运行中涉及到5个实体：</p><ul><li>客户端，提交MapReduce作业</li><li>YARN资源管理器，负责协调集群上计算i机资源的分配</li><li>YARN节点管理器，负责启动和监视集群中机器上的计算容器（container）</li><li>MapReduce的application master，负责协调运行MapReduce作业的任务。它和MapReduce任务在容器中运行</li><li>分布式文件系统</li></ul><h4 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h4><p>Job的submit（）方法创建一个内部JobSummiter实例，其所实现作业提交过程如下：</p><ol><li>向资源管理器申请一个新应用ID </li><li>检查作业的输出说明。例如，如果没有指定输出目录或输出目录已经存在，作业不提交</li><li>计算作业的输入分片。如果分片无法计算，比如输入路径不存在作业不提交</li><li>将运行作业所需要的资源（包括作业JAR文件，配置文件等）复制到共享文件系统中一个以作业ID命名的目录下</li><li>调用资源管理器的submitApplication()提交作业</li></ol><h4 id="作业初始化"><a href="#作业初始化" class="headerlink" title="作业初始化"></a>作业初始化</h4><p>资源管理器收到调用它的submitApplication()消息后，便将请求传递给YARN调度器（scheduler）。调度器分配一个容器，然后节点管理器在资源管理器的管理下启动Application master进程。</p><ol><li>application master通过创建多个薄记对象完成对作业的初始化，用以保持对作业进度的跟踪。</li><li>然后，它将接受l来自共享系统的，在客户端j计算d的输入分片。</li><li>再对每一个分片创建一个map任务对象。任务ID也在此时分配。</li><li>最后，application master在任务运行之前，设置输出目录以及任务输出的临时g工作空间</li></ol><h4 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h4><p>application master需要判断如何运行构成MapReduce作业的各个任务。如果作业很小，就选择和自己在同一个JVM上运行任务。否则应该为该作业的所有map任务和reduce任务向资源管理器请求容器，首先Map任务发出请求，直到有5%d的map任务y已经完成时，reduce任务的请求才会发出。</p><p>reduce任务能够在集群任意位置运行，但是map任务有着数据本地化局限：</p><ul><li>理想情况下，任务的数据本地化，意味着任务在分片驻留的同一节点运行</li><li>任务可能是机架本地化，分片在同一机架而非同一节点上运行</li><li>还有可能是别的机架h获取所需数据</li></ul><h4 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h4><p>一旦资源管理器的调度器为任务分配了一个特定节点上的容器，application master就通过y与节点管理器通信启动容器。在运行任务之前，首先将任务需要的z资源本地化，包括作业配置，JAR文件等。</p><h4 id="作业完成"><a href="#作业完成" class="headerlink" title="作业完成"></a>作业完成</h4><p>一个作业和它的每个任务都有一个状态，这些状态信息在作业期间不断改变。Map任务和Reduce任务会不断报告任务完成情况。</p><p>当Application master收到作业最后一个任务完成得通知时，便将作业状态设置为“成功”。然后，Job轮询状态时，便知道任务已经完成。最后，任务完成时，application master和任务容器清理其工作状态。</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务隔离级别</title>
      <link href="/2019/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2019/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是并发控制的基本单位，所谓事务，它是一个操作序列，这个操作要么都执行，要么都不执行，它是一个不可分割的工作单位，需要满足ACID原则。</p><ul><li>一致性：在事务开始之前和事务结束之后，数据库的完整性没有被破坏。</li><li>原子性：一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务没有执行过一样。即，事务不可分割，不可简约。</li><li>隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</li><li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>对一致性的解释，以银行转钱为例：</p><pre><code>数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。假设A有200，B有200，现在A给B转100，不论事务成功还是失败，应该保证事务结束后，A和B得总金额为400元。</code></pre><h2 id="并发事务会产生的问题"><a href="#并发事务会产生的问题" class="headerlink" title="并发事务会产生的问题"></a>并发事务会产生的问题</h2><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p><strong>A事务撤销时，把已经提交的B事务的更新数据覆盖了</strong></p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center">查询余额为100元</td><td align="center"></td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>提交事务</strong></td></tr><tr><td align="center">T7</td><td align="center">取出10把余额改为90</td><td align="center"></td></tr><tr><td align="center">T8</td><td align="center"><strong>撤销事务</strong></td><td align="center"></td></tr><tr><td align="center">T9</td><td align="center">余额为100</td><td align="center"></td></tr></tbody></table><p><strong>A事务提交时，把已经提交的B事务的更新数据覆盖了</strong></p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center">查询余额为100元</td><td align="center"></td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>提交事务</strong></td></tr><tr><td align="center">T7</td><td align="center">取出10把余额改为90</td><td align="center"></td></tr><tr><td align="center">T8</td><td align="center"><strong>提交事务</strong></td><td align="center"></td></tr><tr><td align="center">T9</td><td align="center">余额为90</td><td align="center"></td></tr></tbody></table><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>读到未提交更新的数据</strong></p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T5</td><td align="center">查询余额为110元</td><td align="center"></td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>撤销事务，余额为100</strong></td></tr><tr><td align="center">T7</td><td align="center">存入100把余额改为210</td><td align="center"></td></tr><tr><td align="center">T8</td><td align="center"><strong>提交事务</strong></td><td align="center"></td></tr></tbody></table><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据</strong></p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T4</td><td align="center">查询余额为100元</td><td align="center"></td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>提交事务</strong></td></tr><tr><td align="center">T7</td><td align="center">查询余额为110元</td><td align="center"></td></tr></tbody></table><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><strong>读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据</strong></p><p><strong>不可重复读和幻读的区别：</strong> 简单来说，不可重复读是由于数据修改引起的，幻读是由数据插入或者删除引起的。</p><table><thead><tr><th align="center">时间点</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center"><strong>事务开始</strong></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center"><strong>事务开始</strong></td></tr><tr><td align="center">T3</td><td align="center">查询交易记录为3条</td><td align="center"></td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">查询余额为100元</td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">存入10元将余额改为110元</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"><strong>提交事务</strong></td></tr><tr><td align="center">T7</td><td align="center">查询交易记录为4条</td><td align="center"></td></tr></tbody></table><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>Mysql中事务的隔离级别一共分为四种，分别如下：</p><ul><li><p>序列化（SERIALIZABLE）:提供了事务之间最大限度隔离，事务一个接一个顺序执行，没有脏读，不可重复读，幻读    </p><pre><code>如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，这种隔离级别提供了事务之间最大限度的隔离。</code></pre></li><li><p>可重复读（REAPETABLE　READ）：解决了不可重复读，但是幻读则未解决</p><pre><code>在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。（因为正在执行的事务所产生的数据变化不能被外部看到）。</code></pre></li><li><p>提交读（READ　COMMITTED）：主要解决了脏读的问题，对于不可重复读和幻象读则未解决</p><pre><code>READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。</code></pre></li><li><p>未提交读（READ UNCOMMITTED）:存在脏读，不可重复读以及幻读问题</p><pre><code>READ UNCOMMITTED 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。</code></pre></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻想读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>READ　COMMITTED</td><td>不允许</td><td>允许</td><td>允许</td></tr><tr><td>REAPETABLE　READ</td><td>不允许</td><td>不允许</td><td>允许</td></tr><tr><td>SERIALIZABLE</td><td>不允许</td><td>不允许</td><td>不允许</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="/2019/02/10/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/10/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，就是虚拟机的类加载机制。</p><p>在Java语言中，类型的加载，连接和初始化过程都是在程序运行期间完成的，即动态加载，动态连接。</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，类的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析三阶段统称为连接。</p><p><img src="%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p><p>虚拟机规范中没有对什么时候开始类加载进行强制约束，但是对于初始化阶段，虚拟机规范则严格规定了有且只有5种情况必须立即对类进行“初始化”</p><ol><li>遇到new，getstatic，putstatic，invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。分别对应的场景如下：<ul><li>new：使用new关键字实例化对象的时候</li><li>getstatic，putstatic：读取或设置一个类的静态字段（被final修饰，已在编译期将结果放入常量池的静态字段除外）</li><li>invokestatic：调用一个类的静态方法的时候</li></ul></li><li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类时，如果其父类没有进行过初始化，则需要先触发其父类的初始化。对于接口在初始化时，并不要求其父接口全部初始化，只有在真正使用到父类接口时才会初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li><li>使用动态语言的特殊场景（没有接触过，现在就不讨论了）</li></ol><p>这5种场景称为对一个类的主动引用，除此以外，所有引用类的方式都不会触发初始化，举例说明主动引用和备用引用的区别：</p><p>补充：</p><ul><li>静态代码块：static声明，JVM加载类时，仅执行一次</li><li>构造代码块：类种直接用{}定义，每次创建对象时执行</li><li>执行顺序：<ul><li>无继承：静态代码块—-&gt; main()  —-&gt; 构造代码块 —-&gt; 构造方法</li><li>有继承：父类静态代码块 —-&gt;子类静态代码块 —-&gt;父类构造代码块，构造函数 —-&gt;子类构造代码块，构造函数</li></ul></li></ul><p><strong>主动引用情况1</strong></p><p>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>A</code></pre><p><strong>主动引用情况2</strong></p><p>使用new关键字实例化对象的时候</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        B b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>B</code></pre><p><strong>主动引用情况3</strong></p><p>读取或设置一个类的静态字段</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>B<span class="token number">100</span></code></pre><p><strong>主动引用情况4</strong></p><p>当初始化一个类时，如果其父类没有进行过初始化，则需要先触发其父类的初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>BA</code></pre><p><strong>被动引用情况1</strong></p><p>通过子类引用父类的静态字段，不会导致类初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span>B<span class="token number">100</span></code></pre><p><strong>被动引用情况2</strong></p><p>通过数组定义来引用类，不会触发类的初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        B<span class="token punctuation">[</span><span class="token punctuation">]</span> bs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//无输出</span></code></pre><p><strong>被动引用情况3</strong></p><p>常量在编译阶段会存入调用类的常量池种，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span><span class="token number">100</span></code></pre><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成3件事情</p><ul><li>通过一个类的全限定名来获取此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为<strong>方法区的运行时数据结构</strong></li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个可类的各种数据的访问入口</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证时连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p><p>验证阶段大致完成下面4个阶段的检验工作</p><ol><li><p>文件格式验证：验证字节码是否符合Class文件格式规范</p><p>该验证阶段主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个java类型信息的要求。该阶段地验证是基于二进制字节流进行地，只有通过了这个阶段地验证后，字节流才会进入内存的方法区中进行存储，后面的3个阶段全部是基于方法区的存储结构进行的。</p></li><li><p>元数据验证：对字节码描述的信息进行语义分析</p></li><li><p>字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的</p></li><li><p>符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用时，该转化发生在连接的第三阶段解析阶段。符号引用验证可以看做时对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</p></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段时正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行匹配。</p><ul><li>进行内存分配的仅包括类变量，而不包括实例变量</li><li>初始值为数据类型的零值（常量要初始化为对应的值）</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</p><ul><li>符号引用：符号引用以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。</li><li>直接引用：直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>到了初始化阶段，才真正开始执行类中定义的java程序代码。</p><p>初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程，对&lt; clinit &gt;的要求有如下</p><ol><li>方法由编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态语句块（static{}块）中的语句合并产生，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问</li><li>方法于类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证子类的&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()方法已经执行完毕</li><li>方法对于类和接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，则编译器不会生成该方法</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此也会生成&lt; clinit &gt;方法，但执行接口的方法时，不需要先执行父接口的&lt; clinit &gt; 的方法，只有当父接口中定义的变量使用时，父接口的方法才会初始化</li><li>虚拟机会保证一个类的&lt; clinit &gt;方法在多线程环境下正确的执行</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类命名空间。</p><p>3种系统提供的类加载器</p><ol><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责将存放在<JAVA_HOME>/lib的类库加载到虚拟机内存中</li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：负责将存放在<JAVA_HOME>/lib/ext的类库加载到虚拟机内存中</li><li><strong>应用程序类加载器（Application ClassLoader）</strong>：负责加载用户路径（ClassPath）上所指定的类库</li></ol><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>类加载器之间的层次关系，称为类加载器的双亲委派模型</p><p><strong>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应由自己的父类加载器</strong></p><p><img src="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt=""></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ClassLoader loader <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>loader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>loader<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            loader <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取其父类加载器</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>双亲委派模型的工作过程：</p><pre><code>如果一个类的加载器收到类加载请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都传送到顶层的类加载器中，只有当父类加载器反馈自己无法完成这个请求时（它的搜索范围中没有找到需要的类）时，子加载器才会尝试自己去加载。</code></pre><p>好处</p><ul><li>核心类不会被篡改</li><li>保证一些特殊类的唯一性，比如java.lang.Object，所有类的父类</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元数据</title>
      <link href="/2019/02/06/%E5%85%83%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/02/06/%E5%85%83%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="元数据概述"><a href="#元数据概述" class="headerlink" title="元数据概述"></a>元数据概述</h3><p>元数据（Metadata）是关于数据的数据。元数据打通了源数据，数据仓库，数据应用，记录了数据从产生到消费的全过程。元数据主要记录数据仓库中模型的定义，各层级间的映射关系，监控数据仓库的数据状态以及ETL的任务运行状态。</p><p>元数据按用途可以分为两类</p><ol><li>技术元数据：是存储关于数据仓库系统技术细节的数据，是用于开发 和管理数据仓库使用的数据<ul><li>分布式计算系统存储元数据，例如表，列，分区等信息</li><li>分布式计算系统运行元数据，例如运行作业信息，作业类型，输入输出等信息</li><li>数据开发平台中数据同步，计算任务，任务调度等信息，包括数据同步的输入输出表和字段，以及同步任务本身的节点信息。</li><li>数据质量和运维相关元数据，如任务监控，运维报警，数据质量，故障等信息。</li></ul></li><li>业务元数据：从业务角度描述了数据仓库中的数据，它提供了介于使用者和实际系统之间的语义层，使得不懂计算机技术的业务人员也能够 “读懂”数据仓库中的数据<ul><li>维度及属性，业务过程，指标等规范化定义</li><li>数据应用元数据，如数据报表，数据产品等的配置和运行元数据。</li></ul></li></ol><p>元数据有重要的应用价值，是数据管理，数据内容，数据应用的基础，在数据管理方面为集团数据提供j计算，存储，成本，质量，安全，模型等治理领域上的数据支持。</p><p>元数据建设的目标是打通数据接入到加工，再到数据消费整个链路，规范元数据体系和模型，提供统一的元数据服务出口，保证元数据产出的稳定性和质量。</p><p>统一元数据建设思路：</p><p><img src="onemate%E4%BD%93%E7%B3%BB.png" alt=""></p><ol><li><p>首先梳理清楚元仓底层数据，对元数据做分类，如计算元数据，存储元数据，质量元数据等，减少数据重复建设，保证数据唯一性。而且也要丰富表和字段使用说明，方便使用和理解</p></li><li><p>根据元仓底层数据构建元仓中间层，建设元数据基础宽表，也就是元数据中间层，打通从数据产生到消费整个链路，不断丰富中间层数据</p></li><li><p>基于元数据中间层，对外提供标准统一的元数据服务出口， 保障元数据产出的质量。</p><p>丰富的元数据中间层不仅能够为集团数据提供 在计算、存储、成本、质量、安全、模型等治理领域上的数据支持，形 成一套完整的 ROI 数据体系，而且为集团数据进行数据内容、数据域、 数据主题、业务属性等的提取和分析提供了数据素材。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据建模</title>
      <link href="/2019/02/06/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/"/>
      <url>/2019/02/06/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="维度建模"><a href="#维度建模" class="headerlink" title="维度建模"></a>维度建模</h2><p>维度建模从分析决策的需求触发构建模型，为分析需求服务，因此它重点关注用户如何更快速地完成需求分析，同时具有较好的大规模复杂查询的响应性能。其设计分为以下几个步骤：</p><ul><li>选择需要进行分析决策的业务流程</li><li>选择粒度，粒度是维度的一个组合</li><li>识别维表</li><li>选择事实，确定分析需要衡量的指标。</li></ul><h2 id="维度设计"><a href="#维度设计" class="headerlink" title="维度设计"></a>维度设计</h2><h3 id="维度设计基础"><a href="#维度设计基础" class="headerlink" title="维度设计基础"></a>维度设计基础</h3><h4 id="维度的概念"><a href="#维度的概念" class="headerlink" title="维度的概念"></a>维度的概念</h4><p>维度是维度建模的基础，在维度建模中，度量称为“事实”，环境描述为“维度”，维度是用于分析事实所需要的多样环境。例如在分析交易过程时，可以通过卖家，买家，商品和交易时间等维度描述交易发生的环境。</p><p>维度所包含的表示维度的列，称为维度属性。维度属性时查询约束条件，分组和表标签生成的基本来源。，</p><p>维度使用主键表示其唯一性，主键也是确保与之相连的任何事实表之间存在引用完整性的基础。主键有两种，他们都是用于标识某维度的具体值：</p><ul><li>代理键：不具有业务含义的键，一般用于处理缓慢变化维</li><li>自然键：具有业务含义的键</li></ul><h4 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h4><p>维度的设计过程就是确定维度属性的过程，如何生成维度属性，以及所生成的维度属性的优劣，决定了维度使用的方便性，以电商商品维度为例：</p><ol><li>选择维度或新建维度，一定要保证维度的唯一性</li><li>确定主维表，主维表一般是ODS表，直接与业务系统同步</li><li>确定相关维表，根据业务，确定哪些表与主维表存在关联关系，并选择其中的某些表用于生成维度属性，比如商品与类目，卖家，店铺存在关联关系</li><li>确定维度属性，包括从主维表中选择维度属性或生成新的维度属性，从相关维表中选择维度属性或生成新的维度属性</li></ol><p>确定维度属性的几点提示</p><ul><li><p>尽可能生成丰富的属性维度</p></li><li><p>尽可能多地给出包括一些富有意义地文字性描述</p></li><li><p>区分数值型属性和事实</p><p>通常用于查询约束条件或分组统计作为维度属性；通常用于参与度量的计算作为事实</p></li><li><p>尽可能沉淀出通用的维度属性</p></li></ul><h4 id="维度的层次结构"><a href="#维度的层次结构" class="headerlink" title="维度的层次结构"></a>维度的层次结构</h4><p><strong>度中的一些描述属性以层次方法或一对多相互关联，可以被理解为包含连续主从关系的属性层次。</strong>比如商品维度，有卖家，类目，品牌等。商品属于类目，类目属于行业，其中类目的最低级别是叶子类目，叶子类目属于二级类目，二级类目属于一级类目。</p><h4 id="规范化与反规范化"><a href="#规范化与反规范化" class="headerlink" title="规范化与反规范化"></a>规范化与反规范化</h4><p>当属性层次被实例化为一系列列维度，而不是单一的维度时，被称为<strong>雪花模式</strong>。大多数联机事务处理系统（OLTP）的底层数据结构在设计时采用这种模式，通过规范化处理将重复属性移至自身所属的表中，删除冗余数据（和数据库三范式的第二范式类似，每一项都要都要于主键有关）</p><p><img src="%E8%A7%84%E8%8C%83%E5%8C%96.png" alt=""></p><p>而对于联机分析处理系统（OLAP），数据是稳定的。将维度的属性层次合并到单个维度中的操作称为反规范化。对于分析系统，采用雪花模式，用户在统计分析的过程中需要大量的关联操作，使用复杂度较高，同时查询性能很差；而采用反规范化方法，方便，易用且性能好。</p><p><img src="%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96.png" alt=""></p><p>采用雪花模式，除了可以节约一部分存储外，对于 OLAP 系统来说 没有其他效用 。 而现阶段存储的成本非常低,出于易用性和性能的考虑， 维表一般是很不规范化的。</p><h4 id="一致性维度和交叉探查"><a href="#一致性维度和交叉探查" class="headerlink" title="一致性维度和交叉探查"></a>一致性维度和交叉探查</h4><p>数据仓库总线架构的重要基石之一就是一致性维度。在针对不同数 据域进行迭代构建或并行构建时，存在很多需求是对于不同数据域的业 务过程或者同一数据域的不同业务过程合并在一起观察。<strong>将不同数据域的商品的事实合并在一起进行数据探查，称为交叉检查。</strong></p><p>如果不同数据域的计算过程使用的维度不一致，就会导致交叉探查存在问题；当存在重复维度，但维度属性或维度属性的值不一致时，会导致交叉探查无法进行或结果错误。</p><p>维度一致性的变现形式如下</p><ol><li>共享维表。</li><li>一致性上卷，其中一个维度属性是另一个维度属性的自己，且两个维度的公共维度属性结构和内容相同。</li><li>交叉属性，两个维度具有部分相同的维度属性。</li></ol><h3 id="维度设计高级主题"><a href="#维度设计高级主题" class="headerlink" title="维度设计高级主题"></a>维度设计高级主题</h3><h4 id="维度整合"><a href="#维度整合" class="headerlink" title="维度整合"></a>维度整合</h4><p>数据仓库的重要数据来源是大量的、分散的面向应用的操作型环 境。不同的应用在设计过程中，可以自由决策，主要满足本应用的需求， 很少会考虑和其他系统进行数据集成。应用之间的差异具体表现在如下 几个方面：</p><ul><li>应用在编码，命名习惯，度量单位等方面存在较大差异</li><li>应用出于性能和扩展性考虑，或者随技术架构演变，以及业务发展，采用不同的物理实现</li></ul><p>所以数据由面向应用操作型环境进入数据仓库后，需要进行数据集成。</p><ul><li>命名规范的统一</li><li>字段类型的统一</li><li>公共代码以及代码值得统一</li><li>业务含义相同的表的统一<ul><li>采用主从表设计，将两个b表或者多个表d都有的字段放在主表中，从属信息分表放在各自的从表中。</li><li>直接合并，共享信息和个性信息都放在一个表中。如果表字段的重合度较低，则会出现d大量空值。</li><li>不合并。因为源表的表结构以及主键等差异较大，无法合并</li></ul></li></ul><p>表级别的整合有两种表现形式</p><ol><li><p>垂直整合：不同的来源表包含相同的数据集，只是存储的信息不同</p><p>比如，会员表中有会员基础信息表，会员扩展信息表，会员等价表，这些表都属于会员相关信息表，依据维度设计方法，尽量整合至会员维度模型</p></li><li><p>水平整合：不同的来源表包含不同的数据集，不同子集之间无交叉，也可以存在部分交叉</p><p>包含不同的数据集，先判断各个数据集有无交叉，如果有交叉，则需要去重；如果不存在交叉，则考虑自然键是否冲突，如果不冲突，则可以将各个子集的自然键作为整合后的表的联合主键。</p></li></ol><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>维度通常需要按照类别或类型进行细分，设计维度有如下两种方法</p><ol><li>方案一：将维度的不同分类实例化为不同的维度，同时在主维度中保存公共属性</li><li>方案二：维护单一维度，包含所有可能的属性</li></ol><p>在设计过程中应该考虑以下三个原则</p><ol><li>扩展性</li><li>效能：性能和成本方面取得平衡</li><li>易用性：模型可l理解性高，访问复杂度低</li></ol><p>在维度进行水平拆分时，主要考虑如下两个依据</p><ol><li><p>维度的不同分类的属性差异情况</p><p>当维度属性随类型变化较大时，将所有可能的属性建立在一个表中不切实际，建议采用方案一。定义一个主维度用于存放公共属性；同时定义多个子维度，其中除了包含公共属性外，还包括各自的特殊属性。</p></li><li><p>依据业务的关联程度</p><p>两个相关性较低的业务，耦合在一起弊大于利，对模型的稳定性和易用性影响较大，可以采用方案二。</p></li></ol><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>由于维度分类的不同而存在特殊的维度属性，可以通过水平拆分解决该问题。</p><p>对于某些维度属性的来源表产出时间较早，而某些维度属性的来源表产出时间较晚；或者某些维度属性的热度高，使用频繁，而某些维度属性比较稳定。处于扩展性，产出时间，易用性等方面考虑，设计主从维度，主维表存放未定，产出时间早，热度高的属性；在维表存放变化比较快，产生时间晚，热度低的属性。</p><h3 id="维度变化"><a href="#维度变化" class="headerlink" title="维度变化"></a>维度变化</h3><h4 id="缓慢变化维"><a href="#缓慢变化维" class="headerlink" title="缓慢变化维"></a>缓慢变化维</h4><p>数据仓库的重要特点之一是反应历史变化。因为现实世界中，维度的属性并不是静态的，它会随着时间的流逝发生缓慢的变化，与数据增长较块的事实表相比，维度变化相对缓慢，这种缓慢变化的维度称为缓慢变化维。</p><p>有三种处理缓慢变化维的方式</p><ol><li><p>重写维度值，不保留历史数据，始终取最新数据。</p></li><li><p>插入新的维度行，保留历史数据，维度变化前的事实和过去的维度值相关，维度变化后的事实与当前维度值关联</p><p>该方式不能将变化前后记录的事实归一为变化前的维度或者归一为变化后的维度</p></li><li><p>添加维度列，该列存储旧的维度值</p></li></ol><h4 id="快照维表"><a href="#快照维表" class="headerlink" title="快照维表"></a>快照维表</h4><p>一般使用代理键作为每个维表的主键，用于处理缓慢变化维。但对于分布式计算系统，不存在事务的概念，对于每个表的记录生成稳定（某条记录每次生成的代理键相同）的全局唯一的代理键难度较大。而且使用代理键会大大增加ETL（数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程）的复杂性，对ETL任务的开发和维护成本很高。</p><p>处理缓慢变化维可以使用快照方式。数据仓库的计算周期一般是每天一次，基于此周期，处理缓慢变化维的方式就是每天保留一份全量快照数据。比如商品维度，每天保留一份全量商品快照数据，任意一天的事实均可以获取当天的商品信息，也可以获取最新的商品信息。（即每天的事实表对应每天的维度表）</p><p>优点：</p><ul><li>简单有效，开发和维护成本低</li><li>使用方便，理解性好</li></ul><p>弊端主要是存储的极大浪费。</p><h4 id="极限存储"><a href="#极限存储" class="headerlink" title="极限存储"></a>极限存储</h4><p><strong>历史拉链</strong>是另一种处理缓慢变化维的方法。这种处理方法是通过新增两个时间戳字段，将所有以天为粒度的变更数据都记录下来。</p><p>比如，如下表记录商品上架下架信息</p><p><img src="%E5%95%86%E5%93%81%E4%B8%8A%E4%B8%8B%E6%9E%B6%E4%BF%A1%E6%81%AF.png" alt=""></p><p>采用历史拉链存储，对于不变的数据，不再重复存储。</p><p><img src="%E6%95%B0%E6%8D%AE%E6%8B%89%E9%93%BE.png" alt=""></p><p>这种存储方式对下游使用存在一定的理解障碍，另外，这种存储方式用start_dt和end_dt做分区，随着时间推移，分区数量会极度膨胀。可以利用极限存储方式处理。</p><p><strong>透明化</strong></p><p>底层的数据还是使用历史拉链存储，但上层做一个视图操作，通过分析语句的分析树，把极限存储前的表的查询转换成对极限存储表的查询</p><p><strong>分月做历史拉链</strong></p><p>在每个月月初重新做历史拉链。</p><p>该方法极大压缩了全量存储的成本，又可以对下游用户透明的效果。但其产出效率很低，并且对变化频率较高的数据并不能达到节约成本的效果。因此在实际生产中，做极限存储需要进行一些额外的处理</p><ul><li>在做极限存储前有一个全量存储表，全量存储表仅保留最近一段时间的全量分区数据，历史数据通过映射的方式关联到极限存储表。即用户只访问全量存储表，所以对用户来说极限存储是不可见的。</li><li>对于部分变化频率频繁的字段需要过滤。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据仓库</title>
      <link href="/2019/02/05/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
      <url>/2019/02/05/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h2><p>数据仓库的定义：<strong>数据仓库是一个面向主题的，集成的，非易失的且随时间变化的数据集合，用来支持管理人员决策</strong>。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="面向主题的"><a href="#面向主题的" class="headerlink" title="面向主题的"></a>面向主题的</h4><p><strong>与传统数据库面向应用进行数据组织的特点相对应，数据仓库中的数据是面向主题进行组织的。</strong>在逻辑意义上，主题是对应企业中某一宏观分析领域所涉及的分析对象。面向主题的数据组织方式，就是在较高层次上对分析对象的数据的一个完整，一致的描述，能完整，统一地刻画各个分析对象所涉及地企业各项数据。</p><h4 id="集成的"><a href="#集成的" class="headerlink" title="集成的"></a>集成的</h4><p><strong>数据仓库的数据是从原有的分散的数据库数据抽取来的，数据仓库的重要数据来源是大量的、分散的面向应用的操作型环境</strong>。数据由面向应用的操作型环境进人数据仓库后，需要进行数据集成。将面向应用的数据转换为面向主题的数据仓库数据，本身就是一 种集成。</p><h4 id="不可更新的"><a href="#不可更新的" class="headerlink" title="不可更新的"></a>不可更新的</h4><p><strong>数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一般情况下并不进行修改操作。</strong>数据仓库的数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据，而不是联机处理的数据。</p><h4 id="随时间变化的"><a href="#随时间变化的" class="headerlink" title="随时间变化的"></a>随时间变化的</h4><p>数据仓库的数据是随时间的变化而不断变化的</p><ul><li>数据仓库随时间变化不断增加新的数据内容</li><li>数据仓库随时间变化不断删去旧的数据内容</li><li>数据仓库中包含有大量的综合数据，这些综合数据中很多跟时间有关，如数据经常按照时间段进行综合，或隔一定的时间片进行抽样等等</li></ul><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>数据仓库可以分为三层，自下而上为：<strong>操作数据层（ODS，Operation Data Store），公共数据层（CMD，Common Data Model）和应用数据层（ADS，Application Data Service）</strong></p><ol><li><p>操作数据层</p><p><strong>将原始数据几乎无处理的存放在数据仓库系统，结构上与源系统基本保持一致，是数据仓库的数据准备区。</strong></p><ul><li>同步：结构化数据增量或全量同步到计算框架</li><li>结构化：非架构化（日志）结构化处理并存储到计算框架</li><li>累计历史，清洗：根据数据业务需求以及稽核和审计要求保存历史数据，清洗数据</li></ul></li><li><p>公共数据层</p><p><strong>主要完成数据加工与整合，建立一致性的维度，构建可复用的面向分析和统计的明细事实表，以及汇总公共粒度的指标。</strong></p><p>存放<strong>明细事实数据、维表数据及公共指标汇总数据</strong> ， 其中明细事实数据、维表数据一般根据 ODS 层数据加工 生成 ，公共指标汇总数据一般根据维表数据和明细事实数据加工生成。</p><p>CDM层又可以细分为明细数据层（DWD层）和汇总数据层（DWS层）</p><ul><li>明细数据层：采用维度模型方法作为理论基础，更多地采用一些维度退化手法，将维度退化至事实表中，减少事实表和维表的关联，提高明细数据表的易用性 </li><li>汇总数据层：加强指标的维度退化，采取更多的宽表化手段构建公共指标数据层，提升公共指标的复用性，减少重复加工。</li></ul></li><li><p>应用数据层</p><p><strong>存放数据产品个性化的统计指标数据，根据CDM与ODS层加工生成。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HbaseShell</title>
      <link href="/2019/02/03/HbaseShell/"/>
      <url>/2019/02/03/HbaseShell/</url>
      
        <content type="html"><![CDATA[<h2 id="Hbase-Shell"><a href="#Hbase-Shell" class="headerlink" title="Hbase Shell"></a>Hbase Shell</h2><p>HBase提供了一个非常方便的命令行交互工具HBase Shell。</p><p>以下表（s_behavior）为例</p><p><img src="%E8%A1%A8.png" alt=""></p><h3 id="数据定义语言"><a href="#数据定义语言" class="headerlink" title="数据定义语言"></a>数据定义语言</h3><p>数据定义语言（Data Definition Language，DDL），包括数据库表的创建，修改等语句。</p><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><pre><code>create &lt;table&gt;, &lt;NAME =&gt; 列族&gt;create &#39;s_behavior&#39;, {NAME =&gt; &#39;pc&#39;},{NAME =&gt; &#39;ph&#39;}</code></pre><h4 id="查看所有表"><a href="#查看所有表" class="headerlink" title="查看所有表"></a>查看所有表</h4><pre><code>list</code></pre><h4 id="查看建表"><a href="#查看建表" class="headerlink" title="查看建表"></a>查看建表</h4><pre><code>describe &#39;s_behavior&#39;</code></pre><p>表的属性解释</p><ul><li>DATA_BLOCK_ENCODING：数据块编码。用类似于压缩算法的编码形式来节省存储空间。</li><li>BLOOMFILTER：布隆过滤器。数据查询Scan操作的时候用来排除待扫描的StoreFile文件。</li><li>REPLICATION_SCOPE：集群间数据赋值开关。1表示开启赋值。</li><li>VERSIONS：HBase对表的数据行可以保留多个数据版本，以时间戳来区分。</li><li>COMPRESSION：压缩方式。HBase提供多种压缩方式用来在数据存储到磁盘之前压缩以减少存储空间。</li><li>TTL：  数据的有效时长，超过TTL的数据在主压缩时会被删除。</li><li>KEEP_DELETED_CELLS：保留了删除的数据，当主压缩后删除的数据才会被清理，如果开启集群间复制，则必须为true，否则会导致数据复制失败</li><li>BLOCKSIZE：HBase读取数据的最小单元，默认为64KB。</li></ul><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><p>修改表需要先将表下线，然后执行修改命令，再上线</p><pre><code>disable &#39;s_behavior&#39; #下线alter &#39;s_behavior&#39;, {NAME =&gt; &quot;cf&quot;, REPLICATION_SCOPE =&gt; &quot;1&quot;, KEEP_DELETED_CELLS =&gt; &quot;TRUE&quot;} #改变表enable &#39;s_behavior&#39; #上线</code></pre><h3 id="数据操作语言"><a href="#数据操作语言" class="headerlink" title="数据操作语言"></a>数据操作语言</h3><p>数据操作语言（Data Manipulation Language，DML），包括数据的修改，查询，删除等语句。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>put命令用来插入一行数据到HBase表</p><pre><code>put &lt;table&gt;, &lt;rowkey&gt;, &lt;列族:列标识符&gt;, &lt;值&gt;#插入pc值put &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, &#39;pc:v&#39;, &#39;1001&#39;#插入ph值put &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, &#39;ph:o&#39;, &#39;1001&#39;</code></pre><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>get命令用来根据行键获取HBase表的一条记录</p><pre><code>get &lt;table&gt;, &lt;rowkey&gt;#获取一条数据get &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;# 获取一条数据某时刻的镜像get &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, {TIMESTAMP =&gt; &#39;151692489001&#39;}#获取多个版本的数据(get命令支持获取数据的多个版本，建表是指定VERSIONS属性即可)alter &#39;s_behavior&#39;, NAME=&gt;&#39;pc&#39;, VERSIONS=&gt;3 #改表put &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, &#39;pc:v&#39;, &#39;1002&#39; #放一个新数据，之前已经有该键get &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, {COLUMN =&gt; &#39;pc:v&#39;, VERSIONS =&gt; 2}</code></pre><h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h3><p>Scan命令用来扫描表的数据，Scan可以有多种用法</p><pre><code>scan &lt;table&gt;#扫描表scan &#39;s_behavior&#39;#获取时间区间内数据scan &#39;s_behavior&#39;, {TIMERANGE =&gt; [151423996739,151513996739]}#获取多版本数据scan &#39;s_behavior&#39;, {VERSIONS =&gt; 2}#获取用户(ID=12345)前5行数据scan &#39;s_behavior&#39;, {FILTER =&gt; &quot;PrefixFilter(&#39;12345_&#39;)&quot;, COLUMNS =&gt; [&#39;pc&#39;], LIMIT=&gt;5}#获取用户(ID=12345)某个时间区间的PC端行为数据scan &#39;s_behavior&#39;, {STARTROW =&gt; &#39;12345_151423996739&#39;,STOPROW =&gt; &#39;12345_151513996739&#39;, COLUMNS =&gt; [&#39;pc&#39;]}#获取用户对商品(ID=1001)的行为数据scan &#39;s_behavior&#39;, FILTER =&gt; &quot;ValueFilter(=,&#39;binary:1001&#39;)&quot;#获用户对商品(ID包含1002)的行为数据scan &#39;s_behavior&#39;, FILTER =&gt; &quot;ValueFilter(=,&#39;substring:1002&#39;)&quot;</code></pre><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>delete用来删除某列数据</p><pre><code>delete &lt;table&gt;, &lt;roekey&gt;, &lt;列族:列标识符&gt;, [&lt;time stamp&gt;]delete &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;, &#39;ph:o&#39;</code></pre><h3 id="DeleteAll"><a href="#DeleteAll" class="headerlink" title="DeleteAll"></a>DeleteAll</h3><p>deleteall删除整行数据</p><pre><code>deleteall &#39;s_behavior&#39;, &#39;12345_151692489001_1&#39;</code></pre><h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><p>truncate删除整个表</p><pre><code>truncate &#39;s_behavior&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka介绍</title>
      <link href="/2019/02/03/kafka%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/02/03/kafka%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="kafka是流处理平台"><a href="#kafka是流处理平台" class="headerlink" title="kafka是流处理平台"></a>kafka是流处理平台</h3><p>流处理平台有三种特性</p><ul><li>发布和订阅可以流式记录</li><li>可以存储流式记录，并且有较好的容错性</li><li>可以在流式记录产生时进行处理</li></ul><p>kafka具有如下特性</p><ul><li>kafka作为一个集群，可以在一台或者多台服务器上运行</li><li>kafka通过topic对存储的流数据进行分类</li><li>每条记录有一个key，一个value和一个timestamp</li></ul><p>kafka有四个核心的API</p><ul><li><strong>Producer API</strong>：允许一个应用程序发布一串流式的数据到一个或者多个Kafka topic。</li><li><strong>Cosumer API</strong>：允许一个应用程序订阅一个或多个 topic ，并且对发布给他们的流式数据进行处理。</li><li><strong>Streams API</strong>：允许一个应用程序作为一个<em>流处理器</em>，消费一个或者多个topic产生的输入流，然后生产一个输出流到一个或多个topic中去，在输入输出流中进行有效的转换。</li><li><strong>Connector API</strong>：允许构建并运行可重用的生产者或者消费者，将Kafka topics连接到已存在的应用程序或者数据系统。比如，连接到一个关系型数据库，捕捉表（table）的所有变更内容。</li></ul><p><img src="./kafka-apis.png" alt=""></p><h3 id="Kafka的构成"><a href="#Kafka的构成" class="headerlink" title="Kafka的构成"></a>Kafka的构成</h3><h4 id="Topics和日志"><a href="#Topics和日志" class="headerlink" title="Topics和日志"></a>Topics和日志</h4><p>Topic是数据主题，是数据记录发布的地方，可以用来区分业务系统。kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费者来订阅其数据。</p><p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，只要如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力：</p><p><img src="./kafka-%E5%88%86%E5%8C%BA.png" alt=""></p><p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，称之为offset，<em>offset</em>用来唯一的标识分区中每一条记录。</p><p>Kafka 集群保留所有发布的记录—无论他们是否已被消费—并通过一个可配置的参数——保留期限来控制. 举个例子， 如果保留策略设置为2天，一条记录发布后两天内，可以随时被消费，两天过后这条记录会被抛弃并释放磁盘空间。Kafka的性能和数据大小无关，所以长时间存储数据没有什么问题。</p><p>在每一个消费者中唯一保存的元数据是offset（偏移量）即消费在log中的位置，偏移量由消费者控制。</p><p><img src="./kafka-consumers.png" alt=""></p><p>日志的分区具有如下用途</p><ol><li>当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可能有多个分区，因此可以处理无限量的数据</li><li>可以作为并行的单元集。</li></ol><p>日志的分区partition （分布）在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性。</p><p>每个分区都有一台 server 作为 “leader”，零台或者多台server作为 follwers 。leader server 处理一切对 partition （分区）的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers 中的一台服务器会自动成为新的 leader。每台 server 都会成为某些分区的 leader 和某些分区的 follower，因此集群的负载是平衡的。</p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>生产者可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(例如：记录中的key)来完成。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>consumer group 是 Kafka 提供的可扩展且具有容错性的消费者机制。一个consumer group有多个consumer，它们共享一个公共的group id。其有如下特点</p><ol><li>consumer group 下可以有一个或多个 consumer instance，consumer instance可以是一个进程，也可以是一个线程。</li><li>group.id 是一个字符串，唯一标识一个 consumer group</li><li>consumer group 订阅的 topic 下的每个分区只能分配给该 group 下的一个 consumer 消费。当然该分区还可以被分配给其他 consumer group。</li></ol><p>对于第三点的理解：组内的所有消费者协调在一起来消费订阅主题的所有分区，partition中的每个message只能被组（Consumer group ）中的一个consumer（consumer 线程）消费，如果一个message被多个consumer消费的话，那么这些consumer必须在不同的组。</p><h4 id="高可用保证"><a href="#高可用保证" class="headerlink" title="高可用保证"></a>高可用保证</h4><ol><li>生产者发送到特定topic partition 的消息将按照发送的顺序处理</li><li>一个消费者实例按照日志中的顺序查看记录.</li><li>对于具有N个副本的主题，我们最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录.</li></ol><h3 id="Kafka使用场景"><a href="#Kafka使用场景" class="headerlink" title="Kafka使用场景"></a>Kafka使用场景</h3><p>它可以用于两大类别的应用:</p><ol><li>构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。 (相当于message queue)</li><li>构建实时流式应用程序，对这些流数据进行转换或者影响。 (就是流处理，通过kafka stream topic和topic之间内部进行变化)</li></ol><p>引用场景</p><ul><li>消息系统</li><li>存储系统</li><li>流处理：在Kafka中，流处理器不断地从输入的topic获取流数据，处理数据后，再不断生产流数据到输出的topic中去。</li><li>批处理：</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YARN简介</title>
      <link href="/2019/01/31/YARN%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/01/31/YARN%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="YARN简介"><a href="#YARN简介" class="headerlink" title="YARN简介"></a>YARN简介</h3><p>YARN（Yet Another Resource Negotiator）是Hadoop的集群资源管理系统。</p><p>分布式计算框架（MapReduce，Spark）作为YARN应用运行在集群计算层（YARN）和集群存储层（HDFS和Hbase）之上。而Pig，Hive等都是运行在MapReduce，Spark之上的处理框架，它们不和YARN直接打交道。</p><p>HDFS，HBase -&gt; YARN -&gt; MapReduce,Spark -&gt;Hive,Pig</p><h3 id="YARN运行机制"><a href="#YARN运行机制" class="headerlink" title="YARN运行机制"></a>YARN运行机制</h3><p>YARN通过两类长期运行的守护进程提供自己的核心服务：管理集群上资源使用的资源管理器（resource manager），运行在集群所有节点且能够启动和监控容器的节点管理器（node manager）</p><p>YARN上运行一个应用：</p><ol><li>客户端要求资源管理器运行一个application master进程</li><li>资源管理器找到一个能够在容器中启动application master的节点管理器</li><li>application master运行起来能做什么依赖于应用本身</li></ol><p>ResourceManager</p><ul><li>处理客户端请求</li><li>启动/监控ApplicationMaster</li><li>监控NodeManager</li><li>资源分配与调度</li></ul><p>NodeManager</p><ul><li>单个节点上的资源管理</li><li>处理ResourceManager的命令</li><li>处理ApplicationMaster的命令</li></ul><p>ApplicationMaster</p><ul><li>数据切分</li><li>为应用程序申请资源，并分配给内部任务</li><li>任务监控与容错</li></ul><p>Container</p><ul><li>对任务运行环境的抽象，封装CPU，内存等资源以及环境变量，启动命令等任务运行相关信息</li></ul><h3 id="YARN中的调度"><a href="#YARN中的调度" class="headerlink" title="YARN中的调度"></a>YARN中的调度</h3><p>YARN调度器是根据既定策略为应用分配资源，有三个调度器：</p><ul><li>FIFO调度器</li><li>容量调度器</li><li>公平调度器</li></ul><h5 id="FIFO调度器"><a href="#FIFO调度器" class="headerlink" title="FIFO调度器"></a>FIFO调度器</h5><p>FIFO调度器将应用放置在一个队列中，然后按照提交的顺序运行应用，先进先出。</p><h5 id="容量调度器"><a href="#容量调度器" class="headerlink" title="容量调度器"></a>容量调度器</h5><p>在FIFO中容易出现小作业阻塞，即等待大作业完成之后才能运行。</p><p>在容量调度器中，设置了一个独立的专门队列保存小作业，一提交就可以启动。与FIFO对比，容量调度器大作业执行时间要长。<br>在capacity-scheduler.xml文件中配置各个队列大小。</p><h5 id="公平调度器"><a href="#公平调度器" class="headerlink" title="公平调度器"></a>公平调度器</h5><p>不需要预留资源，调度器会在所有运行的作业之间动态平衡资源。</p><p>第一个大作业启动，它是唯一运行的作业，则会获得集群所有的资源。当第二个小作业启动，它被分配到集群的一半资源，但是它需要等待第一个作业将这一半资源释放。等第二个作业完成之后，大作业将会再次得到全部的资源。</p><p>在fair-scheduler.xml中配置各个队列大小（分配权重），用于公平共享计算。</p><p>抢占：允许调度器终止那些占用资源超过其公平共享份额的队列的容器，资源释放后可以分配给资源数量低于应得份额的队列。抢占功能有两个抢占超时设置：</p><ul><li>最小共享<br>在指定时间内未获得被承若的最小共享资源，调度器会抢占其他容器。</li><li>公平共享<br>在指定时间呃逆获得的资源仍然低于其公平共享份额的一半，调度器会抢占其他容器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS简介</title>
      <link href="/2019/01/19/HDFS%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/01/19/HDFS%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="HDFS简介"><a href="#HDFS简介" class="headerlink" title="HDFS简介"></a>HDFS简介</h2><h3 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h3><p>HDFS上的文件被划分为块大小的多个分块，作为独立的存储单元，默认大小128M，并且不到一个块大小的文件不会占用多余的空间，比如10M的文件，只会占用10M的大小，而且一个块的大小。</p><p>分布式文件系统抽象为块有如下好处</p><ul><li>一个文件的大小可以大于网络上任意一个磁盘的容量，文件可以不存放在一个磁盘上</li><li>简化了存储子系统的设计，例如可以简化管理</li><li>适合用于数据备份进而提供数据容错能力和提高可用性</li></ul><h3 id="namenode和datanode"><a href="#namenode和datanode" class="headerlink" title="namenode和datanode"></a>namenode和datanode</h3><p>HDFS集群有两类节点以管理节点-工作节点模式运行，即一个namenode和多个datanode。</p><h4 id="namenode"><a href="#namenode" class="headerlink" title="namenode"></a>namenode</h4><ul><li>namenode管理文件系统的命名空间，它维护着文件系统树及整棵树内所有的文件和目录。这些信息以命名空间镜像文件和编辑日志文件两个文件形式永久保存在本地磁盘上。</li><li>namenode在内存中保存文件系统中每个文件和每个数据块的引用关系。</li><li>namenode负责管理文件系统的名字空间以及客户端对文件的访问</li><li>namenode全权管理数据块的复制，它周期性得从集群中每个Datanode接收心跳信号（存活的象征）和块状态报告（节点上所有数据块的列表）。</li><li>跟文件内容相关的数据流不经过namenode，只会询问它跟哪个datanode联系</li><li>目录作为元数据保存在namenode中</li></ul><h5 id="datanode"><a href="#datanode" class="headerlink" title="datanode"></a>datanode</h5><ul><li>datanode是文件系统的工作结点。它们根据需要存储并检索数据块，并定期向namenode发送它们所存储的块的列表。</li><li>datanode启动后向namenode注册，通过后，定期向NameNode上报信息</li><li>心跳是每秒3次，心跳返回结果会带有复制数据，删除数据等命令。如果超过10分钟没有收到某个datanode的心跳，则认为该节点不可用</li></ul><h5 id="数据损坏的处理"><a href="#数据损坏的处理" class="headerlink" title="数据损坏的处理"></a>数据损坏的处理</h5><ol><li>当datanode读取block时，会计算checksum</li><li>如果计算的checksum与block创建时值不一样，说明block已坏，Client读取其他datanode上的block</li><li>namenode标记该块已经损坏，然后复制block达到预期设置的文件备份数</li><li>datanode在其文件创建三周后验证其checksum</li></ol><h3 id="namenode的容错与高可用"><a href="#namenode的容错与高可用" class="headerlink" title="namenode的容错与高可用"></a>namenode的容错与高可用</h3><p>当namenode服务器毁坏，文件系统上所有的文件会丢失，因此对namenode的容错很重要</p><ul><li>备份组成文件系统元数据持久状态的文件，使namenode在多个文件系统上保存元数据的持久状态</li><li>运行一个辅助namenode，可以定期合并编辑日志和命名空间镜像文件，并且会在namenode发生故障时启用。</li><li>活动-备用namenode，当活动namenode失效，备用namenode会接管它的任务并开始接收客户端的请求，不会有明显中断（实现namenode的高可用）<ul><li>namenode之间需要通过高可用共享存储实现编辑日志的共享。当备用namenode接管工作之后，可以通读共享编辑日志直至末尾，以实现活动namenode的状态同步</li><li>datanode需要同时向两个namenode发送数据块处理报告，数据块的映射信息存储在namenode的内存中</li><li>辅助namenode的角色被备用namenode所包含，备用namenode为活动的namenode命名空间设置周期性检查点</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/01/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><strong>时间复杂度：</strong>$O(n^2)$</p><p><strong>方法：</strong>依次找到数组中第一小，第二小，第三小…的数，并放置在对应的位置上</p><p><strong>每次排序后的结果：</strong>每次将未排序的数中的最小值排到正确的位置上</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> position <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到未排序的数中最小的数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span><span class="token punctuation">{</span>                min <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                position <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将找到的数放置在对应位置</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>        num<span class="token punctuation">[</span>position<span class="token punctuation">]</span> <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>时间复杂度：</strong>$O(n^2)$</p><p><strong>方法：</strong>当前的数与后一个数比较，如果比后面小，互换位置继续比较；如果比后面大，则用后面的代替该数继续比较</p><p><strong>每次排序后的结果：</strong>每次将未排序的数中的最大数放置在对应的位置</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> len <span class="token operator">=</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">int</span> max <span class="token operator">=</span> num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//每次选定第一个数，每一轮后第（len-i）排好序</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果后面小，不用变动数据位置，直接将下一个设置为最大</span>                  max <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果比后面大，则交换位置</span>                  num<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                  num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> num<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><strong>时间复杂度：</strong>$ O(n^2) $</p><p><strong>方法：</strong>选定一个数，向前比较，将它插入到比它大的数之前</p><p><strong>每次排序后的结果：</strong>放置好之后的数（包括该数）之前有序，即形成局部有序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sortNum <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//排第i个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>sortNum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 将比他大的数换一下位置</span>                num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sortNum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>时间复杂度：</strong>$O(n * logn)$</p><p><strong>方法：</strong>选定一个数，然后从前向后指针找比该数大的数，从后向前指针找比该数小的数，再交换这两个数，直到从前向后的坐标大于从后向前的坐标，之后再将选定的数与从前向后的最后指向的数交换位置，迭代进行</p><p><strong>每次排序后的结果：</strong>将选定的数排在正确的位置，左边全是比它小的数，右边全是比它大的数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//num为待排序的数组，left为左边界，right为右边界，每次选定数组的最左边的元素为待排元素</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sortNum <span class="token operator">=</span> num<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span>right<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//找比选定的数大的数</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">&amp;&amp;</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>sortNum<span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找比选定的数小的数</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">&amp;&amp;</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>sortNum<span class="token punctuation">)</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//交换</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//交换选定元素sortNum和最后left指定的数</span>    num<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sortNum<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分别对前半部分，后半部分排序，迭代</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>left<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">></span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>时间复杂度：</strong>$O(n*logn)$</p><p><strong>方法：</strong>自低向上，不断合并每个小有序数据，最后形成最终有序</p><p><strong>每次排序后的结果：</strong>每个小有序数据合并成大的有序数列</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergerSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//只有一个元素时直接返回</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">==</span> left<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> answer <span class="token operator">=</span> <span class="token punctuation">{</span>num<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> answer<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> answer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftNum<span class="token punctuation">;</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightNum<span class="token punctuation">;</span>     <span class="token keyword">int</span> leftMid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>left<span class="token operator">+</span>mid<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> rightMid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>right<span class="token operator">+</span>mid<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     leftNum <span class="token operator">=</span> <span class="token function">mergerSort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>left<span class="token punctuation">,</span>leftMid<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>     rightNum <span class="token operator">=</span> <span class="token function">mergerSort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>rightMid<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//合并</span>     <span class="token keyword">int</span> leftLen <span class="token operator">=</span> leftNum<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token keyword">int</span> rightLen <span class="token operator">=</span> rightNum<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>leftLen <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>rightLen<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>leftNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>rightNum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             answer<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftNum<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>leftNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>rightNum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             answer<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightNum<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>leftLen<span class="token punctuation">)</span><span class="token punctuation">{</span>         answer<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftNum<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">&lt;</span>rightLen<span class="token punctuation">)</span><span class="token punctuation">{</span>         answer<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightNum<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> answer<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase数据模型</title>
      <link href="/2019/01/15/Hbase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/01/15/Hbase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Hbase很适合存储不确定列，不确定大小的半结构化数据</p><h2 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h2><p>Hbase是一个键值（key-value）型数据库。Hbase数据行列值可以是空白的，且这些空白行列值不占用存储空间，所以Hbase存储的数据是稀疏的。</p><ul><li><p>表（table）：类似于关系型数据库中的表，即数据行的集合。一个表可以包含一个或者多个分区（region）</p></li><li><p>行键（row key）：用来标识表中唯一的一行数据，类似于关系型数据库中表的主键（不同的是从底层储存来说，行键不能唯一标识一行数据，因为Hbase数据行可以有多个版本，版本用时间戳表示），表中的数据按行键的字典序排序</p></li><li><p>列族（column family）：<strong>Hbase是一个列式存储数据库</strong>，所谓的列式就是根据列族存储，每个列族有一个存储仓库（Store），每个Store有一个内存仓库（MemStore）和多个存储文件（StoreFile）</p></li><li><p>列限定符（column qualifier）：每个列族可以有任意个列限定符用来标识不同的列，这个列类似于关系型数据库中的一列，不同的是，列可以在表创建时不指定，在需要使用时动态插入</p></li><li><p>单元格（cell）：由<strong>行键，列族，列限定符，时间戳，类型</strong>唯一决定，是Hbase数据的存储单元，以字节码的形式存储</p></li><li><p>版本（version）：Hbase数据写入后无法被修改的，数据的PUT操作在写入预写入日志（write-ahead-log）（类似于redo log）后，先写入内存仓库（MemStore），同时在内存中按行键排序，最后再将MemStore中的数据刷新到磁盘的StoreFile文件。因为数据已经排序，所以只需要顺序写入磁盘，这样的顺序写入对磁盘来说效率很高。由于数据不会被修改，因此数据会有多个版本，这些数据都会有一个时间戳用来标识数据写入的时间</p></li><li><p>分区（region）：Hbase的分区时集群中高可用，动态扩展，负载均衡的最小单元。</p></li></ul><p>例如表</p><p><img src="%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt=""></p><ul><li>行键可以定位到一行数据</li><li>列族用来定位到列族文件</li><li>列限定符定位到数据的某一列即某个键值对</li><li>时间戳定位到键值对的某一个时间版本数据</li></ul><h2 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h2><p>Hbase是一个列式存储数据库，数据按照列族聚簇存储再存储文件中，空白的列单元不会被存储。</p><ol><li>HBase中表按照行键的范围被划分为不同的分区，各个分区由分区服务器负责管理并提供数据读写服务，HBase主节点进程（HMaster）负责分区的分配以及在集群中的集群</li><li>一个分区同时有且仅有一个分区服务器提供服务，一个分区下的每个列族都会有一个存储仓库</li><li>每个Store（存储仓库）有且仅有一个MemStore（内存仓库），但是可以有多个存储文件，存储文件只会顺序写入，不支持修改</li><li>数据块（block）是Hbase中数据读取的最小单元，StoreFile由数据块组成，可以在建表时按列族指定表数据的数据块大小</li></ol><p>物理视图如下：</p><p><img src="%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BE.png" alt=""></p><p>HBase模块交互如下</p><p><img src="%E6%A8%A1%E5%9D%97%E4%BA%A4%E4%BA%92.png" alt=""></p><ul><li>HMaster：负责监控集群中所有的分区服务器进程（HRegionServer），负责所有数据的更新，负责分区在分区服务器中的负载均衡，在一个分布式环境中，HMaster进程通常与Hadoop的NameNode运行在同一个节点，每个集群中会部署至少两个HMaster节点，一个作为活跃节点提供服务，一个作为备用节点提供快速的灾备切换，保证集群高可用。</li><li>HRegionServer：管理其负责的分区，处理分区的读写请求，分区增大的拆分，以及分区的压缩。Hbase客户端对数据的读写直接与分区服务器交互，因此对分区的读写不会对HMater造成压力。HRegionServer通常与Hadoop的DataNode运行在一个节点，这样对数据的读写可以尽量做到本地读取，减少网络请求。</li><li>WAL：默认情况下一个分区服务器仅有一个WAL，Hbase客户端数据请求操作会先写入WAL文件再写入内存仓库MemStore，当MemStore到达配置大小或者集群中所有MemStore使用的总内存达到配置的阈值百分比时，MemStore会刷新一个StoreFile到磁盘。当服务器宕机时，可以用WAL来恢复分区服务器的状态。</li><li>MemStore：MemStore位于分区服务器的堆内存，数据再写入MemStore时候会按行键的字典序排序，Mem作为一个内存级缓存，能够提供对新写入数据的快速访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase模式设计实例</title>
      <link href="/2019/01/15/Hbase%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/01/15/Hbase%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="用户行为日志系统"><a href="#用户行为日志系统" class="headerlink" title="用户行为日志系统"></a>用户行为日志系统</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p><strong>数据类型</strong></p><ul><li>用户商品浏览记录</li><li>用户商品下单记录</li></ul><p><strong>统计需求</strong></p><ul><li>需要查询同一个用户一段时间内浏览过的商品，用来做用户商品推荐以提高转化率</li><li>需要统计某个商品在某天的转化率，用来分析各渠道或者营销方式的优劣</li></ul><p><strong>数据特征</strong></p><ul><li>数据一旦写入就不会被修改</li><li>越旧的数据使用越少，越新的数据使用越多</li><li>数据通常需要被大批量读取用作分析</li></ul><h3 id="行键设计"><a href="#行键设计" class="headerlink" title="行键设计"></a>行键设计</h3><h4 id="两个需求"><a href="#两个需求" class="headerlink" title="两个需求"></a>两个需求</h4><p><strong>查询同一个用户一段时间内浏览过的商品</strong></p><p>该需求有两个数据查询维度，第一个为用户，第二个为时间。</p><ul><li>为了提高查询性能，将同一个用户的数据聚簇地放在一起，因此将用户ID作为行键地开始</li><li>需要根据时间查询，类似Mysql中的聚集索引，可以将时间放在第二个位置，格式为：[用户ID]_[时间戳]</li><li>假设极端情况，用户同时打开多个商品，这些商品的时间戳可能相同，可以在行键最后加上一个序列号</li></ul><p>最后设计的行键：[用户ID]_ [时间戳]_[序列号]</p><p><strong>统计某个商品某天的专户率</strong></p><p>转化率的定义是商品下单数除以商品浏览数，需要三个维度的数据，第一个是商品，第二个是数据类型（0表示浏览，1表示记录），第三个是时间。</p><p>根据上一个例子，该行键可以设计为：[商品ID] _[数据类型] _[时间戳] _[序列号]</p><h4 id="行键与二级索引"><a href="#行键与二级索引" class="headerlink" title="行键与二级索引"></a>行键与二级索引</h4><p>如果一张表同时满足以上两个需求，可以考虑在用户维度构建行键存储数据，按商品维度建立二级索引满足商品维度统计需求。如下：</p><p><img src="%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E8%A1%A8.png" alt=""></p><p>行键1：[用户ID]_ [时间戳]_ [序列号]，例如12345_1510720956000_1</p><p>行键2：[分区开始键]_ [索引名称] _[商品ID] _[数据类型] _[时间戳] _ [数据行键]，该行键是一个二级索引</p><ul><li>使用分区开始键作为行键的前缀是为了让索引和数据在同一个分区，这样读取索引和数据的请求会落在同一个分区服务器，否则可能需要在一个分区服务器读取索引后，再到另一个分区服务器读取数据</li><li>索引名称，就是给这个二级索引起一个名字</li><li>数据行键，指得是行键1，相当于就是二级索引。行键2过滤数据后再定位到行键1，再读取数据，多级索引</li><li>二级索引，一般会根据索引行键得到数据行键，再根据数据行键去查询数据</li></ul><p><strong>读取数据示例</strong></p><ul><li><p><strong>查询同一个用户一段时间内浏览过的商品</strong></p><p>扫描请求只需要指定该用户的最小行键和最大行键。例如，用户查询用户12345从2017年12月1日到2018年1月1日之间的浏览记录，只需要指定查询区间[12345_ 1512086400000，12345_1514764800000]</p></li><li><p><strong>统计某个商品某天的专户率</strong></p><p>利用二级索引查询。例如，查询2018年1月1日当天的1001的转化率，需要扫描的区间为[12345_idx1_1001_0_151476400000, 12345_idx1_1001_1_1514851200000]，并且只需要扫描索引索引行键，拿到所有的索引行键再根据数据类型过滤即可。</p></li></ul><h2 id="微信朋友圈"><a href="#微信朋友圈" class="headerlink" title="微信朋友圈"></a>微信朋友圈</h2><p>朋友圈的核心是每个用户各自拥有一个自己发布的相册和一个用户关注的好友的动态，称之为时间线。</p><p>假如：A发朋友圈，B是A的好友，B刷新朋友圈刷到A干刚刚发布的内容</p><ul><li>A发布一张朋友圈图片，该图片会上传到A最近的CDN缓存服务器，上传成功后返回一个图片引用地址</li><li>A的微信客户端将朋友圈的内容以及图片引用地址发布到微信服务器自己的相册</li><li>查找那些用户关注了A，将A发布的朋友圈内容以及图片插入到这些用户的TimeLine（时间线）</li><li>B刷新自己的朋友圈，直接从B的时间线表查询数据即可</li></ul><p>上诉过程一共设计到四张表的设计</p><ul><li><p>user表，记录用户ID与微信昵称的对应关系</p><p><img src="%E7%94%A8%E6%88%B7%E8%A1%A8.png" alt=""></p></li><li><p>好友表，记录用户之间是否关注</p><p>可以使用高表或者宽表记录，该表只能查询关注的用户，查询关注自己的用户，需要构建另一张与此类似的表</p><ul><li><p>宽表，用户ID为行键，一行的数据为该用户关注的所有用户</p><p><img src="%E7%94%A8%E6%88%B7%E5%85%B3%E7%B3%BB%E8%A1%A8-%E5%AE%BD%E8%A1%A8.png" alt=""></p></li><li><p>高表，用户ID和关注的用户混合行键</p><p><img src="%E7%94%A8%E6%88%B7%E5%85%B3%E7%B3%BB%E8%A1%A8-%E9%AB%98%E8%A1%A8.png" alt=""></p></li></ul></li><li><p>用户朋友圈表，记录用户发布的朋友圈内容</p><p><img src="%E7%94%A8%E6%88%B7%E6%9C%8B%E5%8F%8B%E5%9C%88.png" alt=""></p><ul><li>行键：用户ID_时间戳</li><li>t：朋友圈内容</li><li>p：图片链接</li></ul></li><li><p>用户时间线表，记录关注的好友发布的朋友圈内容</p><p><img src="%E6%97%B6%E9%97%B4%E7%BA%BF.png" alt=""></p><ul><li>行键：用户ID_时间戳 _发布者ID</li><li>t：朋友圈内容</li><li>p：图片链接</li><li>u：发布者个人基本信息（昵称头像）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaAgent</title>
      <link href="/2019/01/15/JavaAgent/"/>
      <url>/2019/01/15/JavaAgent/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="RASP简介"><a href="#RASP简介" class="headerlink" title="RASP简介"></a>RASP简介</h3><p>目前主流的Web应用安全防护产品方案较多的是 WAF(Web Application Firewall)和RASP(Runtime Application Self-Protection)。</p><p>WAF</p><ul><li>WAF是门卫模型，通常部署在Web应用系统的外部边界，所有正常或恶意流量都需要通过特征规则和模式识别，通过特定的规则和模式识别出恶意请求，并且把它们拒之门外，拒绝向高风险的Web请求提供服务。</li><li>WAF虽然可以有效个过滤出绝大多数恶意请求，但是不知道应用运行时的上下文，必然会造成一定程度的误报。并且WAF严重依赖于特征库，各种花式绕过，导致特征编写很难以不变应万变。</li></ul><p>RASP</p><ul><li>RASP的不同就在于运行在应用之中，RASP代码与应用代码融为一体，可以获取到应用运行时的上下文行为，根据运行时上下文或者敏感行为操作，对攻击进行精准的识别或拦截。</li><li>RASP运行在应用之中，只要检测点选取合理，获取到的payload已经是解码过的真实payload，可以减少由于WAF规则的不完善导致的漏报。</li></ul><h3 id="RASP实现"><a href="#RASP实现" class="headerlink" title="RASP实现"></a>RASP实现</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Java版的RASP技术使用Javaagent实现。在启动服务器时，利用javaagent参数可以动态修改Java字节码，对敏感函数进行监测。比如数据库操作，文件读取，命令执行等等函数。当服务器被攻击时，RASP会通过检测函数的参数，并对其进行识别判断最后做出拦截或者上传报警等操作。</p><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ul><li>启动时首先会进入Javaaagent的premain函数，该函数在main函数执行之前执行</li><li>javaagent通过字节码修改工具可以修改应用中的函数对其进行监测</li></ul><h2 id="Instrumentation技术"><a href="#Instrumentation技术" class="headerlink" title="Instrumentation技术"></a>Instrumentation技术</h2><p>RASP需要使用到Java Instrument技术。使用Instrument，开发者可以构建一个独立于应用程序的代理（Agent）程序，用来协助或监测在JVM上运行上的程序，也可以替换或修改某些类的定义，这种特性提供了虚拟机级别的AOP实现。</p><p>让Instrument代理在main函数运行前执行，需要如下几个步骤</p><ul><li><p>编写premain函数</p><p>编写一个java类，包含如下两个方法中的任何一个</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">,</span> Instrumentation instrument<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre><p>agentArgs 是 premain 函数得到的程序参数，随同 “<code>– javaagent</code>”一起传入。</p><p>instrument是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。</p><p>在这个premain函数中，可以定义各种对类的操作。</p></li><li><p>jar文件打包</p><p>将带有premain函数的类打包成一个jar文件，并在其中的 manifest 属性当中加入” Premain-Class”来指定步骤 1 当中编写的那个带有 premain 的 Java 类。</p></li><li><p>运行</p><p>利用javaagent参数运行随应用程序运行jar包</p><pre class=" language-java"><code class="language-java">java <span class="token operator">-</span>javaagent<span class="token operator">:</span>jar文件的位置 <span class="token punctuation">[</span><span class="token operator">=</span> 传入 premain 的参数 <span class="token punctuation">]</span></code></pre></li></ul><p>Instrument的主要方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Instrumentation</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 注册一个Transformer，从此之后的类加载都会被 transformer 拦截。     * ClassFileTransformer 的 transform 方法可以直接对类的字节码进行修改，但是只能修改方法体，不能变更方法签名、增加和删除方法/类的成员属性     */</span>    <span class="token keyword">void</span> <span class="token function">addTransformer</span><span class="token punctuation">(</span>ClassFileTransformer transformer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 对JVM已经加载的类重新触发类加载，使用上面注册的 ClassFileTransformer 重新对类进行修饰。     */</span>    <span class="token keyword">void</span> <span class="token function">retransformClasses</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> classes<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnmodifiableClassException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 重新定义类，不是使用 transformer 修饰，而是把处理结果(bytecode)直接给JVM。     * 调用此方法同样只能修改方法体，不能变更方法签名、增加和删除方法/类的成员属性     */</span>    <span class="token keyword">void</span> <span class="token function">redefineClasses</span><span class="token punctuation">(</span>ClassDefinition<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> definitions<span class="token punctuation">)</span> <span class="token keyword">throws</span>  ClassNotFoundException<span class="token punctuation">,</span> UnmodifiableClassException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取一个对象的大小     */</span>    <span class="token keyword">long</span> <span class="token function">getObjectSize</span><span class="token punctuation">(</span>Object objectToSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 将一个jar加入到bootstrap classloader 的 classpath 里     */</span>    <span class="token keyword">void</span> <span class="token function">appendToBootstrapClassLoaderSearch</span><span class="token punctuation">(</span>JarFile jarfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 将一个jar加入到 system classloader 的 classpath 里     */</span>    <span class="token keyword">void</span> <span class="token function">appendToSystemClassLoaderSearch</span><span class="token punctuation">(</span>JarFile jarfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取当前被JVM加载的所有类对象     */</span>    Class<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAllLoadedClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="动态字节码技术"><a href="#动态字节码技术" class="headerlink" title="动态字节码技术"></a>动态字节码技术</h2><p>javassist是一个开源的分析、编辑和创建java字节码的类库。Javassist 中最为重要的是 ClassPool，CtClass ，CtMethod 以及 CtField 这几个类。</p><ul><li><p>ClassPool：一个基于 Hashtable 实现的 CtClass 对象容器，其中键是类名称，值是表示该类的 CtClass 对象。</p></li><li><p>CtClass：CtClass 表示类，一个 CtClass (编译时类）对象可以处理一个 class 文件，这些 CtClass 对象可以从 ClassPool 获得。</p></li><li><p>CtMethods：表示类中的方法。</p></li><li><p>CtFields ：表示类中的字段。</p></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Agent程序"><a href="#Agent程序" class="headerlink" title="Agent程序"></a>Agent程序</h3><p>带有premain函数的类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>Instrumentation<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">,</span> Instrumentation instrumentation<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        <span class="token function">Agent</span><span class="token punctuation">(</span>agentArgs<span class="token punctuation">,</span>instrumentation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Agent</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">,</span> Instrumentation instrumentation<span class="token punctuation">)</span><span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Agent atguments:"</span><span class="token operator">+</span>agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>        JavassistTransformer transformer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JavassistTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要修改的类</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"test.Target"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            instrumentation<span class="token punctuation">.</span><span class="token function">addTransformer</span><span class="token punctuation">(</span>transformer<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            instrumentation<span class="token punctuation">.</span><span class="token function">retransformClasses</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            instrumentation<span class="token punctuation">.</span><span class="token function">removeTransformer</span><span class="token punctuation">(</span>transformer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实现ClassFileTransformer接口的类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>ClassPool<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>CtClass<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>CtMethod<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>ClassFileTransformer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>IllegalClassFormatException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ProtectionDomain<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavassistTransformer</span> <span class="token keyword">implements</span> <span class="token class-name">ClassFileTransformer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transform</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> String className<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> classBeingRedefined<span class="token punctuation">,</span>                            ProtectionDomain protectionDomain<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classfileBuffer<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalClassFormatException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取全部的CtClass对象</span>            ClassPool cp <span class="token operator">=</span> ClassPool<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//获取对应的类</span>            CtClass ctClass <span class="token operator">=</span> cp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classBeingRedefined<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//需要修改的方法</span>            CtMethod ctMethod <span class="token operator">=</span> ctClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//在方法执行之前之后加入两个输出语句</span>            ctMethod<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token string">"System.out.println(\"Before say hello.\");"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ctMethod<span class="token punctuation">.</span><span class="token function">insertAfter</span><span class="token punctuation">(</span><span class="token string">"System.out.println(\"After say hello.\");"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> ctClass<span class="token punctuation">.</span><span class="token function">toBytecode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ctClass<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> classData<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> classfileBuffer<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>pom.xml打包文件</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>agent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdk.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdk.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaassist.version</span><span class="token punctuation">></span></span>3.21.0-GA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaassist.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${javaassist.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fork</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fork</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>${jdk.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>${jdk.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-resources-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>useDefaultDelimiters</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>useDefaultDelimiters</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>overwrite</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>overwrite</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delimiters</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delimiter</span><span class="token punctuation">></span></span>@<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delimiter</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delimiters</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-jar-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestFile</span><span class="token punctuation">></span></span>src/main/resources/META-INF/MANIFEST.MF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestFile</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-assembly-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appendAssemblyId</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appendAssemblyId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRefs</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRef</span><span class="token punctuation">></span></span>jar-with-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRef</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRefs</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestFile</span><span class="token punctuation">></span></span>src/main/resources/META-INF/MANIFEST.MF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestFile</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>make-assembly-package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>single<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>打包配置文件MANIFEST.MF</p><pre><code>Premain-Class: com.test.AgentDemoCan-Retransform-Classes: true</code></pre><h3 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h3><p>启动类（带main函数）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Target</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Target类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>类启动配置(IntelliJ在VM option中配置)</p><pre><code>-javaagent:C:/Users/10920/Downloads/Program/Java/AgentDemo/target/agent-1.0-SNAPSHOT.jar=&quot;I am agent arguments&quot;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1426685" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1426685</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html</a></p><p><a href="https://www.cnblogs.com/chiangchou/p/javassist.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiangchou/p/javassist.html</a></p><p><a href="https://blog.csdn.net/helowken2/article/details/103110368" target="_blank" rel="noopener">https://blog.csdn.net/helowken2/article/details/103110368</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读扩散写扩散</title>
      <link href="/2019/01/15/%E8%AF%BB%E6%89%A9%E6%95%A3%E5%86%99%E6%89%A9%E6%95%A3/"/>
      <url>/2019/01/15/%E8%AF%BB%E6%89%A9%E6%95%A3%E5%86%99%E6%89%A9%E6%95%A3/</url>
      
        <content type="html"><![CDATA[<p>在阅读HBase入门与实践这本书时，模式设计模块有一部分内容写到，微信朋友圈运用写扩散模型提高读的效率，即将一个用户发的朋友圈同步到该用户好友的时间线中。这次找到资料，稍微了解了解读扩散与写扩散。</p><h2 id="读扩散-VS-写扩散"><a href="#读扩散-VS-写扩散" class="headerlink" title="读扩散 VS 写扩散"></a>读扩散 VS 写扩散</h2><p>消息同步模型中，有写扩散和读扩散两种模型，讨论这两种模型涉及下面两个相关概念</p><ul><li>收件箱：该用户收到的消息</li><li>发件箱：该用户发出的消息</li></ul><h3 id="写扩散"><a href="#写扩散" class="headerlink" title="写扩散"></a>写扩散</h3><p>写扩散就是push模式，即每个消息都直接发送到该用户的收件箱中。</p><ul><li>优点：读优化，用户每次只需要去读取自己收件箱的消息即可</li><li>缺点：写很重，如果一条消息是群发消息，那么一个群成员发送出去的消息将拷贝到所有其余群成员的收件箱中</li></ul><p>朋友圈系统也是如此，将一个用户发的朋友圈内容同步到其所有好友的时间线中，当其好友刷新朋友圈时，直接到其好友的时间线中读取消息即可。</p><p><img src="%E5%86%99%E6%89%A9%E6%95%A3.png" alt=""></p><h3 id="读扩散"><a href="#读扩散" class="headerlink" title="读扩散"></a>读扩散</h3><p>读扩散就是pull模式，用户每次到消息发送者的发件箱去拉取信息</p><ul><li>优点：写优化，每次发送的消息只需要写到一个地方，由收件者自己拉取消息即可</li><li>缺点：读操作很重，假设用户重新登陆，要去其全部好友的发件箱读取消息</li></ul><p><img src="%E8%AF%BB%E6%89%A9%E6%95%A3.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.codedump.info/post/20190608-im-msg-storage/" target="_blank" rel="noopener">https://www.codedump.info/post/20190608-im-msg-storage/</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域</title>
      <link href="/2019/01/13/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/01/13/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>JDK7的内存区域如下</p><ul><li>线程私有：虚拟机栈，本地方法栈，程序计数器</li><li>线程共享：堆内存，方法区</li></ul><p><img src="java7%E5%86%85%E5%AD%98.png" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>虚拟机中的程序计数器和计算机的程序计数器(PC)作用类似，可以看成当前线程所执行的字节码的行号指示器，用来记录下一条要执行的指令。</p><p>该区域没有规定任何OutMemeryError情况</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈用来描述<strong>java方法</strong>执行的内存模型，每个方法在执行的同时会创建一个栈帧。</p><p>栈帧中存放局部变量表，操作数栈，动态链接，方法出口</p><p>其中局部变量表存放编译器可知的各种数据类型，对象引用，returnAddress类型(执行下一条指令)，局部变量表所需要的内存空间在编译期间完成分配</p><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt=""></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆中存放所有的对象实例以及数组</p><p>堆内部也进行了分块划分，如下，这个划分会在垃圾回收时使用。</p><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86.png" alt=""></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区存储已被虚拟机加载的<strong>类信息</strong>，<strong>常量</strong>，<strong>静态常量</strong>，<strong>即时编译器编译的代码</strong>，该区域通常被称为“永久代”</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池时方法区的一部分，用于存放编译期生成的各种字面量和符号的引用</p><h3 id="jdk1-8的变化"><a href="#jdk1-8的变化" class="headerlink" title="jdk1.8的变化"></a>jdk1.8的变化</h3><ol><li>将方法区除运行时常量池部分移动到了直接内存</li><li>将运行时常量池部分移动到了堆中</li></ol><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt=""></p><h2 id="java的对象"><a href="#java的对象" class="headerlink" title="java的对象"></a>java的对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当虚拟机遇到一个new指令时</p><p><img src="java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.png" alt=""></p><ul><li><p>检查类是否已经加载</p><p>判断该类是否已被加载，解析，初始化，若没有的话，必须先执行类加载过程</p></li><li><p>为对象分配内存</p><p>对象所需要的内存大小在类加载完成之后便可完全确定。在类加载检查通过后，虚拟机将为对象分配内存。</p></li><li><p>初始化零值</p><p>内存分配完之后，虚拟机将分配到的内存空间都初始化为零值。这一步保证对象的实例字段在java代码中可以不赋初始值就可以直接使用，程序能访问这些字段的数据类型所对应的零值</p></li><li><p>对象头信息设置</p><p>虚拟机堆对对象进行必要的设置，例如对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码等等，这些信息都在对象头之中</p></li><li><p>执行init方法</p><p>最后一步即把对象按照程序员的意愿进行初始化</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机第二版》</p><p><a href="https://blog.csdn.net/bruce128/article/details/79357870" target="_blank" rel="noopener">https://blog.csdn.net/bruce128/article/details/79357870</a></p><p><a href="https://juejin.im/post/5a14de6751882555cc417df7" target="_blank" rel="noopener">https://juejin.im/post/5a14de6751882555cc417df7</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码阅读</title>
      <link href="/2019/01/12/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2019/01/12/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>Hashmap存储键值对，其根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，遍历顺序与插入顺序不一致。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。</p><p>特点</p><ul><li>根据键的hashcode值存储</li><li>hashmap通过Node&lt;K,V&gt;类型的table数组存储数据</li><li>hash冲突通过链表和红黑树解决，table数组中的元素指向链表或者红黑树</li><li>当链表长度大于8时，链表转为红黑树；当红黑树的节点个数少于6时，红黑树转为链表</li></ul><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>静态常量参数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认容量为16，hashmap的容量必须是2的正次幂</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">//最大容量，2^30</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//装载因子，用于判断是否需要扩容</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表转换为红黑树的阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红黑树转为链表的阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化。否则桶内元素太多时会扩容，而不是树形化。</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span></code></pre><p>属性参数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//hash桶，数组长度是2的整次幂</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//元素缓存set</span><span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//元素个数</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改次数，包括添加删除</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//扩容的阈值，当size大于threshold进行扩容</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//装载因子=(size/capacity),即所有元素比上桶的数量，默认0.75</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span></code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>hashmap一共提供了三个构造方法，这三个方法仅仅是将给一些参数复制，并没有初始化table数组，而等到放入第一个元素时，即调用put方法时，数组才会初始化，后面讲诉。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认的构造方法，默认的加载因子为0.75，该地方没有指定大小，会在resize()方法中指定默认大小</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all other fields defaulted</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定大小，使用默认的加载因子0.75</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定大小个装载因子</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设定装载因子</span>        <span class="token comment" spellcheck="true">/*这个地方比较迷，如下：          1. threshold是指扩容的阈值，当size大于threshold时，数据会扩容。          2. tableSize返回的是最小的大于等于initialCapacity的2的整次幂，例如，给定10，返回16          3. 根据threshold的定义，其threshold = table.length*loadFactor        */</span>        <span class="token comment" spellcheck="true">/*         *你会发现，threshold大于等于初始化的大小，比数组大小还大，根据其定义根本无法扩容。         *当debug到数组初始化时，会发现将threshold赋值给数组的大小         *这里threshold就是代表数组的长度，而随后threshold会根据长度*加载因子计算出        */</span>        <span class="token comment" spellcheck="true">/*          我自己的想法如下：          1. HashMap中没有表示数组长度的参数，获取数组长度通过table.length获取          2. 因为没有表示长度的参数，所以先使用threshold暂时表示数组的长度        */</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>HashMap中table数组长度是2的整次幂，通过如下实现</p><ul><li><p>初始化时，通过tableSizeFor()方法计算给定大小initialCapacity的最小的大于等于initialCapacity的2的整次幂，再通过threshold参数暂时表示数组长度。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//该方法实现：返回最小的大于等于输入参数cap的2的整次幂。</span><span class="token comment" spellcheck="true">//原理如下:</span><span class="token comment" spellcheck="true">/* 先来假设n的二进制为01xxx…xxx * 对n右移1位：001xx...xxx，再位或：011xx...xxx * 对n右移2为：00011...xxx，再位或：01111...xxx * 每一操作就是将1的个数翻倍 * 该算法就是将最高位的1后面的位全变为1。 * 最后再n+1就可以得到2的整次幂了 * * 而对于最开始的cap-1是针对cap本身就是2的整次幂这种特殊情况 * 例如：当给定16，即10000时，若不减1，先会得到11111，再加1，得到100000，为32，扩大二倍 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>给一个详细的例子：</p><p><img src="tableSizeFor.png" alt=""></p></li><li><p>在resize()方法中，每次扩容都会将数组长度扩大二倍</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>         threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>         <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>              oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//oldCap左移一位，即扩大二倍</span>         newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold，新的threshold为老的二倍</span> <span class="token punctuation">}</span></code></pre></li></ul><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>HashMap有几个非常重要的辅助方法，比如计算元素在table中位置的方法，即hash机制，以及每次table数组空间不够时要进行扩容时使用的扩容函数。</p><h4 id="hash机制"><a href="#hash机制" class="headerlink" title="hash机制"></a>hash机制</h4><p>hash机制主要是计算元素应该放在table数组哪一个位置，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1. 先去key的hashCode值，32位整数。</span><span class="token comment" spellcheck="true">//2. 将hashCode无符号右移，即将高16位放在低16位上</span><span class="token comment" spellcheck="true">//3. 将1和2的结果或，即hashCode的高16位与低16位或的结果放在低16位，高16位不变</span><span class="token comment" spellcheck="true">//4. 高16位与低16与的好处就是可以使用hashcode的所有特征，增加随机性，利于数据分散</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//无符号右移，左边部分总是以0填充，右边部分舍弃</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面是定位取数操作(选自put方法)，n表示数组的长度</span><span class="token comment" spellcheck="true">//位置结果为n减1再与hash值与，分析如下</span><span class="token comment" spellcheck="true">//1. n为2的整次幂，例如10000，减一之后为01111，设1的个数为x</span><span class="token comment" spellcheck="true">//2. (n-1)与hash与，即保持后x位不变，前(32-x)位全为0，而后x位的值表示的就是该元素的下标</span>tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span></code></pre><p>例如，一个值经过hash之后为<strong>10100101 11000100 00100101</strong>，当前长度为16，即n-1=15，所以有如下结果</p><pre><code>    10100101 11000100 00100101&amp;   00000000 00000000 00001111    //15----------------------------------    00000000 00000000 00000101    //高位全部归零，只保留末四位</code></pre><p>将数组长度设置为2的整次幂，当减1之后，得到的数就像一个掩码一样，取后面几位。</p><p>整体过程如下：</p><p><img src="hash%E6%9C%BA%E5%88%B6.png" alt="hash机制"></p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>扩容机制是非常重要的,其保证table长度始终是2的整次幂。</p><p>扩容函数除了将数组扩大二倍之外，在初始化数组中也会应用到。</p><p>在resize()函数中，会先创建一个扩容后的数组，然后再将原来的数据移动到新的数组中，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第一步是先计算新的数组长度和扩容阈值，这里分为三种情况</span>    <span class="token comment" spellcheck="true">//1. 已经初始化过数组，只需要将长度扩大二倍，扩容阈值扩大二倍，注意要检查是否超出最大的范围</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                 oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先将数据长度扩大二倍，再将扩容阈值扩大二倍</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//下面两种情况是还没有初始化数组，现在要先进行初始化</span>    <span class="token comment" spellcheck="true">// 2. 对于HashMap(int initialCapacity)，HashMap(int initialCapacity, float loadFactor)，这两种情况均指定了threshold,大小为2的整次幂，即代表数组的长度，现在将扩容阈值复制给数组长度</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>         newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//3. 对于默认情况，仅定义了loadFactor，初始化为默认大小，扩容阈值=数组长度*扩容因子</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//继续接情况2，2情况下只指明了数组大小，没有指明扩容阈值，下面计算扩容阈值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计算扩容阈值</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据新长度new出一个数组</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是第一次放元素，即oldTab为null，会直接返回新创建的数组</span>    <span class="token comment" spellcheck="true">//第二步，将老数组中的元素移动到新数组中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//获取老数组中的元素</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将老数组清空，垃圾回收</span>                <span class="token comment" spellcheck="true">//将老数组中元素移动到新数组也分为三种情况</span>                <span class="token comment" spellcheck="true">//1. 桶中只有一个元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">//计算在数组中的位置的方法和之前一样</span>                    <span class="token comment" spellcheck="true">//注意这里是新的数组的长度，在二进制表示上，相当于多了一位1，会有下面两种情况</span>                    <span class="token comment" spellcheck="true">//假设，之前数组长度为16（15=1111），现在为32（31=11111）</span>                    <span class="token comment" spellcheck="true">//（1）.当其hash值第5位为1，则在新位置比老位置多了oldCap的长度</span>                    <span class="token comment" spellcheck="true">//（2）.当其hash值第5位为0，则在老位置不变换</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//2. 桶中结构是红黑树</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//3. 桶中结构是链表</span>                    <span class="token comment" spellcheck="true">//和桶中只有一个元素的情况一样，判断多出来的一位是0还是1</span>                    <span class="token comment" spellcheck="true">/** 首先是先将老数组的元素分发到两个链表中                     *  多出的一位为0，将数据放在lohead，loTail链表中                     *  多出的一位为1，将数据放在hiHead，hiTail链表中                     */</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//链表中下一个位置</span>                        <span class="token comment" spellcheck="true">//将多出一位为0的数，放在头元素是loHead，尾元素是loTail的链表中</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//将多出的一位为1的数，放在头元素是hiHead，尾元素是hiTail的链表中</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//将上述的两个链表放在对应的桶中</span>                    <span class="token comment" spellcheck="true">/** 由老数组存放到链表中时，是从头到尾遍历存放                     *  而从链表存放到新数组中，是从尾到头逆序存放                     *  因此新数组相对于旧数组会逆序                     */</span>                     <span class="token comment" spellcheck="true">//多出一位为0的，在原位置不动</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//多出一位为1的，新位置比原位置大了oldCap</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上诉判断新坐标过程如下：</p><p>扩容前长度为16，key1的坐标为5，key2的坐标为5</p><p>扩容后长度为32，key1的坐标为5，key2的坐标为21</p><p><img src="%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.png" alt=""></p><p>key2的变化如下：</p><p><img src="%E6%89%A9%E5%AE%B9%E7%BB%93%E6%9E%9C.png" alt=""></p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>常用的操作主要有添加，删除，查找这三种，这里也主要阅读了这三个方法的源码。</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//put方法会将要添加的数据添加到对应的桶中，而且table数组的初始化也放生在第一次添加数据时</span><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数组还未初始化，调用resize()方法，返回初始化的数组</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//下面开始存放元素，分为3种情况</span>    <span class="token comment" spellcheck="true">//1. 桶中没有任何元素，直接放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>         K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//仍然对应第一种情况，如果存在元素，key也相同，替换元素即可</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2. 桶中有元素，结构为红黑树</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//3. 桶中有元素，结构为链表</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//添加到链表尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果超过树形化的阈值，将链表转为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//找到key相同的值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//当找到key相同时，替换元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断是否需要扩容</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span>         null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">,</span> Object value<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> null<span class="token punctuation">,</span> e<span class="token punctuation">;</span>         K k<span class="token punctuation">;</span>         V v<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//删除分为三种情况，分两步</span>        <span class="token comment" spellcheck="true">//第一步先找到要删除的元素</span>        <span class="token comment" spellcheck="true">//1. 当桶中第一个即为删除元素时</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//2. 当桶中结构为红黑树时</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//3. 当桶中结构为链表时</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                         <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//第二步删除找到的元素，也是分为红黑树，链表，桶中第一个元素三种情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                             <span class="token punctuation">(</span>value <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">else</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">;</span>     K k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查找分为三种情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1. 桶中第一个元素即为查找的元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//2. 桶中结构为红黑树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//3. 桶中结构为链表</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u010983881/article/details/78637763" target="_blank" rel="noopener">https://blog.csdn.net/u010983881/article/details/78637763</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce原理</title>
      <link href="/2019/01/12/MapReduce%E5%8E%9F%E7%90%86/"/>
      <url>/2019/01/12/MapReduce%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="MapReduce介绍"><a href="#MapReduce介绍" class="headerlink" title="MapReduce介绍"></a>MapReduce介绍</h2><p>Hadoop Map/Reduce是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上T级别的数据集。</p><p>一个Map/Reduce <em>作业（job）</em> 通常会把输入的数据集切分为若干独立的数据块，由 <em>map任务（task）</em>以完全并行的方式处理它们。框架会对map的输出先进行排序， 然后把结果输入给<em>reduce任务</em>。通常作业的输入和输出都会被存储在文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p><h2 id="MapReduce原理"><a href="#MapReduce原理" class="headerlink" title="MapReduce原理"></a>MapReduce原理</h2><p>MapReduce通常由三个操作组成</p><ul><li>map操作：map操作是一类将输入记录集转换为中间格式记录集的独立任务，其应用于本地数据。</li><li>shuffle操作：工作节点根据输出键（由 map 函数生成）重新分配数据，对数据映射排序、分组、拷贝，目的是属于一个键的所有数据都位于同一个工作节点上。</li><li>reduce操作：Reduce操作将与一个key关联的一组中间数值集归约（reduce）为一个更小的数值集。</li></ul><p><img src="MapReduce%E6%B5%81%E7%A8%8B.png" alt=""></p><p>其中map阶段与reduce阶段之间的关系如下，而shuffle阶段就是将map输出的键相同的值汇聚在一起以供reduce处理</p><p><img src="Map%E4%B8%8EReduce%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt=""></p><h3 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h3><p> Map在输入的数据中获取一个键值对，然后返回一个键值对的列表：</p><pre class=" language-java"><code class="language-java"><span class="token function">Map</span><span class="token punctuation">(</span>k1<span class="token punctuation">,</span>v1<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">list</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span>v2<span class="token punctuation">)</span></code></pre><p>Map函数会被并行调用，应用于输入数据集中的每个键值对（keyed by K1），然后每个调用返回一个键值对（keyed by K2）列表。</p><p>以计算词频为例，Map阶段如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 继承的Mapper类中 *    第一个参数：LongWritable是输入的键，此处表示一行的起始偏移量 *    第二个参数：Text是输入的值，此处表示一行的文本内容 *    第三个参数：Text是输出的键，此处表示每一个单词 *    第四个参数：IntWritable是输出的值，此处表示每个单词的数量都是1(不管重复不重复) */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token operator">&lt;</span>LongWritable<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> IntWritable<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * map方法是提供给map task进程来调用的，map task进程是每读取一行文本来调用一次自定义的map方法     * map task在调用map方法时，传递的参数：     *         一行的起始偏移量LongWritable作为key     *         一行的文本内容Text作为value     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span>LongWritable key<span class="token punctuation">,</span> Text value<span class="token punctuation">,</span>Context context<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//拿到一行文本内容，转换成String 类型</span>        String line <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将这行文本切分成单词</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token operator">=</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出&lt;单词，1></span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String word<span class="token operator">:</span>words<span class="token punctuation">)</span><span class="token punctuation">{</span>            context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Shuffle阶段"><a href="#Shuffle阶段" class="headerlink" title="Shuffle阶段"></a>Shuffle阶段</h3><p>shuffle阶段是承接map和reduce，其也可以分为map shuffle和reduce shuffle</p><h4 id="map-shuffle"><a href="#map-shuffle" class="headerlink" title="map shuffle"></a>map shuffle</h4><p>在Map端的shuffle过程是对Map的结果进行分区、排序、分割，然后将属于同一划分（分区）的输出合并在一起并写在磁盘上，最终得到一个分区有序的文件，分区有序的含义是map输出的键值对按分区进行排列，具有相同partition值的键值对存储在一起，每个分区里面的键值对又按key值进行升序排列（默认），其流程大致如下：<br><img src="MapShuffle.png" alt=""></p><h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><p>对于map输出的每一键值对，系统会定一个partition，partition值默认是通过计算key的hash值后对Reduce task的数量取模获得。</p><p>默认情况下只能每一个partition是有序的，但是将所有Reduce的输出合并在一起并非是全局有序的。如果想要做到全局有序，可以只定义一个reduce task，或者自定义Partitioner将数据按序分到每一个分区上。而自定义需要注意数据的倾斜(不能将大量数据放在一个分区)，还要保证同一个键的数据分到一个分区上。</p><h5 id="collector"><a href="#collector" class="headerlink" title="collector"></a>collector</h5><p>Map的输出结果是由collector处理，每Map任务不断得将键值对输出到内存中构造的一个环形数据结构中。这个数据结构其实就是字节数组，叫kvbuffer，同时存放数据和数据的索引。</p><p>当kvbuffer使用到一定程度时，则触发spill。默认的spill门限为0.8，即空间使用了80%的时候，这样可以使Map的输出进程和spill进程并发进行</p><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>当spill触发后，会先将kvbuffer中的数据按照partition值和key两个关键字升序排序，只移动数据的索引，排序结果是将索引数据按照partition为单位聚集在一起，同一个partition中按照key有序</p><h5 id="spill"><a href="#spill" class="headerlink" title="spill"></a>spill</h5><p>spill的过程就是将数据写入到本地的过程，Spill线程根据排过序的Kvmeta挨个partition的把数据吐到这个文件中。</p><p>在这个过程中如果用户配置了combiner类，那么在写之前会先调用combineAndSpill()，对结果进行进一步合并后再写出。Combiner会优化MapReduce的中间结果，Combiner的输出是Reducer的输入，Combiner绝不能改变最终的计算结果。一般combiner类指定为Reduce，因此combiner适合用于Reduce的输入key/value与输出key/value类型完全一致，且不影响最终结果的场景。</p><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>Map任务如果输出数据量很大，可能会进行好几次Spill，输出的文件会产生很多，分布在不同的磁盘上。merge过程就是将这些文件合并成一个大文件。</p><h4 id="reduce-shuffle"><a href="#reduce-shuffle" class="headerlink" title="reduce shuffle"></a>reduce shuffle</h4><p>在Reduce端，shuffle主要分为复制Map输出、排序合并两个阶段。</p><h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><p>Reduce任务通过HTTP向各个Map任务拖取它所需要的数据。Map任务成功完成后，会通知父TaskTracker状态已经更新，TaskTracker进而通知JobTracker（这些通知在心跳机制中进行）。所以，对于指定作业来说，JobTracker能记录Map输出和TaskTracker的映射关系。Reduce会定期向JobTracker获取Map的输出位置，一旦拿到输出位置，Reduce任务就会从此输出对应的TaskTracker上复制输出到本地，而不会等到所有的Map任务结束。</p><h5 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h5><p>Copy过来的数据会先放入内存缓冲区中，如果内存缓冲区中能放得下这次数据的话就直接把数据写到内存中，即<strong>内存到内存merge</strong>。Reduce要向每个Map去拖取数据，在内存中每个Map对应一块数据，当内存缓存区中存储的Map数据占用空间达到一定程度的时候，开始启动内存中merge，把内存中的数据merge输出到磁盘上一个文件中，即<strong>内存到磁盘merge</strong>。</p><h3 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h3><p>Reduce 是对一个列表的元素进行适当的合并，将map阶段的键值对处理成我们想要的结果</p><pre class=" language-java"><code class="language-java"><span class="token function">Reduce</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span> <span class="token function">list</span> <span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">list</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span></code></pre><p>以计算词频为例，Reduce阶段如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 继承的Reducer类中 *    第一个参数：Text是输入的键,和Map阶段的输出键一样，此处表示每个单词 *    第二个参数：IntWritable是输入的值，和Map阶段的输出值一样，此处表示每个单词的数量是1 *    第三个参数：Text是输出的键，此处表示不重复的单词 *    第四个参数：IntWritable是输出的值，此处表示每个单词的数量（不重复） */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token operator">&lt;</span>Text<span class="token punctuation">,</span> IntWritable<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> IntWritable<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">/*     * reduce方法提供给reduce task进程来调用     *      * reduce task会将shuffle阶段分发过来的大量kv数据对进行聚合，聚合的机制是相同key的kv对聚合为一组     * 然后reduce task对每一组聚合kv调用一次我们自定义的reduce方法     * 比如：&lt;hello,1>&lt;hello,1>&lt;hello,1>&lt;tom,1>&lt;tom,1>&lt;tom,1>     *  hello组会调用一次reduce方法进行处理，tom组也会调用一次reduce方法进行处理     *  调用时传递的参数：     *          key：一组kv中的key     *          values：一组kv中所有value的迭代器     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span>Text key<span class="token punctuation">,</span> Iterable<span class="token operator">&lt;</span>IntWritable<span class="token operator">></span> values<span class="token punctuation">,</span>Context context<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定义一个计数器</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过value这个迭代器，遍历这一组kv中所有的value，进行累加</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>IntWritable value<span class="token operator">:</span>values<span class="token punctuation">)</span><span class="token punctuation">{</span>            count<span class="token operator">+=</span>value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//输出这个单词的统计结果</span>        context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5bb59f87f265da0aeb7118f2" target="_blank" rel="noopener">https://juejin.im/post/5bb59f87f265da0aeb7118f2</a></p><p><a href="https://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库分库分表</title>
      <link href="/2019/01/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2019/01/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p><strong>垂直拆分是将一个包含了很多表的数据库,根据表的功能的不同,拆分为多个小的数据库,每个库中包含部分表。</strong></p><p>比如大型的电商项目平台是由不同的子项目模块构成的如订单系统，账户系统，商品管理系统等等，这些个独立的模块都可以拆分成独立的服务与独立的数据库。</p><p>优点</p><ul><li>拆分后业务清晰，拆分规则明确。</li></ul><ol start="2"><li>系统之间整合或扩展容易。</li><li>数据维护简单。</li></ol><p>缺点</p><ul><li>存在单表数据量过大的问题（需要水平切分）</li><li>部分业务表无法join，只能通过接口方式解决，提高了系统复杂度</li></ul><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。<strong>水平切分分为库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。</strong></p><p>比如存放大量用户购物信息的购物表，可以按照下单时间拆分成多个表，每一个表就可以只存放少量的数据，再将这些表存在不同的数据库中，即可解决单库读写，存储性能瓶颈问题。</p><p>优点</p><ul><li>单表大小可控</li><li>便于扩展，如果要对集群扩容，只需要添加节点，无需对其他节点进行数据迁移</li></ul><p>缺点</p><ul><li>热点数据成为性能瓶颈。例如订单系统，近一段的订单可能会被频繁读写，而很早的历史订单则会很少读取。</li></ul><p>水平拆分的三种情况，以students表，db数据库为例</p><ul><li><p>只分表，将一个表水平拆分存储在一个数据库中</p><p>例如，db中存放students1和students2两个表</p></li><li><p>只分库，在多个数据库中分别存放一个表</p><p>例如，db1存放了一个students表，db2也存放了一个students表</p></li><li><p>分库分表，在多个数据库中存放多个相同的表（<strong>可以解决数据库IO瓶颈，数据库连接压力，CPU，网络，内存等等的瓶颈问题。</strong>）</p><p>例如，db1存放了students1和students2两个表；db2也存放了students1和students2两个表</p></li></ul><h2 id="主从复制读写分离"><a href="#主从复制读写分离" class="headerlink" title="主从复制读写分离"></a>主从复制读写分离</h2><p><strong>在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，很多情况下是不能满足实际需求的，通过主从复制的方式来同步数据保证数据不丢失，再通过读写分离来提升数据库的并发负载能力减轻服务器的压力</strong></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt=""></p><p>过程</p><ol><li>在每个事务更新数据完成之前，master在二进制日志进行记录，记录之后，master通知存储引擎提交事务。</li><li>Slave将master的binary log复制到其中继日志</li><li>Slave的线程从中继日志读取事件日志，然后更新slave数据，使其与master中的数据一致</li></ol><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p><img src="%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png" alt=""></p><p>读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也减轻了主服务器的压力。</p><ul><li>主库，提供数据库写服务</li><li>从库，提供数据库读服务</li></ul><h2 id="分库分表比较"><a href="#分库分表比较" class="headerlink" title="分库分表比较"></a>分库分表比较</h2><p>读写分离主要解决数据库读性能瓶颈，水平拆分主要解决数据库数据量大的问题，垂直拆分是实现业务解耦</p><p>数据库拆分原则</p><ol><li><p>优先考虑缓存降低对数据库的读操作。</p></li><li><p>再考虑读写分离，降低数据库写操作。</p></li><li><p>最后开始数据拆分,切分模式： <strong>首先垂直（纵向）拆分、再次水平拆分</strong>。</p></li><li><p>首先考虑按照业务垂直拆分。</p></li><li><p>再考虑水平拆分：先分库(设置数据路由规则，把数据分配到不同的库中)</p></li><li><p>最后再考虑分表，单表拆分到数据1000万以内。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.qingtingip.com/h_186509.html" target="_blank" rel="noopener">https://www.qingtingip.com/h_186509.html</a></p><p><a href="https://blog.csdn.net/shiyong1949/article/details/59586773" target="_blank" rel="noopener">https://blog.csdn.net/shiyong1949/article/details/59586773</a></p><p><a href="https://blog.csdn.net/worn_xiao/article/details/83963932" target="_blank" rel="noopener">https://blog.csdn.net/worn_xiao/article/details/83963932</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2019/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。而如果没有索引，那么可能需要把所有单词看一遍才能找到，这个过程是非常耗费时间的。</p><h2 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h2><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>根本区别</p><ul><li>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</li></ul><p>区别与联系</p><ul><li>两个索引底层均是由B+树实现</li><li>聚集索引叶子即数据，非聚集索引叶子存放指向数据的指针</li></ul><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>数据行的物理顺序与列值的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p><ul><li>查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放</li><li>修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序</li></ul><p>类似于字典的拼音索引，拼音的顺序与字典中汉字实际的顺序一致，当查两个读音一致的词时，找到第一个词后直接向后寻找即可找到第二个词。</p><p>Mysql创建聚集索引</p><pre class=" language-mysql"><code class="language-mysql">create CLUSTERED INDEX 索引名称 ON 表名(字段名)</code></pre><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p><ul><li><p>不会造成数据的重排</p></li><li><p>相对聚集索引可能会慢一些（二次查询造成查询变慢：非聚集索引叶子存放指向数据的指针，当查询列中包含了该索引没有覆盖的列，那么就必须访问该叶子节点指向的数据块查询对应的数据行的数据。）</p><p>二次查询例子：</p><table><thead><tr><th>name</th><th>class</th><th align="left">socre</th></tr></thead><tbody><tr><td>张一</td><td>数学</td><td align="left">100</td></tr><tr><td>张二</td><td>语文</td><td align="left">99</td></tr><tr><td>张三</td><td>英语</td><td align="left">98</td></tr><tr><td>张四</td><td>物理</td><td align="left">97</td></tr></tbody></table><p>建立非聚集索引（name，class）</p><pre class=" language-mysql"><code class="language-mysql">//叶子节点中包好class信息，所以查询到叶子节点即可查到信息select name from table1 where class <> '数学';//叶子节点不包含name，socre信息，所以必须查询结点select name, socre from table1 where class = '数学'</code></pre></li></ul><p>类似于字典的笔画索引，笔画的顺序与字典中汉字实际顺序不一致，当查找两个笔画一样的词时，需要分别查询两个词的位置（两个词一般不会挨着）</p><p>Mysql创建非聚集索引</p><pre class=" language-mysql"><code class="language-mysql">create NONCLUSTERED INDEX 索引名称 ON 表名(字段名)</code></pre><h2 id="建立索引的原则"><a href="#建立索引的原则" class="headerlink" title="建立索引的原则"></a>建立索引的原则</h2><ol><li><p><strong>最左前缀匹配原则</strong>，mysql会一直向右匹配索引直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></li><li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p></li><li><p><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col) / count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p></li><li><p><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/m0_37683670/article/details/85858846" target="_blank" rel="noopener">https://blog.csdn.net/m0_37683670/article/details/85858846</a></p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库三范式</title>
      <link href="/2019/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
      <url>/2019/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><p><strong>数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性</strong></p><ul><li>第一范式的目标是确保每列的原子性</li><li>如果每一列的都是不可再分的最小数据单元，则满足第一范式</li></ul><p>例如：</p><pre><code>每一个人可能有一个公司座机，有一个家庭座机，携带的手机表一：(姓名，性别，电话)        //电话还可以再分，不满足第一范式表二：(姓名，性别，公司座机，家庭座机，手机)        //满足第一范式</code></pre><h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h3><p><strong>满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情</strong></p><ul><li>第二范式要求m每个表只描述一件事情</li><li>如果一个关系满足1NF，并且主键以外其他列，每个属性都依赖主键，则满足第二范式</li></ul><p>例如：</p><pre><code>一个选课系统，学生有学号，姓名和性别属性，课程有课程名和学分表一：(学号，姓名，性别，课程名，学分，成绩)    //主键为(学号，课程名)为主键，姓名依赖于学号，而不依赖于课程名，不满足第二范式表二：(学号，姓名，性别)+(课程名，学分)+(学号，课程名，成绩)    //满足第二范式</code></pre><h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h3><p><strong>必须先满足第二范式（2NF），要求表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）</strong></p><ul><li>每列都和主键直接相关，而不是间接相关</li><li>如果一个关系满足2NF，每一个属性只依赖于主键，而不依赖其他属性，则满足第三范式</li></ul><pre><code>一个学生信息名单，学生有学号，地区有邮编表一：(学号，姓名，地址，邮编)        //邮编依赖于地址，再依赖于学号，不满足第三范式表二：(学号，姓名，地址)+(地址，邮编)    //分成两个表，每一个表均满足第三范式</code></pre><h2 id="不满足三范式的危害"><a href="#不满足三范式的危害" class="headerlink" title="不满足三范式的危害"></a>不满足三范式的危害</h2><p>以第二个例子</p><ul><li><p>数据冗余</p><p>假设一共有学生1000个，共有10门课，每个学生要选5门课，则学分数据重复了（5*1000-10）次</p></li><li><p>更新异常</p><p>若本来高数学分为4，现在要调整为5，则所有的选高数的都要更新，否则学分数据不一致</p></li><li><p>插入异常</p><p>如果新开一门课，还没有学生选择，因为主键中必须包含学号，所以只有课程无法插入</p></li><li><p>删除异常</p><p>假设有一门很烂的课，只有一人选择，现在他要退选，则数据库中便没有了该课的信息</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/waj6511988/p/7027127.html" target="_blank" rel="noopener">https://www.cnblogs.com/waj6511988/p/7027127.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型</title>
      <link href="/2019/01/04/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/01/04/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><h3 id="基本数据类型与封装器类的关系"><a href="#基本数据类型与封装器类的关系" class="headerlink" title="基本数据类型与封装器类的关系"></a>基本数据类型与封装器类的关系</h3><table><thead><tr><th>数据类型</th><th>大小/位</th><th>封装类</th><th>默认值（封装类默认为null）</th><th>数据范围</th></tr></thead><tbody><tr><td>byte</td><td>8bit/1字节</td><td>Byte</td><td>0</td><td>$[-128,127]$</td></tr><tr><td>boolean</td><td>8bit/1字节</td><td>Boolean</td><td>false</td><td>true/false</td></tr><tr><td>short</td><td>16bit/2字节</td><td>Short</td><td>0</td><td>$[-32768,32767]$</td></tr><tr><td>char</td><td>16bit/2字节</td><td>Character</td><td>‘\u0000’（对应数字0，输出为空）</td><td>$[0,65535]$</td></tr><tr><td>int</td><td>32bit/4字节</td><td>Integer</td><td>0</td><td>$[-2^{31},2^{31}-1]$</td></tr><tr><td>float</td><td>32bit/4字节</td><td>Float</td><td>0.0F</td><td>$[1.4E-45,3.4E38]$</td></tr><tr><td>long</td><td>64bit/8字节</td><td>Long</td><td>0L</td><td>$[-2^{63},2^{63}-1]$</td></tr><tr><td>double</td><td>64bit/8字节</td><td>Double</td><td>0.0D</td><td>$[4.9E-324,1.8E308]$</td></tr></tbody></table><h3 id="基本数据类型与封装器类在内存中的差别"><a href="#基本数据类型与封装器类在内存中的差别" class="headerlink" title="基本数据类型与封装器类在内存中的差别"></a>基本数据类型与封装器类在内存中的差别</h3><p>基本数据类型存放在栈中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后在栈中查找有没有字面值为3的地址，没找到，就在栈开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在栈中创建完b这个引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。</p><p>封装器类创建的对象和普通对象一样，存放在堆中</p><pre class=" language-java"><code class="language-java">Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> a<span class="token punctuation">;</span></code></pre><p>执行Integer a = new Integer(3)，首先会在java堆中创建一个new Integer(3)的实例，然后再在栈中创建一个指向该实例的引用a；执行Integer b = new Integer(3)时，同样，首先会在java堆中创建一个new Integer(3)的实例（与第一句创建的实例不一样），然后再在栈中创建一个指向该实例的引用b；执行Integer c = a，则在栈中创建一个实例的引用c，和a指向同一实例</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="自动数据类型转换"><a href="#自动数据类型转换" class="headerlink" title="自动数据类型转换"></a>自动数据类型转换</h4><p>自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下：</p><pre><code>低---------------------------------------------&gt;高byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double注意：char在转为高级或者直接加减运算时，char类型会转换为对应ASCII码值</code></pre><h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><p>强制转换的格式是在需要转型的数据前加上“( )”，然后在括号内加入需要转化的数据类型。高级数据类型转为低级数据类型，数据精度丢失</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">10.66</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//10</span></code></pre><h4 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">double</span> num <span class="token operator">=</span> <span class="token number">0.123456789</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//利用BigDecimal做中间转换</span>BigDecimal bigDecimal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> num1 <span class="token operator">=</span> bigDecimal<span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.12</span><span class="token comment" spellcheck="true">//利用DecimalFormat，返回String类型</span>DecimalFormat decimalFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecimalFormat</span><span class="token punctuation">(</span><span class="token string">"#.000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String num2 <span class="token operator">=</span> decimalFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.123</span><span class="token comment" spellcheck="true">//直接使用String.format，返回String类型</span><span class="token keyword">double</span> num3 <span class="token operator">=</span> Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%.4f"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.1235</span></code></pre><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(), doubleValue()这类的方法将对象转换成原始类型值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token operator">-</span><span class="token number">128</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// high value may be configured by property</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Use Long.decode here to avoid invoking methods that</span>            <span class="token comment" spellcheck="true">// require Integer's autoboxing cache to be initialized</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> Long<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>            h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        high <span class="token operator">=</span> h<span class="token punctuation">;</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>对于-128至127这256个值，直接获取的IntegerCache中的值。 而IntegerCache是Integer中的一个静态内部类，里面将-128至127（即一个字节所能表示的所有带符号值 -2^7至2^7-1）的包装类存在了一个数组中。 对于-128到127之间的数，直接从数组中获取，其他的数则使用new生成。</p><p>因此，当对一个不在范围内的数进行拆箱装箱，最后两个Integer的对象不会相等，而对于在范围内的数进行拆箱装箱，最后两个Integer的对象会相等</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//范围外</span>Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">13452</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//false</span><span class="token comment" spellcheck="true">//范围内</span>Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p>赋值时</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//before autoboxing</span>Integer a <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//after java5</span>Integer a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//装箱 </span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//拆箱 </span></code></pre></li><li><p>方法调用时</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">test</span><span class="token punctuation">(</span>Integer a<span class="token punctuation">)</span><span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先装箱，再拆箱</span></code></pre></li><li><p>循环问题（不可使用）</p><pre class=" language-java"><code class="language-java">Integer sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   sum<span class="token operator">+=</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>+操作方不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象，实际如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> sum<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>Integer sum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样，中间会创建5000个Integer对象，造成空间资源和垃圾回收资源的浪费</p></li><li><p>重载与装箱</p><p>在引入装箱之前，value(int)和value(Integer)是完全不相同的方法，开发者不会因为传入是int还是Integer调用哪个方法困惑。现在由于自动装箱和拆箱的引入，两个方法应该是同相同的方法，但实际上，<strong>自动装箱拆箱对方法的重载并无影响。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Integer b<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b = "</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Reload reload <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reload<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打印a = 5</span>    reload<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//打印b = 10</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="float与double精度丢失问题"><a href="#float与double精度丢失问题" class="headerlink" title="float与double精度丢失问题"></a>float与double精度丢失问题</h2><h3 id="精度丢失的原因"><a href="#精度丢失的原因" class="headerlink" title="精度丢失的原因"></a>精度丢失的原因</h3><p>例子：</p><pre><code>举例：double result = 1.0 - 0.9;这个结果不用说了吧，都知道了，0.09999999999999998</code></pre><p>为什么会出现这个问题呢，就这是java和其它计算机语言都会出现的问题，下面我们分析一下为什么会出现这个问题：<br>float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。float和double类型尤其不适合用于货币运算，因为要让一个float或double精确的表示0.1或者10的任何其他负数次方值是不可能的（其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10）。</p><p>浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。往往产生误差不是因为数的大小，而是因为数的精度。因此，产生的结果接近但不等于想要的结果。尤其在使用 float 和 double 作精确运算的时候要特别小心。</p><p>现在我们就详细剖析一下浮点型运算为什么会造成精度丢失？</p><pre><code>首先我们要搞清楚下面两个问题：     (1) 十进制整数如何转化为二进制数           算法很简单。举个例子，11表示成二进制数：                     11/2=5 余   1                       5/2=2   余   1                       2/2=1   余   0                       1/2=0   余   1                          0结束         11二进制表示为(从下往上):1011          这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，整数永远可以用二进制精确表示 ，但小数就不一定了。      (2) 十进制小数如何转化为二进制数           算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数                     0.9*2=1.8   取整数部分 1                     0.8(1.8的小数部分)*2=1.6    取整数部分 1                     0.6*2=1.2   取整数部分 1                     0.2*2=0.4   取整数部分 0                     0.4*2=0.8   取整数部分 0                     0.8*2=1.6 取整数部分 1                     0.6*2=1.2   取整数部分 0                              .........                           0.9二进制表示为(从上往下): 11100100100100......           注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了&quot;减不尽&quot;的精度丢失问题。</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>利用java.math.BigDecimal，BigDecimal构造部分代码没怎么看懂，查资料查到直接将double转为BigDecimal仍然会出现误差，必须使用String类型转为BigDecimal才能无误差。</p><p>所以，应当先将double转为String，再将String转为BigDecimal才能进行无误差的运算。下面是网上编写的Arith工具类，完成的就是上诉功能。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>math<span class="token punctuation">.</span>BigDecimal<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*** 由于Java的简单类型不能够精确的对浮点数进行运算，这个工具类提供精* 确的浮点数运算，包括加减乘除和四舍五入。*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Arith</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//默认除法运算精度</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEF_DIV_SCALE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这个类不能实例化</span>    <span class="token keyword">private</span> <span class="token function">Arith</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的加法运算。     * @param v1 被加数     * @param v2 加数     * @return 两个参数的和     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的减法运算。     * @param v1 被减数     * @param v2 减数     * @return 两个参数的差     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的乘法运算。     * @param v1 被乘数     * @param v2 乘数     * @return 两个参数的积     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到     * 小数点以后10位，以后的数字四舍五入。     * @param v1 被除数     * @param v2 除数     * @return 两个参数的商     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">div</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span>v2<span class="token punctuation">,</span>DEF_DIV_SCALE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指     * 定精度，以后的数字四舍五入。     * @param v1 被除数     * @param v2 除数     * @param scale 表示表示需要精确到小数点以后几位。     * @return 两个参数的商     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">,</span><span class="token keyword">int</span> scale<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>scale<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                <span class="token string">"The scale must be a positive integer or zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span>scale<span class="token punctuation">,</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的小数位四舍五入处理。     * @param v 需要四舍五入的数字     * @param scale 小数点后保留几位     * @return 四舍五入后的结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">double</span> v<span class="token punctuation">,</span><span class="token keyword">int</span> scale<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>scale<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                <span class="token string">"The scale must be a positive integer or zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        BigDecimal b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>one<span class="token punctuation">,</span>scale<span class="token punctuation">,</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String，StringBuffer，StringBuilder的区别"><a href="#String，StringBuffer，StringBuilder的区别" class="headerlink" title="String，StringBuffer，StringBuilder的区别"></a>String，StringBuffer，StringBuilder的区别</h3><ul><li>String是字符串常量，任何对String的改变都会引发新的String对象的生成，对字符串进行大量修改时不要用String</li><li>StringBuffer，StringBuilder是可变类，任何对它所指代的字符串的改变都不会产生新的对象</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的，单线程下使用StringBuilder</li><li>StringBuffer几个常用的方法<ul><li>append():将新添加的内容连接到调用字符串的末尾</li><li>reverse():颠倒字符串</li><li>detele()：删除指定位置的字符串</li><li>insert(int index，String str)：将一个字符串插入到另一个字符串中指定位置。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/tomcat_2014/article/details/51453988" target="_blank" rel="noopener">https://blog.csdn.net/tomcat_2014/article/details/51453988</a></p><p><a href="https://blog.csdn.net/Evankaka/article/details/44651887" target="_blank" rel="noopener">https://blog.csdn.net/Evankaka/article/details/44651887</a></p><p><a href="https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="noopener">https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
