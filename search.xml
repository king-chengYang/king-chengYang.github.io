<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统</title>
      <link href="/2019/12/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/12/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="一-操作系统概述"><a href="#一-操作系统概述" class="headerlink" title="一.操作系统概述"></a>一.操作系统概述</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统目前有五大类型：<strong>批操作系统，分时系统，实时系统，网络操作系统，分布式系统</strong></p><p>操作系统的特征：</p><ul><li>并发<ul><li>并发：多个程序在同一时间段发生</li><li>并行：多个程序在同一时刻发生。单处理器进程交替进行；多处理器进程可重叠执行</li></ul></li><li>共享</li><li>虚拟</li><li>异步</li></ul><p><strong>设备独立性：</strong>用户程序使用的设备与实际使用哪台设备无关的一种特性</p><p>操作系统的主要功能：</p><ul><li>资源管理：处理器管理，存储器管理，设备管理，文件管理</li><li>提供用户接口：命令接口，图形用户接口，系统调用</li><li>以进程的方式组织用户使用计算机</li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统提供给用户的接口有<strong>命令接口</strong>，<strong>系统调用</strong>，<strong>图形接口</strong></p><p><strong>系统调用（程序接口API）：</strong>用户可以利用系统提供的一组系统调命令，来调用OS内核中的一个或一组过程以完成自己需要的功能。可以被看做一个内核与用户空间交互的接口。</p><h2 id="二-进程管理"><a href="#二-进程管理" class="headerlink" title="二.进程管理"></a>二.进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：是资源分配的独立单位，是调度的基本单位，<strong>资源分配的最小单位</strong></p><p>线程：是CPU调度和执行的最小单位，<strong>CPU调度的最小单位</strong></p><p>引入进程与线程的原因</p><ul><li>引入进程是为了使多个程序能够并发的运行，提高资源利用率和系统吞吐量，增加并发程度</li><li>引入线程是为了减少进程切换和创建，撤销进程的开销，提高执行效率，并发性能和节省资源</li></ul><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程主要由<strong>程序段，数据，进程控制块PCB</strong>三部分组成，其中PCB进程控制块是进程存在的唯一标志，数据部分可以与其它进程共享</p><p>进程的创建：申请空白PCB，分配资源，初始化PCB，将进程插入到就绪队列</p><p>进程的终止：设置进程状态为终止，终止其子进程，回收进程占用的资源，删掉它的PCB</p><p>进程与程序的根本区别是：静态与动态的特点</p><p>进程的状态：</p><ul><li>运行态：进程正在使用计算机</li><li>就绪态：进程具备运行条件，但尚未被调度</li><li>阻塞态（等待态）：进程由于等待某一事件或者等待I/O操作不能运行时而进入阻塞态</li></ul><p>进程通信：</p><ul><li><p>共享存储器系统</p><p>在共享存储器系统中，相互通信的进程共享某些存储区，进程之间能够通过这些空间进行通信</p><ul><li>基于共享数据结构方式</li><li>基于共享存储区方式</li></ul></li><li><p>管道通信</p><p>管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件</p></li><li><p>消息传递系统</p><p>进程间的数据交换，以格式化的消息为单位</p><ul><li>直接通信方式</li><li>间接通信方式</li></ul></li></ul><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>原语：是由若干指令组成的，用于完成一定特定功能的一个过程，原语执行是连续的不被中断的。</p><p>进程同步的目的：协调不同进程的运行次序，使得进程能够有效的共享资源并且相互合作</p><p><strong>并发进程的两种关系：</strong>（间接制约）互斥与（直接制约）同步</p><p><strong>临界资源：</strong>需要进程互斥的访问的计算机资源，进程通过互斥的方式对资源进行共享，例如打印机</p><p><strong>临界区：</strong>每个进程访问临界资源的那段代码</p><p>同步机制遵循的规则：<strong>空闲让等，忙则等待，有限等待，让权等待</strong></p><h3 id="同步经典例子"><a href="#同步经典例子" class="headerlink" title="同步经典例子"></a>同步经典例子</h3><pre><code>P:wait(S){    S = S-1;    if(S&lt;0)        挂起}V:signal(S){    S = S+1;    if(S&lt;=0)        唤醒}</code></pre><p>PV操作中互斥量设置为1，同步信号量若期望的消息尚未产生，则对应的初值应为0，若期望的消息已经存在，则信号量初值设置为存在的数目。</p><p>生产者消费者问题</p><pre><code>参数：    empty表示缓冲区是否为空，初值为n；    full表示缓冲区是否为满，初值为0;    互斥信号量mutex=1生产者：producer(){    while(1){        生产一个产品；        P(empty);        P(mutex);        将产品放入缓冲区        V(mutex);        V(full);    }}消费者：consumer(){    while(1){        P(full);        P(mutex);        将产品从缓冲区读出        V(mutex);        V(empty);        消费产品    }}</code></pre><p>读者-写者问题（当写者发起请求时，后续读者都只能在队列中等待，直到写者完成）</p><pre><code>参数：    readcount记录读者数量，初始为0；    mutex为互斥信号量，用于保护更新readcount变量时的互斥；    rw为读写互斥信号量；    canoperate为可进入文件进行操作的互斥信号量；读者：begin    P(canoperate);    P(mutex);    readcount++;    if(readcount == 1)        P(rw);    V(mutex);    P(canoperate);    读文件    P(mutex)    readcount--;    if(readcount == 0)        V(rw);    V(mutex);end;写者：begin    P(canoperate);    P(rw);    V(canoperate);    写文件    V(rw);</code></pre><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><h4 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h4><ul><li>高级调度：作业调度或者长程调度，以作业为单位从外存调入内存</li><li>中级调度：内存与外存对换区交换内容，从存储器资源的角度，将进程的部分或全部内容换出到外存上，将当前进程所需部分内容换入到内存</li><li>低级调度：从就绪队列中选择一个等待CPU的进程并分配CPU给它</li></ul><h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><ol><li>CPU利用率：CPU的负荷</li><li>吞吐量：一个时间单元内完成的进程的数量</li><li>周转时间：从进程提交到进程完成的时间</li><li>等待时间：在就绪队列中等待的时间</li><li>响应时间：从提交申请到产生第一响应的时间</li></ol><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ul><li><p>先来先服务调度算法（FCFS）</p></li><li><p>短作业优先调度算法（SJF）</p><p>平均等待时间，平均周转时间最短</p></li><li><p>优先级调度算法</p><p>老化技术：使作业的优先级随着等待时间的增加而提高</p></li><li><p>时间片轮转调度算法：进程循环获得时间片</p></li><li><p>多级队列调度：将就绪队列分成多个独立队列，每个队列根据情况使用不同的调度算法</p></li><li><p>多级反馈队列调度：</p><p>有三个队列0，1，2。调度程序会先执行队列0中的进程，未执行完的进程进入队列1，只有当0中没有进程时，才能执行队列1中的进程。同样，在队列1中没有执行完的进程进入队列2，只有0，1都没有进程时，才执行队列2中的进程。</p><p>到达0中的进程可以抢占队列1中的进程。而队列1中的进程没执行完或者被队列0中的进程抢占，都让该进程进入到队列中</p></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>进程-资源图表达的系统状态S为死锁状态的充分必要条件是<strong>当且仅当S状态的资源分配图不可完全简化</strong></p><p>产生死锁的原因：</p><ul><li>系统资源不足</li><li>进程推进顺序不当</li></ul><p>产生死锁的必要条件</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不可剥夺条件</li><li>循环等待</li></ul><p>处理死锁的方法</p><ul><li><p>预防死锁：破坏四个必要条件</p><ul><li>破坏互斥条件：资源共享</li><li>破坏”请求和保持条件“：<strong>静态资源分配法</strong>，申请资源之前，一次性申请全部资源</li><li>破坏”不可剥夺“条件：当新的资源请求得不到满足，则释放已有资源</li><li>破坏”循环等待“条件：<strong>有序资源分配法</strong>，将系统资源按类型编号，所有进程必须按照资源序号递增的次序申请资源，同类资源一次申请完。</li></ul></li><li><p>死锁避免：银行家算法</p></li><li><p>检测和解除死锁：</p><p>允许死锁发生，系统不断检测</p><p>发生死锁后，解除死锁：资源剥夺法，撤销进程法</p></li></ul><h2 id="三-内存管理"><a href="#三-内存管理" class="headerlink" title="三.内存管理"></a>三.内存管理</h2><h3 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h3><h4 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h4><p>程序装入的过程</p><ul><li>编译</li><li>链接：由链接程序将编译后形成的一组目标模块，和所需库函数链接在一起，形成一个完整的装入模块</li><li>装入：由装入程序将程序装入模块</li></ul><p>程序装入的方式</p><ul><li><p>绝对装入</p><p>在编译时就知道程序在内存中的地址，编译程序产生绝对地址的目标代码。程序中的逻辑地址与实际地址完全相同</p></li><li><p>静态重定位装入</p><p>装入时将目标代码中的指令地址和数据地址转换成绝对地址。地址变换在装入时一次完成</p></li><li><p>动态重定位装入</p><p>装入时程序的地址为相对地址，只有程序在运行时，会将相对地址转换位绝对地址，需要重定位寄存器支持。</p></li></ul><h4 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h4><ul><li><p>静态链接</p><p>程序装入之前，将各模块与所需的库函数链接</p></li><li><p>装入时动态链接</p><p>装入内存时，采用边装入边链接的方式</p></li><li><p>运行时动态链接</p><p>程序执行时需要该模块时，才对它进行链接</p></li></ul><h4 id="逻辑地址-物理地址"><a href="#逻辑地址-物理地址" class="headerlink" title="逻辑地址 物理地址"></a>逻辑地址 物理地址</h4><p>编译之后，每个目标模块都是从0号开始编址，称为该模块的相对地址</p><p>逻辑地址：用户的程序经过汇编或编译后形成目标模块，模块的相对地址即为逻辑地址</p><p>物理地址：内存中存储单元的地址，物理地址可以直接寻址</p><p>地址映射（重定位）：将用户程序的逻辑地址转换为运行时由机器直接寻址的物理地址的过程</p><p>静态重定位和动态重定位属于操作系统重定位</p><ul><li>静态重定位（静态重定位装入）：装入一个作业时，将作业中指令地址和数据地址全部转换为绝对地址<ul><li>无需硬件支持</li><li>程序在内存中只能连续存储</li><li>程序经地址重定位后不能移动，也不能再申请内存空间</li></ul></li><li>动态重定位（动态重定位装入）：装入一个作业时，不进行地址转换。当程序执行时，每执行一条指令就将相对地址由<strong>重定位寄存器</strong>转换为绝对地址<ul><li>程序在执行过程中可以移动</li><li>程序不必在内存中连续存储</li><li>程序运行前可以只装入部分代码，然后在运行期间再动态申请内存</li><li>若干个用户可以共享同一程序段或数据段</li></ul></li><li>编译重定位：编译器在内存中分配函数，变量等的虚地址，当程序访问到这些地址时，使用的是预分配的虚地址，根据相对程序头部将PC指针偏移找到目标代码。</li></ul><p>内存保护</p><ul><li>重定位寄存器：包含最小的物理地址</li><li>界地址寄存器：最大的逻辑地址值，每个逻辑地址必须小于界地址寄存器</li></ul><h3 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h3><p>进程可以使用的最大地址空间受限于<strong>地址位数</strong></p><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><ul><li>时间局部性：如果程序中某一条指令一旦执行成功，不久之后该指令可能再次执行。原因是循环操作</li><li>空间局部性：一旦程序访问某一个存储单元，不久之后，其附近的存储单元也将被访问。原因是指令通常是顺序存放顺序执行。</li></ul><p>例子</p><ul><li>虚拟内存</li><li>Cache</li><li>页面置换算法（LRU，CLOCK）</li><li>预调页策略</li></ul><h4 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h4><p><strong>内存连续分配</strong></p><ol><li><p>固定分区：</p><p>将内存中用户区划分为若干个连续的分区，其尺寸固定不可变。可以使用&lt;分区号，起始地址，大小，状态&gt;表结构表示分区。出现内部碎片</p></li><li><p>动态分区：</p><p>每个分区大小可以变化。可以使用空闲分区表，空闲分区链表示分区。出现外部碎片，使用<strong>紧凑（紧缩）</strong>方法合并分区，即操作系统不时对进程进行移动和整理</p><p>动态分区的分配策略</p><ul><li>首次适应：空闲分区地址递增方式连接，找到第一个可用分区</li><li>临近适应：在首次适应的基础上循环适应</li><li>最佳适应：空闲分区按容量递增方式连接，找到第一个可用分区</li><li>最坏适应：空闲分区按容量递减方式连接，找到第一个可用分区（最大分区）</li></ul></li></ol><p>交换技术</p><p>把处于等待状态的程序从内存中移到外存，称为换出；把准备好竞争CPU运行的程序从外存移到内存，称为换入</p><h4 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h4><p><strong>内存离散分配，分页内存管理允许进程的物理地址空间可以是非连续的。作业地址空间一维（只需要指定地址，该地址会通过硬件分为页号和偏移）</strong></p><p>页表：每个进程对应一张页表，记录页面在内存中对应的物理块号。页表放在内存中实现页号到物理块号的地址映射。表结构：页号：&lt;物理块号&gt;</p><p>页表中并不包括页号这一项，因为每个页表中每个页号都对应一个物理块号，并且页号按照顺序排列，直接可以定位。</p><p>页内偏移量 = 一个页的大小</p><p>页表寄存器：存放页表起始地址和页表长度，类似重定位寄存器</p><p>快表：TLB，类似Cache</p><p>优点：</p><ul><li>存在页内碎片，但相对较小，内存利用率较高</li><li>实现了离散分配</li><li>便于存储访问控制，有利于代码共享</li><li>无外部碎片</li></ul><p>缺点：</p><ul><li>用户视角的内存和实际物理内存分离</li><li>需要专门的硬件支持</li><li>不支持动态链接</li><li>有内部碎片</li></ul><p>多级页表</p><p>|顶级页表|二级页表|页内偏移量|</p><p>相当于：二级页表是顶级页表的页内偏移量。顶级页表项和二级页表项占的位数相同</p><p>例如：</p><p>  一个页面大小为$2^{12}$，则页内偏移量占12位，页内偏移量代表一个页的大小。顶级页表长度为9位，则一共$2^9$个页表项，一个页表项的长度为8。二级页表项与顶级页表项占的位数相同，为9位，二级页表项即可表示顶级页表项的偏移量，并且是对页表项的偏移量，而非页面大小的偏移量。         </p><h4 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h4><p><strong>类似分页管理，只是每一段长度不一定相同。作业地址空间二维（需要指定段号和偏移）</strong></p><p>理解为：将一个程序分为很多段，每个段就是一个逻辑处理，这些段可以在内存中随意存放。</p><p>段之所以更好满足用于需要就是其将属于一个逻辑的代码放在一起。</p><p>段表：段号: &lt;段长，基址&gt;表结构</p><p>段表寄存器：&lt;段表起始地址，段表长度&gt;，类似重定位寄存器</p><p>优点：</p><ul><li>便于动态链接</li><li>便于共享分段</li><li>便于程序模块化处理，符合用户视角</li><li>无内部碎片(长度可变)</li></ul><p>缺点：</p><ul><li>需要硬件转换</li><li>为了满足分段动态增长，减少外部碎片，采用拼接技术</li><li>有外部碎片</li></ul><h4 id="段页管理"><a href="#段页管理" class="headerlink" title="段页管理"></a>段页管理</h4><p>一个进程对应若干段，一个段对应若干页</p><ul><li>作业的地址空间被分成若干个逻辑段，每个段都有自己的段号</li><li>将每一个段分成若干个大小固定的页</li></ul><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>分段，分页需要将整个进程放入内存中，虚拟内存技术允许执行进程不必完全在内存中</p><p>缺页中断：在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存</p><ul><li>与一般中断的区别：<ul><li>在指令执行期间响应，而非一条指令执行完之后</li><li>缺页中断处理完成后仍回到原指令重新执行，而一般中断则返回到下一条指令执行</li><li>一条指令在执行期间，可能产生多次缺页中断</li></ul></li></ul><p>页面置换算法</p><ul><li><p>最佳置换算法（OPT）</p><p>淘汰页面最长时间不再使用的页面，需要预测未来</p></li><li><p>先进先出置换算法（FIFO）</p><p>会产生Belady异常，即当所分配的物理块数增大而缺页故障不减反增的异常现象。</p></li><li><p>最近最少使用置换算法（LRU）</p><p>淘汰最近最长没有使用的页面</p></li><li><p>时钟置换法</p><ul><li><p>二次机会法（NRU，最近未使用算法）</p><p>给每一块设置一个访问位，并将所有的块链接成循环链表，0表示未访问可替换，1表示已访问</p></li><li><p>改进后的时钟置换算法</p><p>一个访问位A，一个修改位M</p><p>被替换的优先级</p><ul><li>A=0,M=0</li><li>A=0,M=1</li><li>A=1,M=0</li><li>A=1,M=1</li></ul><p>执行过程</p><ul><li>先找第一优先级的</li><li>再找第二优先级的，遍历过程中将所有的访问位置位0</li></ul></li></ul></li></ul><p>局部模型-工作集</p><p>工作集是一个经常使用的页的集合</p><p><strong>颠簸（抖动）：</strong>在页面置换时，刚刚换出的页面又换入主存，这种频繁的页面调度称为<strong>颠簸</strong></p><p>原因：操作系统监视CPU的使用率，当使用率较低时，会引入新进程，以增加多道程序的程度。当多道程序增加到一定程度会出现颠簸。</p><h2 id="三-设备管理"><a href="#三-设备管理" class="headerlink" title="三.设备管理"></a>三.设备管理</h2><p>I/O设备分类：</p><ul><li>设备使用特性<ul><li>存储设备</li><li>输入输出设别</li></ul></li><li>传输速率<ul><li>低速设备</li><li>高速设别</li><li>中速设备</li></ul></li><li>信息交换单位<ul><li>块设备</li><li>字符设别</li></ul></li><li>设备共享性<ul><li>独占设备</li><li>共享设备</li><li>虚拟设备</li></ul></li></ul><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><h4 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h4><ul><li>DMA数据传输的基本单位是数据块，把对一个数据块的读写变为对一组数据块的读写</li><li>实现CPU，通道，和I/O设备三者并行操作</li></ul><h3 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h3><ul><li>缓和CPU和I/O设备之间速度不匹配的矛盾</li><li>减少对CPU中断的频率，放宽对CPU中断的响应时间的限制</li><li>提高CPU和I/O设备之间的并行性</li></ul><p>方式：</p><p>C为处理时间，M为传输到用户的时间，T为传输到缓冲区的时间</p><ul><li>单缓冲：时间Max（C，T）+M</li><li>双缓冲：时间Max（C+M，T），拿数据和处理数据是一个过程</li><li>循环缓冲</li><li>缓冲池</li></ul><h3 id="假脱机技术（SPOOLing）"><a href="#假脱机技术（SPOOLing）" class="headerlink" title="假脱机技术（SPOOLing）"></a>假脱机技术（SPOOLing）</h3><p>脱机输入脱机输出：利用专门外围控制机，完成低速I/O设备和高速磁盘数据传输</p><p>特点：</p><ul><li>提高I/O的速度。利用输入输出井模拟脱机输入输出，缓和了CPU和I/O设备速度不匹配的矛盾</li><li>将独占设备改造为共享设备。并没有为进程分配设备，而是为进程分配一存储区和建立一张I/O请求表</li><li>实现虚拟设备功能。多个进程同时使用同一台独占设备</li><li>利用空间换时间</li></ul><p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_SPOOLing.PNG" alt=""></p><p>共享打印机</p><p>当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程</p><ul><li>由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据传入其中</li><li>输出进程再为用户进程申请一张空白的用户请求打印表，将用户要打印的内容填入其中，再将该表挂到请求打印队列上。</li></ul><h2 id="四-文件系统"><a href="#四-文件系统" class="headerlink" title="四.文件系统"></a>四.文件系统</h2><p>系统运行时，计算机以进程为基本单位进行资源的调度和分配，而在用户进行的输入，输出中，则以文件为基本单位</p><h3 id="文件的组织方式"><a href="#文件的组织方式" class="headerlink" title="文件的组织方式"></a>文件的组织方式</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>文件的逻辑结构就是从用户的观点出发看到的文件的组织方式。</p><ul><li><p>无结构文件</p><p>数据按照顺序组织成记录并积累保存，是有序相关信息项的集合，以字节为单位。通过穷举法搜索</p></li><li><p>有结构文件</p><ul><li>顺序文件（顺序搜索）<ul><li>串结构（时间顺序）</li><li>顺序结构（关键字顺序）</li></ul></li><li>索引文件：索引表</li><li>索引顺序文件：先索引再顺序</li><li>直接文件和哈希文件</li></ul></li></ul><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>文件的物理结构直接与外存的分配方式有关，采用不同的分配方式时，将形成不同的文件物理结构</p><table><thead><tr><th></th><th>访问第n个记录</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>顺序分配</td><td>访问磁盘一次（不存在一个记录存在两个磁盘块的情况）</td><td>存取速度快，根据相对地址快速定位</td><td>需要连续的存储空间，不利于扩充，且会有碎片</td></tr><tr><td>链接分配</td><td>访问磁盘n次</td><td>解决碎片问题，便于动态扩充</td><td>按文件的指针顺序访问，效率较低，指针存储浪费空间</td></tr><tr><td>索引分配</td><td>m级访问磁盘m+1次</td><td>可以随机访问，易于文件的扩充</td><td>索引表的查找策略对文件系统影响较大</td></tr></tbody></table><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件控制块：FCB，用于描述和控制文件的数据结构。文件与文件控制块一一对应。</p><p>目录表</p><p>存储空间管理</p><ul><li>空闲表法&lt;序号，第一个空闲盘块号，空闲盘块数&gt;</li><li>空闲链表法</li><li>位视图法</li><li>成组链接法</li></ul><h2 id="五-磁盘"><a href="#五-磁盘" class="headerlink" title="五.磁盘"></a>五.磁盘</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>磁道划分为扇区。</p><p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.PNG" alt=""></p><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>先寻道，再定位到对应扇区，最后传输数据</p><ul><li><p>寻道时间 = 启动振臂时间$S$+经过的磁道数$N$*经过一个磁道的时间$M$</p></li><li><p>延迟时间 ，定位到对应的扇区，与磁盘的旋转速度$r$有关</p></li><li><p>传输时间 = （经过的磁盘数=传输的字节数$b$ / 一个磁道的字节数$N$）*(转一圈需要的时间=1 / 磁盘每秒的转数)</p><p>rpm代表一分钟的转数vv</p></li></ul><p>磁盘调度算法</p><ul><li>先来先服务(FCFS）</li><li>最短寻道时间优先(SSTF)</li><li>扫描（SCAN）算法（电梯算法）（改进版），双向扫描</li><li>循环扫描（C-SCAN）（改进版）：单向扫描</li></ul><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>低级格式化：将一个磁盘分成扇区</p><p>为了使磁盘可以存储文件，需要两部</p><ul><li><p>磁盘分区</p></li><li><p>逻辑格式化（创建文件系统）</p><p>操作系统将初始的文件系统数据结构存储到磁盘上，包括空闲，已分配的空间和一个初始位空的目录。</p></li></ul><h3 id="RAID（磁盘冗余阵列）"><a href="#RAID（磁盘冗余阵列）" class="headerlink" title="RAID（磁盘冗余阵列）"></a>RAID（磁盘冗余阵列）</h3><p>RAID级别：</p><ul><li><p>RAID0：无冗余的磁盘阵列</p><p>将多个磁盘合并位一个大磁盘，不具备冗余能力，并行I/O。</p><p>一个磁盘块损坏，所有数据无法使用</p></li><li><p>RAID1：镜像文件</p><p>将磁盘阵列中硬盘分为两组，互为镜像，并行传输方式。</p><p>提高读写速度，增加系统可靠性</p></li><li><p>RAID2：内存方式的差错纠正结构</p><p>差错由内存系统检测</p></li><li><p>RAID3：位交织奇偶结构</p><p>一个硬盘存放数据的奇偶校验位，其余硬盘存放数据。</p><p>检验盘损坏，则全部数据无法使用</p></li><li><p>RAID4：块交织奇偶结构</p></li><li><p>RAID5：分布交织奇偶结构</p><p>将数据的奇偶校验位交互存放于各个硬盘上</p></li><li><p>RAID6：P+Q冗余方案</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列BlockingQueue</title>
      <link href="/2019/12/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/"/>
      <url>/2019/12/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列相对于非阻塞队列最大的区别在于</p><ul><li>当队列是空的时，从队列中获取元素的操作将会被阻塞，直到其他的线程往空的队列插入新的元素</li><li>当队列是满时，往队列里添加元素的操作会被阻塞，直到队列中移除一个或者多个元素，或者完全清空队列</li></ul><h2 id="BlockingQueue简介"><a href="#BlockingQueue简介" class="headerlink" title="BlockingQueue简介"></a>BlockingQueue简介</h2><p>BlockingQueue是一个阻塞队列，满足上面阻塞队列的性质，其插入，删除，读取操作方法如下：</p><table><thead><tr><th align="center"></th><th align="center">抛异常</th><th align="center">返回特殊值</th><th align="center">阻塞</th><th>超时</th></tr></thead><tbody><tr><td align="center"><strong>插入</strong></td><td align="center">add(o)</td><td align="center">offer(o)</td><td align="center">put(o)</td><td>offer(o, timeout, timeunit)</td></tr><tr><td align="center"><strong>移除</strong></td><td align="center">remove(o)</td><td align="center">poll(o)</td><td align="center">take(o)</td><td>poll(timeout, timeunit)</td></tr><tr><td align="center"><strong>检查</strong></td><td align="center">element(o)</td><td align="center">peek(o)</td><td align="center"></td><td></td></tr></tbody></table><ul><li>抛异常：操作无法立即执行，抛出异常</li><li>返回特殊值：操作无法立即执行，返回false或null</li><li>阻塞：操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li>超时：操作无法立即执行，该方法调用将在给定的时间内发生阻塞，直到能够执行，操作成功返回true；若在给定时间内无法完成操作，返回false</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 插入队列，通常会使用offer实现     *     * @param e 需要添加的元素     * @return 添加成功返回true     * @throws IllegalStateException 如果元素无法被插入到队列中     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入队列，插入成功返回true，失败返回false     *     * @param e 需要添加的元素     * @return 插入成功返回true，失败返回false     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入元素e至队尾, 如果队列已满, 则阻塞调用线程直到队列有空闲空间.     *     * @param e 需要添加的元素     * @throws InterruptedException 如果等待时被中断     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 插入元素e至队列, 如果队列已满, 则限时阻塞调用线程，直到队列有空闲空间或超时.     *     * @param e 需要添加的元素     * @param timeout 在放弃插入之前需要等待的时间     * @param unit a timeout的时间单位     * @return 插入成功返回true，失败返回false     * @throws InterruptedException 如果等待时被中断     * @throws NullPointerException 如果插入的元素是null     */</span>    <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 从队首删除元素，如果队列为空, 则阻塞调用线程直到队列中有元素.     *     * @return 队列头部的元素     * @throws InterruptedException 如果等待时被中断     */</span>    E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 从队首删除元素，如果队列为空, 则限时阻塞调用线程，直到队列中有元素或超时.     *     * @param timeout 在放弃插入之前需要等待的时间     * @param unit a timeout的时间单位     * @return 返回头部的元素，或者时间超时返回null     * @throws InterruptedException 如果等待时被中断     */</span>    E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre><p>谨记：BlockingQueue无法插入null</p><h2 id="消费者生产者问题"><a href="#消费者生产者问题" class="headerlink" title="消费者生产者问题"></a>消费者生产者问题</h2><p>操作系统中，生产者消费者问题，一般定义两个同步信号量和一个互斥信号量</p><ul><li>mutex 互斥信号量，表示只有一个线程可以操作队列</li><li>empty 同步信号量，表示剩余空间的个数</li><li>full 同步信号量，表示已经装满的个数</li></ul><p>消费者生产者问题可以自己定义P操作，V操作，然后再利用这三个信号量完成。</p><p>下面是一个利用LinkedBlockingQueue，并且空间大小为5的阻塞队列实现的消费者生产者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 生产者线程 */</span><span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token function">Producer</span><span class="token punctuation">(</span>LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> linkedBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> linkedBlockingQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">Produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Apple apple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产:"</span><span class="token operator">+</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 消费者线程 */</span><span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token function">Consumer</span><span class="token punctuation">(</span>LinkedBlockingQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> linkedBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> linkedBlockingQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">comsume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">comsume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Apple apple <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费Apple="</span><span class="token operator">+</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue是一种<strong>有界阻塞队列</strong>，在初始构造的时候需要指定队列的容量。具有如下特点：</p><ol><li>队列的容量一旦在构造时指定，后续不能改变；</li><li>插入元素时，在队尾进行；删除元素时，在队首进行；</li><li>队列满时，调用特定方法插入元素会阻塞线程；队列空时，删除元素也会阻塞线程；</li><li>支持公平/非公平策略，默认为非公平策略。</li><li>ArraBlockingQueue是使用环形数组实现<ul><li>当元素个数等于队列长度时表示队列已满</li><li>当元素个数等于0表示队列为空</li></ul></li><li>所有线程共用一把锁</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>所有线程共同使用同一个重入锁</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 存储数据的数组 */</span><span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**获取数据的索引，头索引，主要用于take，poll，peek，remove方法 */</span><span class="token keyword">int</span> takeIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**添加数据的索引，尾索引，主要用于 put, offer, or add 方法*/</span><span class="token keyword">int</span> putIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 队列元素的个数 */</span><span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 控制并非访问的锁，相当于mutex */</span><span class="token keyword">final</span> ReentrantLock lock<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作，相当于full */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**notFull条件对象，用于通知put方法队列未满，可执行添加操作，相当于empty */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 迭代器 */</span><span class="token keyword">transient</span> Itrs itrs <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ArrayBlockingQueue有三个构造函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * 指定队列初始容量的构造器. */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span>int capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用ArrayBlockingQueue(int capacity, boolean fair) </span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定队列初始容量和公平/非公平策略的构造器. */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化队列</span>    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 利用独占锁的策略</span>    notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 根据已有集合构造队列 */</span><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//先构造队列，再插入元素</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> fair<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保证items数组的可见性，即保证插入，删除，读取操作不会操作数据不完整的队列</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不能有null元素</span>                items<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArrayIndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count <span class="token operator">=</span> i<span class="token punctuation">;</span>        putIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> i<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 如果队列已满，则重置puIndex索引为0</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>核心构造方法 ArrayBlockingQueue(int capacity, boolean fair) 默认的是非公平锁</p><ul><li><p><strong>公平策略：</strong>按照“先来后到”的原则，对于每一个等待线程都是公平的。</p></li><li><p><strong>非公平策略：</strong>在多个线程争用锁的情况下，能够最终获得锁的线程是随机的（由底层OS调度）。</p></li></ul><p><em>注意：一般情况下，使用公平策略的程序在多线程访问时，总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时一定需要暂停线程并启动线程。</em></p><p>构造完之后，ArrayBlockingQueue的初始化结构如下</p><p><img src="ArrayBlockingQueue%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84.png" alt=""></p><p>插入元素之后，ArrayBlockingQueue的结构如下</p><p><img src="ArrayBlockingQueue%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E7%BB%93%E6%9E%84.png" alt=""></p><h3 id="尾部插入"><a href="#尾部插入" class="headerlink" title="尾部插入"></a>尾部插入</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ArrayBlockingQueue中的add方法调用其父类AbstractQueue中的add方法，如下</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//调用offer方法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入失败抛出异常</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//检测是否为空</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果队列已满，插入失败，返回false</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入到队列中，返回true</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//检测是否为空</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该方法可中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这里必须用while，防止虚假唤醒，若是虚假唤醒，则再检查一遍确认是否能插入</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//队列已满。</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在notfull队列上等待</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列已满，在notfull队列上等待nanos时间</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span>    <span class="token comment" spellcheck="true">// assert items[putIndex] == null;</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//环形数组，如果尾指针已经到数组尾部，则将尾指针移到数组头部，即重置索引为0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//已经有数据插入，可以唤醒删除线程</span><span class="token punctuation">}</span></code></pre><h3 id="头部删除"><a href="#头部删除" class="headerlink" title="头部删除"></a>头部删除</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果队列为空，返回null，否则删除头部元素</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中孤单</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果队列为空，加入到notEmpty队列中</span>        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列为空，加入到notEmpty队列等待nanos</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span>    <span class="token comment" spellcheck="true">// assert items[takeIndex] != null;</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    E x <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取出元素</span>    items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置取出后的位置为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果头指针已经到尾部，则将头针移到数组头部，即重置头部索引为1</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>        itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//队列中已经空余出位置，唤醒插入线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一种<strong>近似有界阻塞队列</strong>，因为LinkedBlockingQueue既可以在初始构造时就指定队列的容量，也可以不指定，如果不指定，那么它的容量大小默认为<code>Integer.MAX_VALUE</code>。</p><ol><li>插入元素时，在队尾进行；删除元素时，在队首进行；</li><li>队列满时，调用特定方法插入元素会阻塞线程；队列空时，删除元素也会阻塞线程；</li><li>底层数据结构为链表</li><li>维护两把锁<code>takeLock</code>和<code>putLock</code>，可以使删除和插入操作互不干扰<ul><li>takeLock用于控制出队的并发，只能有一个线程进行删除操作</li><li>putLock用于入队的并发，只能有一个线程进行插入操作</li></ul></li><li>所有的元素都被封装成Node类型的节点插入到队列中</li></ol><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 节点类，用于存储数据 */</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span> item <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 当前阻塞队列中的元素个数 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**阻塞队列的头结点,不存数据*/</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**阻塞队列的尾节点，存数据*/</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 获取并移除元素时使用的锁，如take, poll, etc */</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty <span class="token operator">=</span> takeLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 添加元素时使用的锁如 put, offer, etc */</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull <span class="token operator">=</span> putLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 默认构造器. * 队列容量为Integer.MAX_VALUE. */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用LinkedBlockingQueue(int capacity)</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 显示指定队列容量的构造器 */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化为头指针，尾指针为null的队列</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 从已有集合构造队列. * 队列容量为Integer.MAX_VALUE */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保证items数组的可见性，即保证插入，删除，读取操作不会操作数据不完整的队列</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 队列不能包含null元素</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> capacity<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 队列已满</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队尾插入元素</span>            <span class="token operator">++</span>n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 设置元素个数</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>构造完之后，LinkedBlockingQueue的初始化结构如下</p><p><img src="LinkedBlockingQueue%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84.png" alt=""></p><p>插入元素之后，LinkedBlockingQueue的结构如下</p><p><img src="LinkedBlockingQueue%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E7%BB%93%E6%9E%84.png" alt=""></p><h3 id="尾部插入-1"><a href="#尾部插入-1" class="headerlink" title="尾部插入"></a>尾部插入</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不能插入null元素</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//队列已满，返回false</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//加上插入锁</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//队列未满插入数据</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入前队列的长度</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果插入后队列不满，唤醒等待的插入线程</span>                notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> c <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不可插入null数据</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入之前的队列长度</span>    putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果已经满了，则加入notFull队列等待</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//被唤醒后，插入数据</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取后再增加</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果插入后队列未满，则可以唤醒下一个插入线程</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//插入之前的队列长度</span>    putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列已满，在notfull队列上等待nanos时间</span>        <span class="token punctuation">}</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒，插入数据</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果插入后队列未满，则可以唤醒下一个插入线程</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果之前的队列为空，现在已经插入一个数据，因此可以唤醒删除线程</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert putLock.isHeldByCurrentThread();</span>    <span class="token comment" spellcheck="true">// assert last.next == null;</span>    last <span class="token operator">=</span> last<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在尾节点插入数据</span><span class="token punctuation">}</span></code></pre><h3 id="头部删除-1"><a href="#头部删除-1" class="headerlink" title="头部删除"></a>头部删除</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果队列为空，返回null</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    E x <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果队列不为空，删除头部元素</span>            x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//删除之前，队列长度大于1，则可以唤醒下一个删除线程</span>                notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    E x<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//可中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//队列长度为0，加入到notEmpty等待队列中</span>            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒后，删除元素</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果删除之前长度大于1，则可以唤醒下一个删除进程</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    E x <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//等待的时间</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持中断</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//队列长度为0，加入到notEmpty等待队列等待nanos时间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//被唤醒后，删除元素</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果删除之前长度大于1，则可以唤醒下一个删除进程</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果删除之前队列是满的，删除后则唤醒添加线程</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// assert takeLock.isHeldByCurrentThread();</span>     <span class="token comment" spellcheck="true">// assert head.item == null;</span>     Node<span class="token operator">&lt;</span>E<span class="token operator">></span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head头部没有数据</span>     Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>     h<span class="token punctuation">.</span>next <span class="token operator">=</span> h<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC    ，自己指向自己</span>     head <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head指针后移</span>     E x <span class="token operator">=</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>     first<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h2 id="ArrayBlockingQueue与LinkedBlockingQueue对比"><a href="#ArrayBlockingQueue与LinkedBlockingQueue对比" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue对比"></a>ArrayBlockingQueue与LinkedBlockingQueue对比</h2><table><thead><tr><th></th><th>ArrayBlockingQueue</th><th>LinkedBlockingQueue</th></tr></thead><tbody><tr><td>底部数据结构</td><td>环形数组，存储元素</td><td>链表，封装成Node插入</td></tr><tr><td>锁</td><td>只有一个lock，插入删除只能一个进行</td><td>takeLock和putLock两个锁，插入删除可同时进行，效率会更高一些</td></tr><tr><td>队列大小</td><td>必须指定大小</td><td>可不指定大小默认为Integer.MAX_VALUE，可指定大小</td></tr><tr><td>插入唤醒</td><td>插入数据后直接唤醒删除线程</td><td>插入数据后如果还有空间唤醒后续插入线程；插入之前为空队列再唤醒删除线程</td></tr><tr><td>删除唤醒</td><td>删除数据后直接唤醒插入线程</td><td>删除数据后如果还有数据唤醒后续删除线程；删除之前为满队列再唤醒插入线程</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/77410889</a></p><p><a href="https://segmentfault.com/a/1190000016296278" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016296278</a></p><p><a href="https://blog.yeskery.com/articles/338891277" target="_blank" rel="noopener">https://blog.yeskery.com/articles/338891277</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2019/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2019/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一-计算机系统概述"><a href="#一-计算机系统概述" class="headerlink" title="一. 计算机系统概述"></a>一. 计算机系统概述</h2><h3 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h3><p>硬件性能参数</p><ul><li>计算机字长：CPU字长，指CPU一次能处理数据的二进制位数</li><li>机器主频：时钟脉冲的频率</li><li>主存容量：计算机能够存放的最大的二进制位数bit，B，KB，MB</li></ul><p>计算机性能指标</p><ul><li><p>响应时间：计算机完成某任务从任务输入到结果输出的全部时间</p></li><li><p>吞吐量：单位时间内计算机完成的工作量</p><p>CPI：执行一条指令平均使用的CPU时钟个数</p><p>MIPS：每秒完成百万条（10的六次方）指令数</p></li></ul><h2 id="二-数据的表示和运算"><a href="#二-数据的表示和运算" class="headerlink" title="二. 数据的表示和运算"></a>二. 数据的表示和运算</h2><h3 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h3><p>$X =x_0x_1x_2…x_n$ </p><p>定点小数：$x_0$为符号位，$x_1x_2…x_n$为尾数（小数部分的内容）$[-(1-2^n),1-2^{n}]$</p><p>定点整数：$x_0$为符号位，$x_1x_2…x_n$为尾数（整数部分的内容）$[-(2^n-1),2^n-1]$</p><table><thead><tr><th>真值</th><th>$-2^n$</th><th>$-(2^n-1)$</th><th>-1</th><th>0</th><th>+1</th><th>$2^n-1$</th></tr></thead><tbody><tr><td>原码</td><td>无</td><td>11…11</td><td>10…01</td><td>10…00/00…00</td><td>00…01</td><td>01…11</td></tr><tr><td>反码</td><td>无</td><td>10…00</td><td>11…10</td><td>11…11/00…00</td><td>00…01</td><td>01…11</td></tr><tr><td>补码</td><td>10…00</td><td>10…01</td><td>11…11</td><td>00…00</td><td>00…01</td><td>01…11</td></tr></tbody></table><h3 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h3><p>步骤</p><ul><li>对阶</li><li>尾数加减运算</li><li>尾数结果规格化</li><li>舍入</li><li>溢出判断</li></ul><p>算术逻辑单元ALU</p><ul><li><p>一位全加器</p><p>加数A，加数B，进位C</p></li><li><p>并行加法器</p><p>由多个一位全加器组成</p><ul><li><p>串行进位</p><p>高位依赖低位的进位信息</p></li><li><p>并行进位</p><p>高位低位同时进行运算</p></li></ul></li></ul><h2 id="三-存储器层次结构"><a href="#三-存储器层次结构" class="headerlink" title="三. 存储器层次结构"></a>三. 存储器层次结构</h2><h3 id="半导体存储器RAM"><a href="#半导体存储器RAM" class="headerlink" title="半导体存储器RAM"></a>半导体存储器RAM</h3><p>RAM（随机存取存储器）随机存取存储器，每次访问时间是固定的，与其所在的物理位置无关。</p><p>RAM可以分为静态RAM与动态RAM。</p><ul><li>SRAM：利用触发器电路状态存储信息</li><li>DRAM：利用MOS电容是否带电荷存储信息</li></ul><p>RAM与ROM</p><ul><li>ROM只能读不能写，常用于存放系统程序或不需要修改的数据，非易失</li><li>RAM既可以读也可以写，常用来存放用户程序，数据或作为系统程序的工作区，易失</li></ul><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>多用于cache</p><p>由存储阵列，地址译码器，I/O电路，片选线，读写控制电路组成</p><ul><li><p>存储阵列：是主存储器的核心，程序与数据存放在存储阵列中</p></li><li><p>地址译码器：包含译码器与驱动器，可分为一维译码器（字选择线），二维译码器（字选择线+位选择线）</p><ul><li><p>二维译码器</p><p>将一维线性排列的存储单元进行重新排列，变成二维排列。行选择线选择某一行，位选择线选择该行第几个存储器。</p></li></ul></li><li><p>片选器：实现选择某一个芯片</p></li><li><p>I/O电路与读写控制电路：完成选中存储单元中各位的读出与写入操作</p></li></ul><p>参数：</p><ul><li>数据引脚数量=存储字长=存储单元所包含存储元个数</li><li>存储阵列容量=存储数量（存储单元的个数，与地址线数量有关）*存储字长</li><li>地址引脚数量：与存储单元的个数有关</li></ul><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>多用于主存</p><ul><li><p>刷新：对DRAM定期进行全部重写过程。刷新操作主要解决存储单元中电容缓慢泄露电荷导致的信息丢失问题。</p></li><li><p>DRAM刷新地址计数器：指刷新存储器的行地址。其位数就是行地址的位数</p></li><li><p>刷新的方式</p><ul><li><p>集中式刷新</p><p>是指将各行的行刷新集中一段时间统一进行</p></li><li><p>分散式刷新</p><p>将存储周期扩大一倍，前半段用于正常的读写，后半段用于行刷新。不存在“死区”</p></li><li><p>异步式刷新</p><p>将各行的行刷新均匀分散在整个刷新周期中进行，对集中式刷新和分散式刷新的折中</p></li></ul></li></ul><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>数据存放的方式：</p><ul><li>小端照齐：数据的最低位存放在地址低位</li><li>大端照齐：数据的最高位存放在地址低位</li></ul><h4 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h4><ul><li>位扩展：横向扩展</li><li>字扩展：纵向扩展</li><li>字与位同时扩展：纵向横向同时扩展</li></ul><h4 id="片选"><a href="#片选" class="headerlink" title="片选"></a>片选</h4><p>CPU对存储单元的访问：</p><ol><li>选择存储芯片，即进行片选</li><li>从选中的芯片中依地址码选择对应的存储单元，即进行字选</li></ol><p>片选的方法：</p><ul><li>线选法：有多少个芯片就有多少个选择线，一个选择线对应一个芯片</li><li>全译码法：对芯片进行编码，n个芯片，需要$log_2n$个选择线</li><li>部分译码：相比全译码方法，会多出几位无用</li></ul><h3 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>读</p><ul><li>Cache和主存均被分为若干个大小相等的块，每个块由若干字节组成</li><li>CPU发出主存地址后<ul><li>首先判断该存储字是否在Cache中，若命中，直接访问Cache</li><li>若不命中，则访问主存并将该字所在的主存块装入Cache</li></ul></li></ul><p>写，可能出现数据不一致问题</p><ul><li>如果命中Cache<ul><li>写直达法：将信息同时写入Cache和主存中</li><li>写回法：将信息写入Cache，在Cache被替换时再写入主存</li><li>写一次法：与写回法一样，但再第一次写入时也将信息写入到主存</li></ul></li><li>如果不命中Cache<ul><li>不按写分配法：只将需要写的信息写入主存</li><li>按写分配法：将需要写的信息写入主存后，再将该块从主存中读入Cache</li></ul></li></ul><h4 id="Cache与主存之间的映射关系"><a href="#Cache与主存之间的映射关系" class="headerlink" title="Cache与主存之间的映射关系"></a>Cache与主存之间的映射关系</h4><p>主存的块标记有m位，即主存有$2^m$个块，块大小$2^b$个字，Cache一个$2^c$个块，块大小$2^b$个字</p><ol><li><p>全相联映射</p><p>主存中某个块可以被放到Cache中任意一个位置</p><p>主存：| 块号m位 | 块内地址b位 |</p><p>Cache：| 块号c位 | 块内地址b位 |</p><p>目录表： 块标记位数m位</p></li><li><p>直接映射</p><p>将主存划分为若干个区，每个区的块数与Cache的块数相同，区内第$j$个块只能放在Cache第$j$个块</p><p>主存快标记m=k+c，$2^c$为Cache的块数，k为区标记，一共$2^k$个区</p><p>主存：| 区号k位 | 区内块号c位 | 块内地址b位 |</p><p>Cache：| 块号c位 | 块内地址b位 |</p><p>目录表：块标记位数k位</p></li><li><p>组相联映射</p><p>Cache分成若干个组，每个组包含多个块，将主存划分为若干个区，每个区的主存块数与Cache的组数相同，区内第j块可以放置在Cache的第j组的任意位置</p><p>Cache中c=(c-g)+g，一个$2^{c-g}$个组，一个组内有$2^g$个块</p><p>主存快标记m=(m-c+g) + (c-g) ，一共$2^{m-c+g}$个区，一个区内有$2^{c-g}$个块数</p><p>n路组相联表示一组中有n个数据块</p><p>主存：| 区号k位 | 区内块号g位 | 块内地址b位 |</p><p>Cache：| 组号g位 | 块号c位 | 块内地址b位 |</p><p>目录表：块标记位数k位</p></li></ol><h2 id="四-MIPS-指令系统"><a href="#四-MIPS-指令系统" class="headerlink" title="四. MIPS 指令系统"></a>四. MIPS 指令系统</h2><p>MIPS按字节寻址，一条指令长度为32位，一个字长，所以执行一条指令，PC＋４</p><p>程序控制局部性原理：<strong>时间局部性</strong>和<strong>空间局部性</strong></p><h3 id="MIPS指令格式"><a href="#MIPS指令格式" class="headerlink" title="MIPS指令格式"></a>MIPS指令格式</h3><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_MIPS%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.PNG" alt=""></p><h3 id="MIPS寻址方式"><a href="#MIPS寻址方式" class="headerlink" title="MIPS寻址方式"></a>MIPS寻址方式</h3><p>寄存器取数使用()，例如(R)</p><p>主存按地址取数使用[]，例如[(R)]</p><h4 id="MISP"><a href="#MISP" class="headerlink" title="MISP"></a>MISP</h4><ul><li><p>寄存器寻址：操作数在寄存器组中，指令中有寄存器编号</p></li><li><p>立即数寻址：操作数在指令中</p></li><li><p>基址寻址：操作数地址=基址+偏移地址，基址寄存器编号和偏移地址均在指令中</p></li><li><p>PC相对寻址：操作数地址=PC+偏移地址，偏移地址在指令中</p></li><li><p>伪直接寻址：操作数在主存中，操作数地址在指令中</p><p>单地址指令：操作码+A</p><p>双地址指令：操作码+A+A</p><p>操作码采用定长编码：所有指令格式的操作码长度相同</p><p>操作码采用变长编码：指令格式操作码长度不一样</p></li></ul><p>有效地址为EA，获取操作数需要访问内存的次数</p><table><thead><tr><th>寻址方式</th><th>有效地址</th><th>访存次数</th></tr></thead><tbody><tr><td>立即数寻址</td><td>A即为操作数</td><td>0</td></tr><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>寄存器寻址</td><td>EA=$R_i$</td><td>0</td></tr><tr><td>基址寻址</td><td>EA=(BR)+A</td><td>1</td></tr><tr><td>PC相对寻址</td><td>EA=(PC)+A</td><td>1</td></tr></tbody></table><h4 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h4><ul><li>立即寻址：√</li><li>寄存器寻址：√</li><li>直接寻址：√</li><li>间接寻址：两次寻址</li><li>寄存器间接寻址：两次寻址</li><li>基址寻址：基址固定不变</li><li>变址寻址 = MISP的基址寻址（基址寄存器）</li><li>相对寻址：√</li></ul><h2 id="五-MIPS处理器"><a href="#五-MIPS处理器" class="headerlink" title="五.MIPS处理器"></a>五.MIPS处理器</h2><h3 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h3><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_CPU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.PNG" alt="CPU内部结构"></p><p>CPU的基本功能就是对指令流和数据流在时间和空间上实施正确的控制</p><ul><li>指令流：CPU执行的指令序列</li><li>数据流：根据指令操作要求依次存取数据的序列</li></ul><p>指令的四种基本操作：</p><ul><li>取数：读取某个主存单元的数据，并传输到某个寄存器中</li><li>存数：将某个寄存器的数据存入到主存某个单元之中</li><li>传送：将某个寄存器的数据传输到ALU或者另一个寄存器中</li><li>运算：进行某种逻辑运算，并将结果保存到某一个寄存器中</li></ul><p>CPU组成：</p><ul><li>程序计数器PC</li><li>指令寄存器IR：存放从存储器中取出的指令</li><li>存储器数据寄存器MDR：暂存由主存读出的一条指令或一个数据字</li><li>存储器地址寄存器MAR：保存当前CPU所访问的主存单元地址</li></ul><p>CPU执行流程：</p><pre><code>以ADD R1,(R2)为例：R1 &lt;- (R1)+((R2))最后再将R1中数据放回内存取指：    T1:PC -&gt; MAR            //读取地址    T2:1 -&gt; READ            //发出读命令       M(MAR) -&gt; MDR        //读取数据    T3:MDR -&gt; IR            //读出的数据放在    T4:PC+1 -&gt; PC             //PC+1取数：    T1:R2 -&gt; MAR    T2:1 -&gt; READ       M(MAR) -&gt; MDR    T3:MDR -&gt; B    T4:R1 -&gt; A运算：    A+B -&gt; AC    AC -&gt; R1写回：    T1: R1 -&gt; MDR    T2: PC -&gt; MAR    T3: 1 -&gt; WRITE        MDR-&gt;M(MAR)    T4: PC+1 -&gt; PC</code></pre><h3 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h3><p>所有指令执行周期为固定为单一时钟周期，即CPI=1.采用<strong>哈弗体系结构</strong>（指令和数据采用不同存储器）。</p><h4 id="单周期数据通路设计"><a href="#单周期数据通路设计" class="headerlink" title="单周期数据通路设计"></a>单周期数据通路设计</h4><ol><li><p>取指和PC自增数据通路</p><p>功能描述：</p><ul><li>取指：IM Address ⬅PC，instruction=IM[PC]</li><li>PC自增：PC⬅PC+4</li></ul><p>所需部件：PC，Adder，指令寄存器IM</p></li><li><p>R型指令数据通路</p><p>add rd，rs，rt</p><ul><li>rd第三个寄存器</li><li>rs第一个寄存器</li><li>rt第二个寄存器</li></ul><p>功能描述：R[rd]⬅R[rs]+R[rt]</p><p>所需部件：寄存器堆，ALU</p></li><li><p>加载数据指令</p><p>lw rt，rs，imm16</p><p>功能描述：R[rt] = DM[ R[rs]+Signext(imm16) ]</p><p>通路部件：寄存器堆，ALU，符号扩展单元Signext，数据存储器DM</p></li><li><p>存数指令</p><p>sw rt，rs，imm16</p><p>功能描述：DM[R[rs]+Signext(imm16)] ⬅R[rt]</p><p>通路部件：寄存器堆，ALU，符号扩展单元Signext，数据存储器DM</p></li><li><p>分支指令数据通路</p><p>beq rs，rt，imm16</p><p>功能描述：If ( R[rs] – R[rt] =0) then PC  ⬅ (PC + 4) + Signext(imm16)&lt;&lt;2</p><pre><code>                                                 else PC  ⬅  PC + 4</code></pre><p>通路部件：寄存器堆，ALU，增加一个加法器，符号扩展器，移位器</p></li></ol><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.PNG" alt=""></p><h4 id="指令执行时间计算"><a href="#指令执行时间计算" class="headerlink" title="指令执行时间计算"></a>指令执行时间计算</h4><ul><li>采用单周期，即所有指令周期固定为单一时钟周期，<ul><li>时钟周期由最长的指令决定(LW指令)，为600ps</li></ul></li><li>不同类型采用不同的指令周期（可变时钟周期）</li></ul><p>改进方法：改变m每种指令类型所用的时钟数，采用多周期实现</p><h3 id="多周期处理器"><a href="#多周期处理器" class="headerlink" title="多周期处理器"></a>多周期处理器</h3><p>为什么不使用单周期实现方式</p><pre><code>单周期设计中，时钟周期对所有指令等长，而时钟周期由计算机中可能的最长执行时间的指令决定，一般为取数指令。因此一些较短执行时间的指令会浪费一段时间</code></pre><p>多周期方案（采用普林斯顿结构，指令和数据采用一个存储器）</p><ul><li>将指令分为多个步骤执行，每一个步骤一个时钟周期，则指令执行周期为多个周期，不同指令的指令周期包含时钟周期不一样。</li><li>优点：<ul><li>提高性能</li><li>降低成本：一个功能单元可以在一条指令执行过程中使用多次，只要是在不同的周期内（有点像流水线）</li></ul></li></ul><h4 id="MIPS多周期数据通路设计"><a href="#MIPS多周期数据通路设计" class="headerlink" title="MIPS多周期数据通路设计"></a>MIPS多周期数据通路设计</h4><p>一个ALU，指令算术逻辑运算，取指后PC+4，beq转移指令，都在ALU中完成，扩展数据为补码形式。</p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%A4%9A%E5%91%A8%E6%9C%9F%E6%8C%87%E4%BB%A4.PNG" alt=""></p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E5%A4%9A%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.PNG" alt=""></p><h3 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h3><ul><li>流水线不改善单个任务处理延迟，但改善了整个工作负载得吞吐率</li><li>流水线速率受限于最慢的流水段</li><li>多个任务同时工作，但占用不同的资源</li><li>潜在加速比=流水线级数</li></ul><h4 id="流水线的五个阶段"><a href="#流水线的五个阶段" class="headerlink" title="流水线的五个阶段"></a>流水线的五个阶段</h4><ol><li>IF：取指令，PC值变化，利用PC中地址从内存中读取指令，放入ID/IF中</li><li>ID：指令译码，读寄存器，从寄存器堆中读取数据放入到ID/EXE中</li><li>EX：执行运算，ALU操作，将结果放在EX/MEM中<ul><li>Load/Store：计算地址</li></ul></li><li>EME：访存。为每一条指令分配该阶段是为了保证同一时刻不会有两条指令都访问数据缓存<ul><li>Load：从Memory读取数据</li><li>Store：将数据写入Memory</li></ul></li><li>WB：数据写回寄存器，将计算结果从ALU输出寄存器写回RF中</li></ol><p>不同阶段之间增加寄存器，保存前一个周期产生的信息。</p><ul><li>命名法则：前级/后继</li><li>功能：时钟上升沿到来，保存前级结果，之后输出至下级组合逻辑</li></ul><p>RF：Register File寄存器堆有两次使用：第二级读，第五级写。并且其第二个寄存器的值可以直接传递到EX/MEM</p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG" alt=""></p><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><p>流水线处理中，由于各个阶段的依赖关系，硬件资源的竞争等原因，会出现操作无法执行的情况。</p><p>在下一个时钟周期妨碍下一条指令执行的执行的情况称为<strong>数据冒险</strong></p><h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p> 结构冒险是指由于硬件资源的竞争，操作无法同时执行的情况，即资源使用冲突</p><ol><li><p>内存访问造成构造冒险</p><p>IF阶段和MEM阶段都涉及内存访问，访问内存使用的总线是共享资源，无法同时进行。（若依曼架构）</p><p>第一条指令为load或者save指令的第四个周期，会与第四条指令的第一个周期发生冲突。</p><p>解决方法：使用哈弗架构</p><pre><code>将指令用的内存和数据用的内存分别设置，即可解决构造冒险。CPU直接访问的缓存基本上都分为指令用和数据用两种，称为指令缓存和数据缓存</code></pre></li><li><p>寄存器访问造成构造冒险</p><p>WB阶段写回寄存器和ID阶段读取寄存器，寄存器无法读写同时进行</p><p>第一条指令为load或者R型指令第五个周期，会与第四条指令第二个周期发生冲突。</p><p>解决办法：分割寄存器堆的访问周期</p><pre><code>时钟周期前半段写，后半段读</code></pre></li></ol><h4 id="数据冒险-1"><a href="#数据冒险-1" class="headerlink" title="数据冒险"></a>数据冒险</h4><p>数据冒险指，由于指令所需要的数据还未准备好所引起的冒险情况。当即将执行的指令依赖于还未完成的数据时，会导致指令无法立刻开始执行，引起数据冒险。</p><ol><li><p>第一条指令在第五个周期将数据写回寄存器，若第二条指令第二个周期要用到第一条指令的数据，则会出现数据冒险</p><p>写回的数据，后续指令需要用到。第一条指令为R型指令，在第五个周期将数据写回寄存器，而第二条指令在第二个周期取指时需要用到该寄存器的值，发生数据冒险。</p></li></ol><p>解决方法：使用<strong>直通的方法</strong>，或者两个nop</p><pre><code>R型指令原本回写运算结果是在WB阶段，而实际上决定运算结果的是在EX阶段。直通方法就是指，在运算结果确定的EX阶段，将数据直接传递给下一个指令的ALU阶段EX/MEM.RegisterRd = ID/EX.RegisterRs = r1在EX/MEM与ID/EX中间加一个转发单元</code></pre><ol start="2"><li><p>数据冒险与阻塞</p><p>当一条指令读取一个寄存器而其前一条指令是load指令（需要将内存中的数据写回寄存器），并且该load指令写入的是同一个寄存器，则直通方法无法解决。原因：load指令写回的数据在MEM阶段完成后产生</p><p>解决方法：阻塞流水线</p><pre><code>当load指令后紧跟着一个需要其结果的指令时，必须采用相应的机制阻塞流水线。除了转发单元，还要将第二条指令阻塞一个周期，使用nop指令（没有任何效果），如果没有转发单元，需要两个nop指令</code></pre></li></ol><p>还可以调整指令的执行顺序。</p><h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p>控制冒险指，无法确定下一条指令而引发的冒险情况。</p><p>在执行可能会改变下一条指令的分支指令时，在这一条指令执行结果确定前（MEM之后）下一条指令无法进行</p><p>解决方法：</p><ul><li><p>假定分支不发生</p><p>即不管分支结果是否产生，继续向下执行，如果分支产生，则丢弃已经预取并译码的指令</p></li><li><p>缩短分支延迟</p><p>一般到MEM阶段才能确定分支结构要执行的下一条指令的PC。</p><p>题前计算分支的目的地址可以将分支加法器从EX段移动到ID段，将PC值和IF/ID流水线寄存器中的指令立即数相加，计算分支结果。</p><p>当分支指令的判断条件的数据寄存器依赖前一条指令的结果时</p><ul><li>如果依赖前一条指令的ALU计算结果时，通过转发单元完成</li><li>如果依赖前一条指令的回写阶段，通过nop指令实现</li></ul></li></ul><h2 id="六-总线与输入输出系统"><a href="#六-总线与输入输出系统" class="headerlink" title="六. 总线与输入输出系统"></a>六. 总线与输入输出系统</h2><h3 id="总线的仲裁方式"><a href="#总线的仲裁方式" class="headerlink" title="总线的仲裁方式"></a>总线的仲裁方式</h3><p>仲裁的方式有集中式和分布式两种。</p><h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><p>总线上主设备最少有两根信号线连接到总线仲裁机构，一根是总线请求信号线BR，一根是总线允许信号线BG</p><ol><li><p>链式查询方式</p><p>总线仲裁机构在有总线请求时，发出总线允许信号BG，由各主设备自行仲裁。需要三根信号线</p><p>特点：</p><ul><li>仲裁采用优先级策略，且各主设备的优先级固定，即离CPU越近主设备优先级越高</li><li>需要的仲裁信号线较少</li><li>可扩展性比较高，但对电路故障敏感，容易产生断链现象</li><li>三条线：BS（总线忙），BR（总线请求），BG（总线允许）</li></ul></li><li><p>计数器定时查询方式</p><p>使用设备地址信号线代替BG，内部使用计数器的计数信号表示设备。可以实现循环优先级和固定优先级两种方式。</p><p>特点：</p><p>　* 对电路不敏感，但信号线数量增多<br>　* 需要2+$log_2 n$条信号线，总线允许线改为设备地址线</p></li><li><p>独立请求方式</p><p>每个设备需要一对总线请求和总线允许信号线</p><p>特点</p><ul><li>速度快</li><li>优先次序控制灵活</li><li>线路多，电路复杂</li><li>n条BR，n条BG</li></ul></li></ol><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>不需要中央总裁器，每个设备都有自己的仲裁号和仲裁器，当某主设别由总线请求时，由自身决定仲裁结果。</p><h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h3><h4 id="I-O接口的功能"><a href="#I-O接口的功能" class="headerlink" title="I/O接口的功能"></a>I/O接口的功能</h4><ul><li><p>实现对主机和外设的通信联络控制</p></li><li><p>进行地址译码和设备选择</p><p>接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息</p></li><li><p>实现数据缓冲</p></li><li><p>数据格式的变换</p><p>并-串转换，串-并转换，模-数转换，数-模转换</p></li><li><p>传输控制命令和状态信息</p></li></ul><h4 id="I-O接口的结构"><a href="#I-O接口的结构" class="headerlink" title="I/O接口的结构"></a>I/O接口的结构</h4><p>接口要分别传送数据信息，控制信息，状态信息，这些数据都是由数据总线来传输</p><p>接口类型</p><ul><li>数据传输方式分类：串行接口，并行接口</li><li>主机访问I/O设备的控制方式分类：程序查询式接口，程序中断接口，DMA接口，通道</li><li>功能选择分灵活性分：可编程接口，不可编程接口</li><li>通用性分类：通用接口，专用接口</li><li>输入输出的信号分类：数字接口，模拟接口</li></ul><p>I/O端口：接口电路中可以被CPU直接访问的寄存器，若干个端口+相应的控制逻辑电路=接口</p><ul><li>数据端口：存放数据信息</li><li>命令端口：存放控制命令，CPU只可写</li><li>状态端口：存放状态信息，CPU只可读</li></ul><p>I/O端口编址方式：</p><ul><li>独立编址方式</li><li>统一编址方式</li></ul><h3 id="基本I-O方式"><a href="#基本I-O方式" class="headerlink" title="基本I/O方式"></a>基本I/O方式</h3><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>为了保证数据传输的正确进行，要求CPU在程序中查询外设的工作状态。如果外设没有准备好，CPU就循环等待，如果已经准备好，CPU才能执行I/O指令进行数据传送</p><p>流程：</p><ol><li>预置传送参数</li><li>向外设接口发出命令字</li><li>从外设接口取回状态字</li><li>查询外设标志</li><li>传送数据</li><li>修改传送参数：每进行一次数据传送之后必须修改传送参数：主存缓冲区地址+1，传送个数计数器-1</li><li>判断传送是否结束</li></ol><p>接口：</p><ul><li>数据缓冲寄存器：数据端口，用来存放CPU进行传送的数据信息</li><li>设备状态寄存器：供CPU查询的设备状态寄存器，即状态端口</li></ul><p>缺点：</p><ul><li>CPU等待外部设备</li><li>CPU只能和一台外设交换信息</li><li>不能发现和处理预先无法估计的错误和异常</li></ul><h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>计算机执行程序的过程中，出现某些急需处理的异常情况和特殊请求，CPU暂时中止现行程序，转去对出现的异常情况和特殊请求处理，在处理完毕之后，CPU将自动返回原来的程序继续执行</p><p>中断条件：</p><ul><li>CPU接收到中断请求信号</li><li>CPU允许中断，CPU内部有一个中断允许触发器（EINT）</li><li>一条指令执行完毕（缺页中断除外）</li></ul><p>中断隐指令：CPU响应中断之后，经过某些操作，需执行中断程序，这些操作由硬件实现，称为中断隐指令，包括保存断点，暂不允许中断，引出中断服务程序</p><p>中断过程：</p><ul><li>中断请求</li><li>中断判优（判断中断的优先级）</li><li>中断响应</li><li>中断处理<ul><li>准备部分：关中断，保护现场，判断中断源，开中断指令（允许更高级中断）</li><li>处理部分：执行中断服务程序</li><li>结尾部分：关中断，恢复现场，开中断指令</li></ul></li><li>中断返回</li></ul><p>中断屏蔽：有些中断发生后，可以选择性封锁部分中断，即中断屏蔽。中断屏蔽触发器（MASK），可以改变中断优先级（将原来较低的中断源编程较高的级别，称为中断升级）</p><p>中断分类：</p><p>分类一</p><ul><li>强迫性中断</li><li>自愿性中断</li></ul><p>分类二</p><ul><li>外中断</li><li>内中断</li></ul><p>分类三</p><ul><li>硬中断</li><li>软中断</li></ul><p>分类四</p><ul><li><p>向量中断：用硬件方法识别中断源和获得中断服务程序入口地址</p><p>中断向量：中断服务程序的入口地址</p></li><li><p>非向量中断：用软件查询的方式识别中断源和获得中断程序程序入口地址</p></li></ul><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>周期挪用（周期窃取）：每传输一个字需要占用一个存储周期的时间</p><p>直接存储器访问（DMA）在<strong>外设</strong>和<strong>主存</strong>之间开辟一条”直接数据通道”，在不需要CPU干预不需要软件介入的情况下在两者之间进行高速数据传送。</p><p>通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出<strong>系统总线</strong>，由DMA控制器接管总线进行数据传送</p><p>DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p><p>DMA与中断的区别：</p><ul><li>中断方式是程序切换，需要现场保护和现场恢复；DMA方式除了开始与结尾，不占用任何CPU资源</li><li>中断请求一般发生在每条指令执行完毕；DMA请求的响应时间可以发生在每个机器周期结束</li><li>中断传送需要CPU参与，DMA方式传输数据时无需CPU干预</li><li>DMA请求优先级高于中断请求</li><li>中断方式可以处理异常事件，DMA局限于传输数据块</li></ul><p>DMA控制器</p><ul><li>主存地址计数器：存放待交换数据的主存地址</li><li>传送长度计数器：记录长度计数器</li><li>数据缓冲寄存器：暂存每次传输的数据</li><li>DMA请求触发器：每当外设准备好数据后给出一个控制信号，使DMA请求触发器置位</li><li>控制/状态逻辑</li><li>中断机构：当一个数据块传输完毕之后触发中断机构，向CPU提出中断请求，CPU进行结尾处理</li></ul><p>传输过程</p><ul><li>DMA预处理：DMA传输之前进行初始化，由CPU完成</li><li>数据传送：以数据块为基本单位进行传输</li><li>DMA后处理：DMA向CPU发中断请求，CPU停止原来的程序执行，转去执行DMA结束处理工作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/25/hello-world/"/>
      <url>/2019/12/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域</title>
      <link href="/2019/01/13/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/01/13/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>JDK7的内存区域如下</p><ul><li>线程私有：虚拟机栈，本地方法栈，程序计数器</li><li>线程共享：堆内存，方法区</li></ul><p><img src="java7%E5%86%85%E5%AD%98.png" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>虚拟机中的程序计数器和计算机的程序计数器(PC)作用类似，可以看成当前线程所执行的字节码的行号指示器，用来记录下一条要执行的指令。</p><p>该区域没有规定任何OutMemeryError情况</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈用来描述<strong>java方法</strong>执行的内存模型，每个方法在执行的同时会创建一个栈帧。</p><p>栈帧中存放局部变量表，操作数栈，动态链接，方法出口</p><p>其中局部变量表存放编译器可知的各种数据类型，对象引用，returnAddress类型(执行下一条指令)，局部变量表所需要的内存空间在编译期间完成分配</p><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt=""></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆中存放所有的对象实例以及数组</p><p>堆内部也进行了分块划分，如下，这个划分会在垃圾回收时使用。</p><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86.png" alt=""></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区存储已被虚拟机加载的<strong>类信息</strong>，<strong>常量</strong>，<strong>静态常量</strong>，<strong>即时编译器编译的代码</strong>，该区域通常被称为“永久代”</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池时方法区的一部分，用于存放编译期生成的各种字面量和符号的引用</p><h3 id="jdk1-8的变化"><a href="#jdk1-8的变化" class="headerlink" title="jdk1.8的变化"></a>jdk1.8的变化</h3><ol><li>将方法区除运行时常量池部分移动到了直接内存</li><li>将运行时常量池部分移动到了堆中</li></ol><p><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt=""></p><h2 id="java的对象"><a href="#java的对象" class="headerlink" title="java的对象"></a>java的对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当虚拟机遇到一个new指令时</p><p><img src="java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.png" alt=""></p><ul><li><p>检查类是否已经加载</p><p>判断该类是否已被加载，解析，初始化，若没有的话，必须先执行类加载过程</p></li><li><p>为对象分配内存</p><p>对象所需要的内存大小在类加载完成之后便可完全确定。在类加载检查通过后，虚拟机将为对象分配内存。</p></li><li><p>初始化零值</p><p>内存分配完之后，虚拟机将分配到的内存空间都初始化为零值。这一步保证对象的实例字段在java代码中可以不赋初始值就可以直接使用，程序能访问这些字段的数据类型所对应的零值</p></li><li><p>对象头信息设置</p><p>虚拟机堆对对象进行必要的设置，例如对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码等等，这些信息都在对象头之中</p></li><li><p>执行init方法</p><p>最后一步即把对象按照程序员的意愿进行初始化</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机第二版》</p><p><a href="https://blog.csdn.net/bruce128/article/details/79357870" target="_blank" rel="noopener">https://blog.csdn.net/bruce128/article/details/79357870</a></p><p><a href="https://juejin.im/post/5a14de6751882555cc417df7" target="_blank" rel="noopener">https://juejin.im/post/5a14de6751882555cc417df7</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码阅读</title>
      <link href="/2019/01/12/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2019/01/12/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>Hashmap存储键值对，其根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，遍历顺序与插入顺序不一致。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。</p><p>特点</p><ul><li>根据键的hashcode值存储</li><li>hashmap通过Node&lt;K,V&gt;类型的table数组存储数据</li><li>hash冲突通过链表和红黑树解决，table数组中的元素指向链表或者红黑树</li><li>当链表长度大于8时，链表转为红黑树；当红黑树的节点个数少于6时，红黑树转为链表</li></ul><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>静态常量参数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认容量为16，hashmap的容量必须是2的正次幂</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">//最大容量，2^30</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//装载因子，用于判断是否需要扩容</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表转换为红黑树的阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红黑树转为链表的阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化。否则桶内元素太多时会扩容，而不是树形化。</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span></code></pre><p>属性参数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//hash桶，数组长度是2的整次幂</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//元素缓存set</span><span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//元素个数</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改次数，包括添加删除</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//扩容的阈值，当size大于threshold进行扩容</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//装载因子=(size/capacity),即所有元素比上桶的数量，默认0.75</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span></code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>hashmap一共提供了三个构造方法，这三个方法仅仅是将给一些参数复制，并没有初始化table数组，而等到放入第一个元素时，即调用put方法时，数组才会初始化，后面讲诉。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认的构造方法，默认的加载因子为0.75，该地方没有指定大小，会在resize()方法中指定默认大小</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all other fields defaulted</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定大小，使用默认的加载因子0.75</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定大小个装载因子</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设定装载因子</span>        <span class="token comment" spellcheck="true">/*这个地方比较迷，如下：          1. threshold是指扩容的阈值，当size大于threshold时，数据会扩容。          2. tableSize返回的是最小的大于等于initialCapacity的2的整次幂，例如，给定10，返回16          3. 根据threshold的定义，其threshold = table.length*loadFactor        */</span>        <span class="token comment" spellcheck="true">/*         *你会发现，threshold大于等于初始化的大小，比数组大小还大，根据其定义根本无法扩容。         *当debug到数组初始化时，会发现将threshold赋值给数组的大小         *这里threshold就是代表数组的长度，而随后threshold会根据长度*加载因子计算出        */</span>        <span class="token comment" spellcheck="true">/*          我自己的想法如下：          1. HashMap中没有表示数组长度的参数，获取数组长度通过table.length获取          2. 因为没有表示长度的参数，所以先使用threshold暂时表示数组的长度        */</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>HashMap中table数组长度是2的整次幂，通过如下实现</p><ul><li><p>初始化时，通过tableSizeFor()方法计算给定大小initialCapacity的最小的大于等于initialCapacity的2的整次幂，再通过threshold参数暂时表示数组长度。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//该方法实现：返回最小的大于等于输入参数cap的2的整次幂。</span><span class="token comment" spellcheck="true">//原理如下:</span><span class="token comment" spellcheck="true">/* 先来假设n的二进制为01xxx…xxx * 对n右移1位：001xx...xxx，再位或：011xx...xxx * 对n右移2为：00011...xxx，再位或：01111...xxx * 每一操作就是将1的个数翻倍 * 该算法就是将最高位的1后面的位全变为1。 * 最后再n+1就可以得到2的整次幂了 * * 而对于最开始的cap-1是针对cap本身就是2的整次幂这种特殊情况 * 例如：当给定16，即10000时，若不减1，先会得到11111，再加1，得到100000，为32，扩大二倍 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>给一个详细的例子：</p><p><img src="tableSizeFor.png" alt=""></p></li><li><p>在resize()方法中，每次扩容都会将数组长度扩大二倍</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>         threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>         <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>              oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//oldCap左移一位，即扩大二倍</span>         newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold，新的threshold为老的二倍</span> <span class="token punctuation">}</span></code></pre></li></ul><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>HashMap有几个非常重要的辅助方法，比如计算元素在table中位置的方法，即hash机制，以及每次table数组空间不够时要进行扩容时使用的扩容函数。</p><h4 id="hash机制"><a href="#hash机制" class="headerlink" title="hash机制"></a>hash机制</h4><p>hash机制主要是计算元素应该放在table数组哪一个位置，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1. 先去key的hashCode值，32位整数。</span><span class="token comment" spellcheck="true">//2. 将hashCode无符号右移，即将高16位放在低16位上</span><span class="token comment" spellcheck="true">//3. 将1和2的结果或，即hashCode的高16位与低16位或的结果放在低16位，高16位不变</span><span class="token comment" spellcheck="true">//4. 高16位与低16与的好处就是可以使用hashcode的所有特征，增加随机性，利于数据分散</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//无符号右移，左边部分总是以0填充，右边部分舍弃</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面是定位取数操作(选自put方法)，n表示数组的长度</span><span class="token comment" spellcheck="true">//位置结果为n减1再与hash值与，分析如下</span><span class="token comment" spellcheck="true">//1. n为2的整次幂，例如10000，减一之后为01111，设1的个数为x</span><span class="token comment" spellcheck="true">//2. (n-1)与hash与，即保持后x位不变，前(32-x)位全为0，而后x位的值表示的就是该元素的下标</span>tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span></code></pre><p>例如，一个值经过hash之后为<strong>10100101 11000100 00100101</strong>，当前长度为16，即n-1=15，所以有如下结果</p><pre><code>    10100101 11000100 00100101&amp;   00000000 00000000 00001111    //15----------------------------------    00000000 00000000 00000101    //高位全部归零，只保留末四位</code></pre><p>将数组长度设置为2的整次幂，当减1之后，得到的数就像一个掩码一样，取后面几位。</p><p>整体过程如下：</p><p><img src="hash%E6%9C%BA%E5%88%B6.png" alt="hash机制"></p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>扩容机制是非常重要的,其保证table长度始终是2的整次幂。</p><p>扩容函数除了将数组扩大二倍之外，在初始化数组中也会应用到。</p><p>在resize()函数中，会先创建一个扩容后的数组，然后再将原来的数据移动到新的数组中，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第一步是先计算新的数组长度和扩容阈值，这里分为三种情况</span>    <span class="token comment" spellcheck="true">//1. 已经初始化过数组，只需要将长度扩大二倍，扩容阈值扩大二倍，注意要检查是否超出最大的范围</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                 oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先将数据长度扩大二倍，再将扩容阈值扩大二倍</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//下面两种情况是还没有初始化数组，现在要先进行初始化</span>    <span class="token comment" spellcheck="true">// 2. 对于HashMap(int initialCapacity)，HashMap(int initialCapacity, float loadFactor)，这两种情况均指定了threshold,大小为2的整次幂，即代表数组的长度，现在将扩容阈值复制给数组长度</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>         newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//3. 对于默认情况，仅定义了loadFactor，初始化为默认大小，扩容阈值=数组长度*扩容因子</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//继续接情况2，2情况下只指明了数组大小，没有指明扩容阈值，下面计算扩容阈值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计算扩容阈值</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据新长度new出一个数组</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是第一次放元素，即oldTab为null，会直接返回新创建的数组</span>    <span class="token comment" spellcheck="true">//第二步，将老数组中的元素移动到新数组中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//获取老数组中的元素</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将老数组清空，垃圾回收</span>                <span class="token comment" spellcheck="true">//将老数组中元素移动到新数组也分为三种情况</span>                <span class="token comment" spellcheck="true">//1. 桶中只有一个元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">//计算在数组中的位置的方法和之前一样</span>                    <span class="token comment" spellcheck="true">//注意这里是新的数组的长度，在二进制表示上，相当于多了一位1，会有下面两种情况</span>                    <span class="token comment" spellcheck="true">//假设，之前数组长度为16（15=1111），现在为32（31=11111）</span>                    <span class="token comment" spellcheck="true">//（1）.当其hash值第5位为1，则在新位置比老位置多了oldCap的长度</span>                    <span class="token comment" spellcheck="true">//（2）.当其hash值第5位为0，则在老位置不变换</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//2. 桶中结构是红黑树</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//3. 桶中结构是链表</span>                    <span class="token comment" spellcheck="true">//和桶中只有一个元素的情况一样，判断多出来的一位是0还是1</span>                    <span class="token comment" spellcheck="true">/** 首先是先将老数组的元素分发到两个链表中                     *  多出的一位为0，将数据放在lohead，loTail链表中                     *  多出的一位为1，将数据放在hiHead，hiTail链表中                     */</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//链表中下一个位置</span>                        <span class="token comment" spellcheck="true">//将多出一位为0的数，放在头元素是loHead，尾元素是loTail的链表中</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//将多出的一位为1的数，放在头元素是hiHead，尾元素是hiTail的链表中</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//将上述的两个链表放在对应的桶中</span>                    <span class="token comment" spellcheck="true">/** 由老数组存放到链表中时，是从头到尾遍历存放                     *  而从链表存放到新数组中，是从尾到头逆序存放                     *  因此新数组相对于旧数组会逆序                     */</span>                     <span class="token comment" spellcheck="true">//多出一位为0的，在原位置不动</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//多出一位为1的，新位置比原位置大了oldCap</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上诉判断新坐标过程如下：</p><p>扩容前长度为16，key1的坐标为5，key2的坐标为5</p><p>扩容后长度为32，key1的坐标为5，key2的坐标为21</p><p><img src="%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.png" alt=""></p><p>key2的变化如下：</p><p><img src="%E6%89%A9%E5%AE%B9%E7%BB%93%E6%9E%9C.png" alt=""></p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>常用的操作主要有添加，删除，查找这三种，这里也主要阅读了这三个方法的源码。</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//put方法会将要添加的数据添加到对应的桶中，而且table数组的初始化也放生在第一次添加数据时</span><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数组还未初始化，调用resize()方法，返回初始化的数组</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//下面开始存放元素，分为3种情况</span>    <span class="token comment" spellcheck="true">//1. 桶中没有任何元素，直接放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>         K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//仍然对应第一种情况，如果存在元素，key也相同，替换元素即可</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2. 桶中有元素，结构为红黑树</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//3. 桶中有元素，结构为链表</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//添加到链表尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果超过树形化的阈值，将链表转为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//找到key相同的值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//当找到key相同时，替换元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断是否需要扩容</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span>         null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">,</span> Object value<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> null<span class="token punctuation">,</span> e<span class="token punctuation">;</span>         K k<span class="token punctuation">;</span>         V v<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//删除分为三种情况，分两步</span>        <span class="token comment" spellcheck="true">//第一步先找到要删除的元素</span>        <span class="token comment" spellcheck="true">//1. 当桶中第一个即为删除元素时</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//2. 当桶中结构为红黑树时</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//3. 当桶中结构为链表时</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                         <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//第二步删除找到的元素，也是分为红黑树，链表，桶中第一个元素三种情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                             <span class="token punctuation">(</span>value <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">else</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">;</span>     K k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查找分为三种情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1. 桶中第一个元素即为查找的元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//2. 桶中结构为红黑树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//3. 桶中结构为链表</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u010983881/article/details/78637763" target="_blank" rel="noopener">https://blog.csdn.net/u010983881/article/details/78637763</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库分库分表</title>
      <link href="/2019/01/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2019/01/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p><strong>垂直拆分是将一个包含了很多表的数据库,根据表的功能的不同,拆分为多个小的数据库,每个库中包含部分表。</strong></p><p>比如大型的电商项目平台是由不同的子项目模块构成的如订单系统，账户系统，商品管理系统等等，这些个独立的模块都可以拆分成独立的服务与独立的数据库。</p><p>优点</p><ul><li>拆分后业务清晰，拆分规则明确。</li></ul><ol start="2"><li>系统之间整合或扩展容易。</li><li>数据维护简单。</li></ol><p>缺点</p><ul><li>存在单表数据量过大的问题（需要水平切分）</li><li>部分业务表无法join，只能通过接口方式解决，提高了系统复杂度</li></ul><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。<strong>水平切分分为库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。</strong></p><p>比如存放大量用户购物信息的购物表，可以按照下单时间拆分成多个表，每一个表就可以只存放少量的数据，再将这些表存在不同的数据库中，即可解决单库读写，存储性能瓶颈问题。</p><p>优点</p><ul><li>单表大小可控</li><li>便于扩展，如果要对集群扩容，只需要添加节点，无需对其他节点进行数据迁移</li></ul><p>缺点</p><ul><li>热点数据成为性能瓶颈。例如订单系统，近一段的订单可能会被频繁读写，而很早的历史订单则会很少读取。</li></ul><p>水平拆分的三种情况，以students表，db数据库为例</p><ul><li><p>只分表，将一个表水平拆分存储在一个数据库中</p><p>例如，db中存放students1和students2两个表</p></li><li><p>只分库，在多个数据库中分别存放一个表</p><p>例如，db1存放了一个students表，db2也存放了一个students表</p></li><li><p>分库分表，在多个数据库中存放多个相同的表（<strong>可以解决数据库IO瓶颈，数据库连接压力，CPU，网络，内存等等的瓶颈问题。</strong>）</p><p>例如，db1存放了students1和students2两个表；db2也存放了students1和students2两个表</p></li></ul><h2 id="主从复制读写分离"><a href="#主从复制读写分离" class="headerlink" title="主从复制读写分离"></a>主从复制读写分离</h2><p><strong>在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，很多情况下是不能满足实际需求的，通过主从复制的方式来同步数据保证数据不丢失，再通过读写分离来提升数据库的并发负载能力减轻服务器的压力</strong></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt=""></p><p>过程</p><ol><li>在每个事务更新数据完成之前，master在二进制日志进行记录，记录之后，master通知存储引擎提交事务。</li><li>Slave将master的binary log复制到其中继日志</li><li>Slave的线程从中继日志读取事件日志，然后更新slave数据，使其与master中的数据一致</li></ol><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p><img src="%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png" alt=""></p><p>读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也减轻了主服务器的压力。</p><ul><li>主库，提供数据库写服务</li><li>从库，提供数据库读服务</li></ul><h2 id="分库分表比较"><a href="#分库分表比较" class="headerlink" title="分库分表比较"></a>分库分表比较</h2><p>读写分离主要解决数据库读性能瓶颈，水平拆分主要解决数据库数据量大的问题，垂直拆分是实现业务解耦</p><p>数据库拆分原则</p><ol><li><p>优先考虑缓存降低对数据库的读操作。</p></li><li><p>再考虑读写分离，降低数据库写操作。</p></li><li><p>最后开始数据拆分,切分模式： <strong>首先垂直（纵向）拆分、再次水平拆分</strong>。</p></li><li><p>首先考虑按照业务垂直拆分。</p></li><li><p>再考虑水平拆分：先分库(设置数据路由规则，把数据分配到不同的库中)</p></li><li><p>最后再考虑分表，单表拆分到数据1000万以内。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.qingtingip.com/h_186509.html" target="_blank" rel="noopener">https://www.qingtingip.com/h_186509.html</a></p><p><a href="https://blog.csdn.net/shiyong1949/article/details/59586773" target="_blank" rel="noopener">https://blog.csdn.net/shiyong1949/article/details/59586773</a></p><p><a href="https://blog.csdn.net/worn_xiao/article/details/83963932" target="_blank" rel="noopener">https://blog.csdn.net/worn_xiao/article/details/83963932</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2019/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。而如果没有索引，那么可能需要把所有单词看一遍才能找到，这个过程是非常耗费时间的。</p><h2 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h2><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>根本区别</p><ul><li>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</li></ul><p>区别与联系</p><ul><li>两个索引底层均是由B+树实现</li><li>聚集索引叶子即数据，非聚集索引叶子存放指向数据的指针</li></ul><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>数据行的物理顺序与列值的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p><ul><li>查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放</li><li>修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序</li></ul><p>类似于字典的拼音索引，拼音的顺序与字典中汉字实际的顺序一致，当查两个读音一致的词时，找到第一个词后直接向后寻找即可找到第二个词。</p><p>Mysql创建聚集索引</p><pre class=" language-mysql"><code class="language-mysql">create CLUSTERED INDEX 索引名称 ON 表名(字段名)</code></pre><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p><ul><li><p>不会造成数据的重排</p></li><li><p>相对聚集索引可能会慢一些（二次查询造成查询变慢：非聚集索引叶子存放指向数据的指针，当查询列中包含了该索引没有覆盖的列，那么就必须访问该叶子节点指向的数据块查询对应的数据行的数据。）</p><p>二次查询例子：</p><table><thead><tr><th>name</th><th>class</th><th align="left">socre</th></tr></thead><tbody><tr><td>张一</td><td>数学</td><td align="left">100</td></tr><tr><td>张二</td><td>语文</td><td align="left">99</td></tr><tr><td>张三</td><td>英语</td><td align="left">98</td></tr><tr><td>张四</td><td>物理</td><td align="left">97</td></tr></tbody></table><p>建立非聚集索引（name，class）</p><pre class=" language-mysql"><code class="language-mysql">//叶子节点中包好class信息，所以查询到叶子节点即可查到信息select name from table1 where class <> '数学';//叶子节点不包含name，socre信息，所以必须查询结点select name, socre from table1 where class = '数学'</code></pre></li></ul><p>类似于字典的笔画索引，笔画的顺序与字典中汉字实际顺序不一致，当查找两个笔画一样的词时，需要分别查询两个词的位置（两个词一般不会挨着）</p><p>Mysql创建非聚集索引</p><pre class=" language-mysql"><code class="language-mysql">create NONCLUSTERED INDEX 索引名称 ON 表名(字段名)</code></pre><h2 id="建立索引的原则"><a href="#建立索引的原则" class="headerlink" title="建立索引的原则"></a>建立索引的原则</h2><ol><li><p><strong>最左前缀匹配原则</strong>，mysql会一直向右匹配索引直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></li><li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p></li><li><p><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col) / count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p></li><li><p><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/m0_37683670/article/details/85858846" target="_blank" rel="noopener">https://blog.csdn.net/m0_37683670/article/details/85858846</a></p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库三范式</title>
      <link href="/2019/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
      <url>/2019/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><p><strong>数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性</strong></p><ul><li>第一范式的目标是确保每列的原子性</li><li>如果每一列的都是不可再分的最小数据单元，则满足第一范式</li></ul><p>例如：</p><pre><code>每一个人可能有一个公司座机，有一个家庭座机，携带的手机表一：(姓名，性别，电话)        //电话还可以再分，不满足第一范式表二：(姓名，性别，公司座机，家庭座机，手机)        //满足第一范式</code></pre><h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h3><p><strong>满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情</strong></p><ul><li>第二范式要求m每个表只描述一件事情</li><li>如果一个关系满足1NF，并且主键以外其他列，每个属性都依赖主键，则满足第二范式</li></ul><p>例如：</p><pre><code>一个选课系统，学生有学号，姓名和性别属性，课程有课程名和学分表一：(学号，姓名，性别，课程名，学分，成绩)    //主键为(学号，课程名)为主键，姓名依赖于学号，而不依赖于课程名，不满足第二范式表二：(学号，姓名，性别)+(课程名，学分)+(学号，课程名，成绩)    //满足第二范式</code></pre><h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h3><p><strong>必须先满足第二范式（2NF），要求表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）</strong></p><ul><li>每列都和主键直接相关，而不是间接相关</li><li>如果一个关系满足2NF，每一个属性只依赖于主键，而不依赖其他属性，则满足第三范式</li></ul><pre><code>一个学生信息名单，学生有学号，地区有邮编表一：(学号，姓名，地址，邮编)        //邮编依赖于地址，再依赖于学号，不满足第三范式表二：(学号，姓名，地址)+(地址，邮编)    //分成两个表，每一个表均满足第三范式</code></pre><h2 id="不满足三范式的危害"><a href="#不满足三范式的危害" class="headerlink" title="不满足三范式的危害"></a>不满足三范式的危害</h2><p>以第二个例子</p><ul><li><p>数据冗余</p><p>假设一共有学生1000个，共有10门课，每个学生要选5门课，则学分数据重复了（5*1000-10）次</p></li><li><p>更新异常</p><p>若本来高数学分为4，现在要调整为5，则所有的选高数的都要更新，否则学分数据不一致</p></li><li><p>插入异常</p><p>如果新开一门课，还没有学生选择，因为主键中必须包含学号，所以只有课程无法插入</p></li><li><p>删除异常</p><p>假设有一门很烂的课，只有一人选择，现在他要退选，则数据库中便没有了该课的信息</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/waj6511988/p/7027127.html" target="_blank" rel="noopener">https://www.cnblogs.com/waj6511988/p/7027127.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型</title>
      <link href="/2019/01/04/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/01/04/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><h3 id="基本数据类型与封装器类的关系"><a href="#基本数据类型与封装器类的关系" class="headerlink" title="基本数据类型与封装器类的关系"></a>基本数据类型与封装器类的关系</h3><table><thead><tr><th>数据类型</th><th>大小/位</th><th>封装类</th><th>默认值（封装类默认为null）</th><th>数据范围</th></tr></thead><tbody><tr><td>byte</td><td>8bit/1字节</td><td>Byte</td><td>0</td><td>$[-128,127]$</td></tr><tr><td>boolean</td><td>8bit/1字节</td><td>Boolean</td><td>false</td><td>true/false</td></tr><tr><td>short</td><td>16bit/2字节</td><td>Short</td><td>0</td><td>$[-32768,32767]$</td></tr><tr><td>char</td><td>16bit/2字节</td><td>Character</td><td>‘\u0000’（对应数字0，输出为空）</td><td>$[0,65535]$</td></tr><tr><td>int</td><td>32bit/4字节</td><td>Integer</td><td>0</td><td>$[-2^{31},2^{31}-1]$</td></tr><tr><td>float</td><td>32bit/4字节</td><td>Float</td><td>0.0F</td><td>$[1.4E-45,3.4E38]$</td></tr><tr><td>long</td><td>64bit/8字节</td><td>Long</td><td>0L</td><td>$[-2^{63},2^{63}-1]$</td></tr><tr><td>double</td><td>64bit/8字节</td><td>Double</td><td>0.0D</td><td>$[4.9E-324,1.8E308]$</td></tr></tbody></table><h3 id="基本数据类型与封装器类在内存中的差别"><a href="#基本数据类型与封装器类在内存中的差别" class="headerlink" title="基本数据类型与封装器类在内存中的差别"></a>基本数据类型与封装器类在内存中的差别</h3><p>基本数据类型存放在栈中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后在栈中查找有没有字面值为3的地址，没找到，就在栈开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在栈中创建完b这个引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。</p><p>封装器类创建的对象和普通对象一样，存放在堆中</p><pre class=" language-java"><code class="language-java">Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> a<span class="token punctuation">;</span></code></pre><p>执行Integer a = new Integer(3)，首先会在java堆中创建一个new Integer(3)的实例，然后再在栈中创建一个指向该实例的引用a；执行Integer b = new Integer(3)时，同样，首先会在java堆中创建一个new Integer(3)的实例（与第一句创建的实例不一样），然后再在栈中创建一个指向该实例的引用b；执行Integer c = a，则在栈中创建一个实例的引用c，和a指向同一实例</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="自动数据类型转换"><a href="#自动数据类型转换" class="headerlink" title="自动数据类型转换"></a>自动数据类型转换</h4><p>自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下：</p><pre><code>低---------------------------------------------&gt;高byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double注意：char在转为高级或者直接加减运算时，char类型会转换为对应ASCII码值</code></pre><h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><p>强制转换的格式是在需要转型的数据前加上“( )”，然后在括号内加入需要转化的数据类型。高级数据类型转为低级数据类型，数据精度丢失</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">10.66</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//10</span></code></pre><h4 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">double</span> num <span class="token operator">=</span> <span class="token number">0.123456789</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//利用BigDecimal做中间转换</span>BigDecimal bigDecimal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> num1 <span class="token operator">=</span> bigDecimal<span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.12</span><span class="token comment" spellcheck="true">//利用DecimalFormat，返回String类型</span>DecimalFormat decimalFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecimalFormat</span><span class="token punctuation">(</span><span class="token string">"#.000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String num2 <span class="token operator">=</span> decimalFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.123</span><span class="token comment" spellcheck="true">//直接使用String.format，返回String类型</span><span class="token keyword">double</span> num3 <span class="token operator">=</span> Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%.4f"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0.1235</span></code></pre><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(), doubleValue()这类的方法将对象转换成原始类型值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token operator">-</span><span class="token number">128</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// high value may be configured by property</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Use Long.decode here to avoid invoking methods that</span>            <span class="token comment" spellcheck="true">// require Integer's autoboxing cache to be initialized</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> Long<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>            h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        high <span class="token operator">=</span> h<span class="token punctuation">;</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>对于-128至127这256个值，直接获取的IntegerCache中的值。 而IntegerCache是Integer中的一个静态内部类，里面将-128至127（即一个字节所能表示的所有带符号值 -2^7至2^7-1）的包装类存在了一个数组中。 对于-128到127之间的数，直接从数组中获取，其他的数则使用new生成。</p><p>因此，当对一个不在范围内的数进行拆箱装箱，最后两个Integer的对象不会相等，而对于在范围内的数进行拆箱装箱，最后两个Integer的对象会相等</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//范围外</span>Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">13452</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//false</span><span class="token comment" spellcheck="true">//范围内</span>Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p>赋值时</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//before autoboxing</span>Integer a <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//after java5</span>Integer a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//装箱 </span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//拆箱 </span></code></pre></li><li><p>方法调用时</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">test</span><span class="token punctuation">(</span>Integer a<span class="token punctuation">)</span><span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先装箱，再拆箱</span></code></pre></li><li><p>循环问题（不可使用）</p><pre class=" language-java"><code class="language-java">Integer sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   sum<span class="token operator">+=</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>+操作方不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象，实际如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> sum<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>Integer sum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样，中间会创建5000个Integer对象，造成空间资源和垃圾回收资源的浪费</p></li><li><p>重载与装箱</p><p>在引入装箱之前，value(int)和value(Integer)是完全不相同的方法，开发者不会因为传入是int还是Integer调用哪个方法困惑。现在由于自动装箱和拆箱的引入，两个方法应该是同相同的方法，但实际上，<strong>自动装箱拆箱对方法的重载并无影响。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Integer b<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b = "</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Reload reload <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reload<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打印a = 5</span>    reload<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//打印b = 10</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="float与double精度丢失问题"><a href="#float与double精度丢失问题" class="headerlink" title="float与double精度丢失问题"></a>float与double精度丢失问题</h2><h3 id="精度丢失的原因"><a href="#精度丢失的原因" class="headerlink" title="精度丢失的原因"></a>精度丢失的原因</h3><p>例子：</p><pre><code>举例：double result = 1.0 - 0.9;这个结果不用说了吧，都知道了，0.09999999999999998</code></pre><p>为什么会出现这个问题呢，就这是java和其它计算机语言都会出现的问题，下面我们分析一下为什么会出现这个问题：<br>float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。float和double类型尤其不适合用于货币运算，因为要让一个float或double精确的表示0.1或者10的任何其他负数次方值是不可能的（其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10）。</p><p>浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。往往产生误差不是因为数的大小，而是因为数的精度。因此，产生的结果接近但不等于想要的结果。尤其在使用 float 和 double 作精确运算的时候要特别小心。</p><p>现在我们就详细剖析一下浮点型运算为什么会造成精度丢失？</p><pre><code>首先我们要搞清楚下面两个问题：     (1) 十进制整数如何转化为二进制数           算法很简单。举个例子，11表示成二进制数：                     11/2=5 余   1                       5/2=2   余   1                       2/2=1   余   0                       1/2=0   余   1                          0结束         11二进制表示为(从下往上):1011          这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，整数永远可以用二进制精确表示 ，但小数就不一定了。      (2) 十进制小数如何转化为二进制数           算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数                     0.9*2=1.8   取整数部分 1                     0.8(1.8的小数部分)*2=1.6    取整数部分 1                     0.6*2=1.2   取整数部分 1                     0.2*2=0.4   取整数部分 0                     0.4*2=0.8   取整数部分 0                     0.8*2=1.6 取整数部分 1                     0.6*2=1.2   取整数部分 0                              .........                           0.9二进制表示为(从上往下): 11100100100100......           注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了&quot;减不尽&quot;的精度丢失问题。</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>利用java.math.BigDecimal，BigDecimal构造部分代码没怎么看懂，查资料查到直接将double转为BigDecimal仍然会出现误差，必须使用String类型转为BigDecimal才能无误差。</p><p>所以，应当先将double转为String，再将String转为BigDecimal才能进行无误差的运算。下面是网上编写的Arith工具类，完成的就是上诉功能。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>math<span class="token punctuation">.</span>BigDecimal<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*** 由于Java的简单类型不能够精确的对浮点数进行运算，这个工具类提供精* 确的浮点数运算，包括加减乘除和四舍五入。*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Arith</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//默认除法运算精度</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEF_DIV_SCALE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这个类不能实例化</span>    <span class="token keyword">private</span> <span class="token function">Arith</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的加法运算。     * @param v1 被加数     * @param v2 加数     * @return 两个参数的和     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的减法运算。     * @param v1 被减数     * @param v2 减数     * @return 两个参数的差     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的乘法运算。     * @param v1 被乘数     * @param v2 乘数     * @return 两个参数的积     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到     * 小数点以后10位，以后的数字四舍五入。     * @param v1 被除数     * @param v2 除数     * @return 两个参数的商     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">div</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span>v2<span class="token punctuation">,</span>DEF_DIV_SCALE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指     * 定精度，以后的数字四舍五入。     * @param v1 被除数     * @param v2 除数     * @param scale 表示表示需要精确到小数点以后几位。     * @return 两个参数的商     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span><span class="token keyword">double</span> v2<span class="token punctuation">,</span><span class="token keyword">int</span> scale<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>scale<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                <span class="token string">"The scale must be a positive integer or zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span>scale<span class="token punctuation">,</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供精确的小数位四舍五入处理。     * @param v 需要四舍五入的数字     * @param scale 小数点后保留几位     * @return 四舍五入后的结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">double</span> v<span class="token punctuation">,</span><span class="token keyword">int</span> scale<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>scale<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                <span class="token string">"The scale must be a positive integer or zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        BigDecimal b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>one<span class="token punctuation">,</span>scale<span class="token punctuation">,</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String，StringBuffer，StringBuilder的区别"><a href="#String，StringBuffer，StringBuilder的区别" class="headerlink" title="String，StringBuffer，StringBuilder的区别"></a>String，StringBuffer，StringBuilder的区别</h3><ul><li>String是字符串常量，任何对String的改变都会引发新的String对象的生成，对字符串进行大量修改时不要用String</li><li>StringBuffer，StringBuilder是可变类，任何对它所指代的字符串的改变都不会产生新的对象</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的，单线程下使用StringBuilder</li><li>StringBuffer几个常用的方法<ul><li>append():将新添加的内容连接到调用字符串的末尾</li><li>reverse():颠倒字符串</li><li>detele()：删除指定位置的字符串</li><li>insert(int index，String str)：将一个字符串插入到另一个字符串中指定位置。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/tomcat_2014/article/details/51453988" target="_blank" rel="noopener">https://blog.csdn.net/tomcat_2014/article/details/51453988</a></p><p><a href="https://blog.csdn.net/Evankaka/article/details/44651887" target="_blank" rel="noopener">https://blog.csdn.net/Evankaka/article/details/44651887</a></p><p><a href="https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="noopener">https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
